<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RP&#39;s Blog</title>
  
  <subtitle>学习总结  思考感悟</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://paradoxallen.github.io/"/>
  <updated>2018-08-24T05:33:50.022Z</updated>
  <id>https://paradoxallen.github.io/</id>
  
  <author>
    <name>LRP</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>提问的智慧</title>
    <link href="https://paradoxallen.github.io/34680/"/>
    <id>https://paradoxallen.github.io/34680/</id>
    <published>2018-08-19T16:00:00.000Z</published>
    <updated>2018-08-24T05:33:50.022Z</updated>
    
    <content type="html"><![CDATA[<p>这里有一篇文章是关于“提问的智慧”（How To Ask Questions in The Smart Way），虽然文章的假设对象是黑客，但觉得帮助作用甚大，所以就从论坛搬过来了。。。在这里仅代表问题帮向热心为我们答疑解惑的各位致以最崇高的敬意，你们辛苦啦！</p><p><img src="https://i.imgur.com/Z2ttQsd.png" alt=""></p><p>内容如下：<br>   在黑客世界里，当提出一个技术问题时，你能得到怎样的回答？这取决于挖出答案的难度，同样取决于你提问的方法。本指南旨在帮助你提高发问技巧，以获取你最想要的答案。</p><p>   首先你必须明白，黑客们只偏爱艰巨的任务，或者能激发他们思维的好问题。如若不然，我们还来干吗？如果你有值得我们反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼，可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，“问得好！”是发自内心的大力称赞。</p><p>   尽管黑客们有蔑视简单问题和不友善的坏名声，有时看起来似乎我们对新手，对知识贫乏者怀有敌意，但其实不是那样的。</p><p>   我们不想掩饰对这样一些人的蔑视–他们不愿思考，或者在发问前不去完成他们应该做的事。这种人只会谋杀时间–他们只愿索取，从不付出，无端消耗我们的时间，而我们本可以把时间用在更有趣的问题或者更值得回答的人身上。我们称这样的人为“失败者”（由于历史原因，我们有时把它拼作“lusers”）。</p><p>   我们在很大程度上属于志愿者，从繁忙的生活中抽出时间来解惑答疑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是抛弃那些看起来像失败者的家伙，以便更高效的利用时间来回答胜利者的问题。<br>   如果你觉得我们过于傲慢的态度让你不爽，让你委屈，不妨设身处地想想。我们并没有要求你向我们屈服–事实上，我们中的大多数人最喜欢公平交易不过了，只要你付出小小努力来满足最起码的要求，我们就会欢迎你加入到我们的文化中来。但让我们帮助那些不愿意帮助自己的人是没有意义的。如果你不能接受这种“歧视”，我们建议你花点钱找家商业公司签个技术支持协议得了，别向黑客乞求帮助。</p><p>   如果你决定向我们求助，当然不希望被视为失败者，更不愿成为失败者中的一员。立刻得到有效答案的最好方法，就是像胜利者那样提问–聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。</p><h3 id="提问之前"><a href="#提问之前" class="headerlink" title="======== 提问之前 ========"></a>======== 提问之前 ========</h3><p>   在通过电邮、新闻组或者聊天室提出技术问题前，检查你有没有做到：</p><ol><li>通读手册，试着自己找答案。</li><li>在FAQ里找答案(一份维护得好的FAQ可以包罗万象)。</li><li>在网上搜索(个人推荐google~~~)。</li><li>向你身边精于此道的朋友打听。</li></ol><p>当你提出问题的时候，首先要说明在此之前你干了些什么；这将有助于树立你的形象：你不是一个妄图不劳而获的乞讨者，不愿浪费别人的时间。如果提问者能从答案中学到东西，我们更乐于回答他的问题。</p><p>   周全的思考，准备好你的问题，草率的发问只能得到草率的回答，或者根本得不到任何答案。越表现出在寻求帮助前为解决问题付出的努力，你越能得到实质性的帮助。</p><p>   小心别问错了问题。如果你的问题基于错误的假设，普通黑客(J. Random Hacker)通常会用无意义的字面解释来答复你，心里想着“蠢问题…”，希望着你会从问题的回答(而非你想得到的答案)中汲取教训。</p><p>   决不要自以为够资格得到答案，你没这种资格。毕竟你没有为这种服务支付任何报酬。你要自己去“挣”回一个答案，靠提出一个有内涵的，有趣的，有思维激励作用的问题–一个对社区的经验有潜在贡献的问题，而不仅仅是被动的从他人处索要知识–去挣到这个答案。<br>   另一方面，表明你愿意在找答案的过程中做点什么，是一个非常好的开端。“谁能给点提示？”、“我这个例子里缺了什么？”以及“我应该检查什么地方？”比“请把确切的过程贴出来”更容易得到答复。因为你显得只要有人指点正确的方向，你就有完成它的能力和决心。</p><h3 id="怎样提问"><a href="#怎样提问" class="headerlink" title="======== 怎样提问 ========"></a>======== 怎样提问 ========</h3><p>   ☆ 谨慎选择论坛版块<br>   小心选择提问的场合。如果象下面描述的那样，你很可能被忽略掉或者被看作失败者：</p><ol><li>在风马牛不相及的论坛贴出你的问题</li><li>在探讨高级技巧的论坛张贴非常初级的问题；反之亦然</li><li>在太多的不同新闻组交叉张贴<br>☆ 用辞贴切，语法正确，拼写无误</li></ol><p>我们从经验中发现，粗心的写作者通常也是马虎的思考者(我敢打包票)。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。</p><p>   正确的拼写，标点符号和大小写很重要。更一般的说，如果你的提问写得象个半文盲，你很有可能被忽视。</p><p>   如果你在使用非母语的论坛提问，你可以犯点拼写和语法上的小错–但决不能在思考上马虎(没错，我们能弄清两者的分别)<br>   ☆ 使用含义丰富，描述准确的标题</p><p>   在邮件列表或者新闻组中，大约50字以内的主题标题是抓住资深专家注意力的黄金时机。别用喋喋不休的“帮帮忙”(更别说“救命啊！！！！！”这样让人反感的话)来浪费这个机会。不要妄想用你的痛苦程度来打动我们， 别用空格代替问题的描述，哪怕是极其简短的描述。</p><p>   蠢问题： 救命啊！我的膝上机不能正常显示了！<br>   聪明问题： XFree86 4.1下鼠标光标变形，FoowareMV1005的显示芯片。</p><p>   如果你在回复中提出问题，记得要修改内容标题，表明里面有一个问题。一个看起来象“Re：测试”或者“Re：新bug”的问题很难引起足够重视。另外，引用并删减前文的内容，给新来的读者留下线索。</p><p>   ☆ 精确描述，信息量大</p><ol><li>谨慎明确的描述症状。</li><li>提供问题发生的环境(机器配置、操作系统、应用程序以及别的什么)。</li><li>说明你在提问前是怎样去研究和理解这个问题的。</li><li>说明你在提问前采取了什么步骤去解决它。</li><li><p>罗列最近做过什么可能有影响的硬件、软件变更。<br>尽量想象一个黑客会怎样反问你，在提问的时候预先给他答案。</p><p>☆ 话不在多<br>你需要提供精确有效的信息。这并不是要求你简单的把成吨的出错代码或者数据完全转储摘录到你的提问中。如果你有庞大而复杂的测试条件，尽量把它剪裁得越小越好。<br>这样做的用处至少有三点。</p><p>第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加；<br>第二，简化问题使你得到有用答案的机会增加；<br>第三，在提炼你的bug报告的过程中，也许你自己就能找出问题所在或作出更正。</p><p>☆ 只说症状，不说猜想<br>告诉黑客们你认为问题是怎样引起的没什么帮助。(如果你的推断如此有效，还用向别人求助吗？)，因此要确信你原原本本告诉了他们问题的症状，不要加进你自己的理解和推论。让黑客们来诊断吧。<br>蠢问题： 我在内核编译中一次又一次遇到SIG11错误，我怀疑某条飞线搭在主板的走线上了， 这种情况应该怎样检查最好？<br>聪明问题： 我自制的一套K6/233系统，主板是FIC-PA2007(VIA Apollo VP2芯片组)，256MBCorsair PC133 SDRAM，在内核编译中频频产生SIG11错误，从开机20分钟以后就有这种情况，开机前20分钟内从没发生过。重启也没有用，但是关机一晚上就又能工作20分钟。所有内存都换过了，没有效果。相关部分的典型编译记录如下…。<br>☆ 按时间顺序列出症状</p><p>对找出问题最有帮助的线索，往往就是问题发生前的一系列操作，因此，你的说明应该包含操作步骤，以及电脑的反应，直到问题产生。<br>如果你的说明很长(超过四个段落)，在开头简述问题会有所帮助，接下来按时间顺序详述。这样黑客们就知道该在你的说明中找什么。<br>☆ 明白你想问什么</p><p>漫无边际的提问近乎无休无止的时间黑洞。最能给你有用答案的人也正是最忙的人(他们忙是因为要亲自完成大部分工作)。这样的人对无节制的时间黑洞不太感冒，因此也可以说他们对漫无边际的提问不大感冒。</p><p>如果你明确表述需要回答者做什么(提供建议，发送一段代码，检查你的补丁或是别的)，就最有可能得到有用的答案。这会定出一个时间和精力的上限，便于回答者集中精力来帮你，这很凑效。<br>要理解专家们生活的世界，要把专业技能想象为充裕的资源，而回复的时间则是贫乏的资源。解决你的问题需要的时间越少，越能从忙碌的专家口中掏出答案。</p><p>因此，优化问题的结构，尽量减少专家们解决它所需要的时间，会有很大的帮助–这通常和简化问题有所区别。因此，问“我想更好的理解X，能给点提示吗？”通常比问“你能解释一下X吗？”更好。如果你的代码不能工作，问问它有什么地方不对，比要求别人替你修改要明智得多。</p><p>☆ 别问应该自己解决的问题<br>黑客们总是善于分辨哪些问题应该由你自己解决；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由你来搞定，你会从中学到东西。</p><p>你可以要求给点提示，但别要求得到完整的解决方案。</p><p>☆ 去除无意义的疑问<br>别用无意义的话结束提问，例如“有人能帮我吗？”或者“有答案吗？”。</p><p>首先：如果你对问题的描述不很合适，这样问更是画蛇添足。其次：由于这样问是画蛇添足，黑客们会很厌烦你–而且通常会用逻辑上正确的回答来表示他们的蔑视，例如：“没错，有人能帮你”或者“不，没答案”。</p><p>☆ 谦逊绝没有害处，而且常帮大忙<br>彬彬有礼，多用“请”和“先道个谢了”。让大家都知道你对他们花费时间义务提供帮助心存感激。</p><p>然而，如果你有很多问题无法解决，礼貌将会增加你得到有用答案的机会。(我们注意到，自从本指南发布后，从资深黑客处得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得“先谢了”的言外之意是过后就不会再感谢任何人了。我们的建议是：都道谢。)</p><p>☆ 问题解决后，加个简短说明<br>问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个补充说明。</p><p>补充说明不必很长或是很深入；简单的一句“你好，原来是网线出了问题！谢谢大家–Bill”比什么也不说要强。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇学术论文更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。<br>除了表示礼貌和反馈信息以外，这种补充有助于他人在邮件列表/新闻组/论坛中搜索对你有过帮助的完整解决方案，这可能对他们也很有用。</p><p>最后(至少？)，这种补充有助于所有提供过帮助的人从中得到满足感。</p><p>如果你自己不是老手或者黑客，那就相信我们，这种感觉对于那些你向他们求助的导师或者专家而言，是非常重要的。问题久拖未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次贴出新问题时尝到甜头。</p><p>☆ 还是不懂<br>如果你不是很理解答案，别立刻要求对方解释。象你以前试着自己解决问题时那样(利用手册，FAQ，网络，身边的高手)，去理解它。如果你真的需要对方解释，记得表现出你已经学到了点什么。<br>比方说，如果我回答你：“看来似乎是zEntry被阻塞了；你应该先清除它。”，然后：一个很糟的后续问题：“zEntry是什么？”<br>聪明的问法应该是这样：“哦~~~我看过帮助了但是只有-z和-p两个参数中提到了zEntry而且还都没有清楚的解释:&lt;你是指这两个中的哪一个吗？还是我看漏了什么？”</p></li></ol><h3 id="三思而后问"><a href="#三思而后问" class="headerlink" title="======== 三思而后问 ========"></a>======== 三思而后问 ========</h3><p>   以下是几个经典蠢问题，以及黑客在拒绝回答时的心中所想：<br>   问题：我能在哪找到X程序？<br>   问题：我的程序/配置/SQL申明没有用<br>   问题：我的Windows有问题，你能帮我吗？<br>   问题：我在安装Linux(或者X)时有问题，你能帮我吗？<br>   问题：我怎么才能破解root帐号/窃取OP特权/读别人的邮件呢？<br>   提问：我能在哪找到X程序？ 回答：就在我找到它的地方啊蠢货–搜索引擎的那一头。天呐！还有人不会用Google吗？<br>   提问：我的程序(配置、SQL申明)没有用回答：这不算是问题吧，我对找出你的真正问题没兴趣–如果要我问你二十个问题才找得出来的话–我有更有意思的事要做呢。</p><p>   在看到这类问题的时候，我的反应通常不外如下三种：</p><ol><li>你还有什么要补充的吗？</li><li>真糟糕，希望你能搞定。</li><li>这跟我有什么鸟相关？</li></ol><p>提问：我的Windows有问题，你能帮我吗？ 回答：能啊，扔掉萎软的垃圾，换Linux吧。<br>   提问：我在安装Linux(或者X)时有问题，你能帮我吗？回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的Linux用户组寻求手把手的指导吧(你能在这儿找到用户组的清单)。<br>   提问：我怎么才能破解root帐号/窃取OP特权/读别人的邮件呢？回答：想要这样做，说明你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！</p><h3 id="好问题，坏问题"><a href="#好问题，坏问题" class="headerlink" title="======== 好问题，坏问题 ========"></a>======== 好问题，坏问题 ========</h3><p>   最后，我举一些例子来说明，怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。<br>   蠢问题：我可以在哪儿找到关于Foonly Flurbamatic的资料？<br>这种问法无非想得到“STFW”这样的回答。</p><p>   聪明问题：我用Google搜索过“FoonlyFlurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？<br>   这个问题已经STFW过了，看起来他真的遇到了麻烦。</p><p>蠢问题：我从FOO项目找来的源码没法编译。它怎么这么烂？<br>   他觉得都是别人的错，这个傲慢自大的家伙</p><p>聪明问题：FOO项目代码在Nulix 6.2版下无法编译通过。我读过了FAQ，但里面没有提到跟Nulix有关的问题。这是我编译过程的记录，我有什么做得不对的地方吗？<br>   他讲明了环境，也读过了FAQ，还指明了错误，并且他没有把问题的责任推到别人头上，这个家伙值得留意。</p><p>蠢问题：我的主板有问题了，谁来帮我？<br>   普通黑客对这类问题的回答通常是：“好的，还要帮你拍拍背和换尿布吗？”，然后按下删除键。</p><p>聪明问题：我在S2464主板上试过了X、Y和Z，但没什么作用，我又试了A、B和C。请注意当我尝试C时的奇怪现象。显然边带传输中出现了收缩，但结果出人意料。在多处理器主板上引起边带泄漏的通常原因是什么？谁有好主意接下来我该做些什么测试才能找出问题？<br>   这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。</p><p>在最后一个问题中，注意“告诉我答案”和“给我启示，指出我还应该做什么诊断工作”之间微妙而又重要的区别。<br>   事实上，后一个问题源自于2001年8月在Linux内核邮件列表上的一个真实的提问。我(Eric)就是那个提出问题的人。我在Tyan S2464主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决那一问题的重要信息。</p><p> 通过我的提问方法，我给了大家值得玩味的东西；我让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，邀请他们与我共同探讨。我告诉他们我所走过的弯路，以避免他们再浪费时间，这是一种对他人时间价值的尊重。</p><p>后来，当我向每个人表示感谢，并且赞赏这套程序(指邮件列表中的讨论–译者注)运作得非常出色的时候，一个Linux内核邮件列表(lkml)成员表示，问题得到解决并非由于我是这个列表中的“名人”，而是因为我用了正确的方式来提问。</p><p>我们黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我象个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，给编写这个指南的人一些指导。</p><h3 id="找不到答案怎么办"><a href="#找不到答案怎么办" class="headerlink" title="======== 找不到答案怎么办 ========"></a>======== 找不到答案怎么办 ========</h3><p>   如果仍得不到答案，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。</p><p>   总的说来，简单的重复张贴问题是个很糟的想法。这将被视为无意义的喧闹。你可以通过其它渠道获得帮助，这些渠道通常更适合初学者的需要。有许多网上的以及本地的用户组，由狂热的软件爱好者(即使他们可能从没亲自写过任何软件)组成。通常人们组建这样的团体来互相帮助并帮助新手。</p><p>另外，你可以向很多商业公司寻求帮助，不论公司大还是小(RedHat和LinuxCare就是两个最常见的例子)。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了–完全可能如此–你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。</p><p>对大众化的软件，就象Linux之类而言，每个开发者至少会有上万名用户。根本不可能由一个人来处理来自上万名用户的求助电话。要知道，即使你要为帮助付费，同你必须购买同类软件相比，你所付出的也是微不足道的(通常封闭源代码软件的技术支持费用比开放源代码软件要高得多，且内容也不那么丰富)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里有一篇文章是关于“提问的智慧”（How To Ask Questions in The Smart Way），虽然文章的假设对象是黑客，但觉得帮助作用甚大，所以就从论坛搬过来了。。。在这里仅代表问题帮向热心为我们答疑解惑的各位致以最崇高的敬意，你们辛苦啦！&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="个人随笔" scheme="https://paradoxallen.github.io/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="提问" scheme="https://paradoxallen.github.io/tags/%E6%8F%90%E9%97%AE/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫代码———拉勾数据分析师岗位数据分析</title>
    <link href="https://paradoxallen.github.io/19544/"/>
    <id>https://paradoxallen.github.io/19544/</id>
    <published>2018-07-31T16:00:00.000Z</published>
    <updated>2018-08-21T07:24:35.329Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">fi = &apos;F:\cs\python\code\lagou_dataanalysis_craping\lagou3.0.txt&apos;</span><br><span class="line"></span><br><span class="line">#read_csv()表示读取csv格式文件，&apos;gb2312&apos;表示csv文件格式的编码</span><br><span class="line"></span><br><span class="line">df = pd.read_table(fi,  encoding=&apos;gbk&apos;)</span><br><span class="line"></span><br><span class="line">df.head()</span><br><span class="line">df = df.iloc[:,0].str.split(&apos;@@@&apos;, expand=True)</span><br><span class="line">df.columns = [&apos;city&apos;,&apos;companyFullName&apos;,&apos;companyId&apos;,&apos;companyLabelList&apos;,&apos;companyShortName&apos;,&apos;companySize&apos;,&apos;businessZones&apos;,&apos;firstType&apos;,&apos;secondType&apos;,&apos;education&apos;,&apos;industryField&apos;,&apos;positionId&apos;,&apos;positionAdvantage&apos;,&apos;positionName&apos;,&apos;positionLables&apos;,&apos;salary&apos;,&apos;workYear&apos;]</span><br><span class="line">#df = pd.DataFrame(df)</span><br><span class="line">#读取前五行</span><br><span class="line">df.head()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">df_duplicates=df.drop_duplicates(subset=&apos;positionId&apos;,keep=&apos;first&apos;)#keep=&apos;first&apos;表示保留第一个，删除后面的重复值；keep=&apos;last&apos;表示保留最后一个，删除前面的重复值</span><br><span class="line">def cut_word(word,method):</span><br><span class="line">    position=word.find(&apos;-&apos;)       #查找“7k-8k”这种形式&quot;-&quot;的位置</span><br><span class="line">    length=len(word)         </span><br><span class="line">    if position !=-1:       # &quot;-1&quot; 是False的意思，表示字符串中存在&apos;-&apos;</span><br><span class="line">        bottomsalary=word[:position-1]</span><br><span class="line">        topsalary=word[position+1:length-1]</span><br><span class="line">    else:</span><br><span class="line">        bottomsalary=word[:word.upper().find(&apos;K&apos;)]    #这里是指不存在&apos;10k-15k&apos;这种形式，数据中存在7k以上，k有的大写有的小写</span><br><span class="line">        topsalary=bottomsalary</span><br><span class="line">    if method==&quot;bottom&quot;:        #获得工资下限</span><br><span class="line">        return bottomsalary</span><br><span class="line">    else:</span><br><span class="line">        return topsalary          #获得工资的上限</span><br><span class="line">df_duplicates[&apos;topsalary&apos;]=df_duplicates.salary.apply(cut_word,method=&quot;top&quot;)  # apply()函数形式：apply(func,*args,**kwargs)，*args相当于元组，**kwargs相当于字典</span><br><span class="line">df_duplicates[&quot;bottomsalary&quot;]=df_duplicates.salary.apply(cut_word,method=&quot;bottom&quot;)#apply()函数作用：用来间接的调用一个函数，并把参数传递给函数</span><br><span class="line">df_duplicates.bottomsalary.astype(&apos;int&apos;)# 字符串转为数值型</span><br><span class="line">df_duplicates.topsalary.astype(&apos;int&apos;)</span><br><span class="line">df_duplicates[&quot;avgsalary&quot;]=df_duplicates.apply(lambda x:(int(x.bottomsalary)+int(x.topsalary))/2,axis=1)  #lambda是一种函数，举例：lambda x:x+1,x是参数，x+1是表达式;axis=1表示作用于行</span><br><span class="line">df_duplicates</span><br><span class="line"></span><br><span class="line">#选出我们想要的内容进行后续分析</span><br><span class="line">#总体薪酬情况</span><br><span class="line">df_clean=df_duplicates[[&apos;city&apos;,&apos;companyShortName&apos;,&apos;companySize&apos;,&apos;education&apos;,&apos;positionName&apos;,&apos;positionLables&apos;,&apos;workYear&apos;,&apos;avgsalary&apos;,&apos;industryField&apos;]]</span><br><span class="line">import matplotlib.pyplot as plt       </span><br><span class="line">#matplotlib inline  #%matplotlib inline是jupyter自带的方式，允许图表在cell中输出。</span><br><span class="line">plt.style.use(&quot;ggplot&quot;)    #使用R语言中的ggplot2配色作为绘图风格，为好看</span><br><span class="line">from matplotlib.font_manager import FontProperties        #matplotlib.Font_manager 是一种字体管理工具</span><br><span class="line">zh_font = FontProperties(fname=&quot;C:\\WINDOWS\\Fonts\\simsun.ttc&quot;)#matplotlib.Font_manager.FontProperties(fname) 是指定一种字体，C:\\WINDOWS\\Fonts\\simsun.ttc 是字体路径，直接复制到电脑搜索，你看能不能找到</span><br><span class="line">fig=plt.figure(figsize=(8,5))        #关于绘图方面，文末放了一个链接，讲述的比较详细</span><br><span class="line">ax=plt.subplot(111)</span><br><span class="line">rect=ax.hist(df_duplicates[&quot;avgsalary&quot;],bins=30)</span><br><span class="line">ax.set_title(u&apos;薪酬分布&apos;,fontProperties=zh_font)</span><br><span class="line">ax.set_xlabel(u&apos;K/月&apos;,fontProperties=zh_font)     </span><br><span class="line">plt.xticks(range(5,100,5))     #xticks为x轴主刻度和次刻度设置颜色、大小、方向，以及标签大小。</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">#不同城市薪酬分布情况</span><br><span class="line">ax=df_clean.boxplot(column=&apos;avgsalary&apos;,by=&apos;city&apos;,figsize=(9,7))</span><br><span class="line">for label in ax.get_xticklabels():</span><br><span class="line">    label.set_fontproperties(zh_font)</span><br><span class="line">    </span><br><span class="line">#不同学历的薪酬分布</span><br><span class="line">ax=df_clean.boxplot(column=&apos;avgsalary&apos;,by=&apos;education&apos;,figsize=(9,7))</span><br><span class="line">for label in ax.get_xticklabels():</span><br><span class="line">    label.set_fontproperties(zh_font)</span><br><span class="line"></span><br><span class="line">#招聘人数</span><br><span class="line">df_clean.groupby([&apos;city&apos;,&apos;education&apos;]).avgsalary.count().unstack()   #unstack()函数可进行行列转置，大家不妨去掉看下效果</span><br><span class="line"></span><br><span class="line">#北京上海工作经验不同薪酬分布情况</span><br><span class="line">df_bj_sh=df_clean[df_clean[&apos;city&apos;].isin([&apos;上海&apos;,&apos;北京&apos;])]</span><br><span class="line">ax=df_bj_sh.boxplot(column=&apos;avgsalary&apos;,by=[&apos;workYear&apos;,&apos;city&apos;],figsize=(19,6))</span><br><span class="line">for label_x in ax.get_xticklabels():</span><br><span class="line">    label_x.set_fontproperties(zh_font)</span><br><span class="line">    </span><br><span class="line">#北上广深对数据分析职位需求量</span><br><span class="line">def topN(df,n=5):</span><br><span class="line">    counts=df.value_counts()    #value_counts()统计所有非零元素的个数  </span><br><span class="line">    return counts.sort_values(ascending=False)[:n]    #sort_values()对数据进行排序，ascending是设置升序和降序</span><br><span class="line">df_bj_sh_gz_sz=df_clean[df_clean[&apos;city&apos;].isin([&apos;上海&apos;,&apos;北京&apos;,&apos;广州&apos;,&apos;深圳&apos;])]</span><br><span class="line">df_bj_sh_gz_sz.groupby(&apos;city&apos;).positionName.apply(topN)</span><br><span class="line"></span><br><span class="line">#公司所处行业领域词云图分析</span><br><span class="line">import re  #re模块提供了对正则表达式的支持</span><br><span class="line">import jieba as jb</span><br><span class="line">from wordcloud import WordCloud</span><br><span class="line">word_str = &apos;,&apos;.join(df_clean[&apos;industryField&apos;]) # 以&apos;,&apos;为分隔符，将所有的元素合并成一个新的字符串,注意：csv文件中，单元格之间有逗号。</span><br><span class="line">#对文本进行分词</span><br><span class="line">word_split = jb.cut(word_str) #精确模式</span><br><span class="line">#使用|作为分隔符</span><br><span class="line">word_split1 = &quot;|&quot;.join(word_split)</span><br><span class="line">pattern=re.compile(&quot;移动|互联网|其他|金融|企业|服务|电子商务|O2O|数据|服务|医疗健康|游戏|社交网络|招聘|生活服务|文化娱乐|旅游|广告营销|教育|硬件|信息安全&quot;)</span><br><span class="line">#匹配所有文本字符；pattern 我们可以理解为一个匹配模式，用re.compile()方法来获得这个模式</span><br><span class="line">word_w=pattern.findall(word_split1)   #搜索word_split1，以列表形式返回全部能匹配的子串</span><br><span class="line">word_s = str(word_w)</span><br><span class="line">my_wordcloud = WordCloud(font_path=&quot;C:\\WINDOWS\\Fonts\\simsun.ttc&quot;,width=900,height=400,background_color=&quot;white&quot;).generate(word_s)</span><br><span class="line">plt.imshow(my_wordcloud)</span><br><span class="line">plt.axis(&quot;off&quot;)    #取出坐标轴</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="数据挖掘" scheme="https://paradoxallen.github.io/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="python" scheme="https://paradoxallen.github.io/tags/python/"/>
    
      <category term="爬虫" scheme="https://paradoxallen.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>预测北京和伦敦两个城市的空气质量</title>
    <link href="https://paradoxallen.github.io/18671/"/>
    <id>https://paradoxallen.github.io/18671/</id>
    <published>2018-06-17T16:00:00.000Z</published>
    <updated>2018-08-06T03:59:25.705Z</updated>
    
    <content type="html"><![CDATA[<p>源代码分享<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">import pickle</span><br><span class="line">import hashlib</span><br><span class="line">import requests</span><br><span class="line">import datetime</span><br><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">from tqdm import tqdm</span><br><span class="line">import lightgbm as lgb</span><br><span class="line">from io import StringIO</span><br><span class="line">from dateutil.parser import parse</span><br><span class="line">from datetime import date, timedelta</span><br><span class="line">from sklearn.preprocessing import LabelEncoder</span><br><span class="line"></span><br><span class="line">inplace = False</span><br><span class="line">cache_path = &apos;../cache/&apos;</span><br><span class="line">data_path = &apos;../data/&apos;</span><br><span class="line">station_dict = pd.read_csv(&apos;../data/station_dict.csv&apos;)</span><br><span class="line"></span><br><span class="line">##########################################基础工具包#######################################</span><br><span class="line"># 日期的加减</span><br><span class="line">def date_add_days(start_date, days):</span><br><span class="line">    end_date = parse(start_date[:10]) + timedelta(days=days)</span><br><span class="line">    end_date = end_date.strftime(&apos;%Y-%m-%d&apos;)</span><br><span class="line">    return end_date</span><br><span class="line"># 日期的加减</span><br><span class="line">def date_add_hours(start_date, hours):</span><br><span class="line">    end_date = parse(start_date) + timedelta(hours=hours)</span><br><span class="line">    end_date = end_date.strftime(&apos;%Y-%m-%d %H:%M:%S&apos;)</span><br><span class="line">    return end_date</span><br><span class="line"># 压缩数据降低精度</span><br><span class="line">def convert_dtypes(data,predictors,slient=False):</span><br><span class="line">    for c in predictors:</span><br><span class="line">        if data[c].dtypes == &apos;O&apos;:</span><br><span class="line">            try:</span><br><span class="line">                data[c] = data[c].astype(&apos;float32&apos;)</span><br><span class="line">            except:</span><br><span class="line">                if not slient:</span><br><span class="line">                    print(&apos;特征&#123;&#125;格式无法转换&apos;.format(c))</span><br><span class="line">        if data[c].dtypes == &apos;float64&apos;:</span><br><span class="line">            data[c] = data[c].astype(&apos;float32&apos;)</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">##########################################aq数据更新#######################################</span><br><span class="line">def up_date():</span><br><span class="line"></span><br><span class="line">    # 北京aq数据（起始时间2018-03-31-16）</span><br><span class="line">    url = &apos;https://biendata.com/competition/airquality/bj/2018-03-31-16/2018-06-11-23/2k0d1d8&apos;</span><br><span class="line">    # url = &apos;http://kdd.caiyunapp.com/competition/2k0d1d8/bj/2018-03-31-16/2018-06-11-23/airquality&apos;</span><br><span class="line">    respones= requests.get(url)</span><br><span class="line">    with open (data_path + &quot;bj_aq+.csv&quot;,&apos;w&apos;) as f:</span><br><span class="line">        f.write(respones.text)</span><br><span class="line"></span><br><span class="line">    # 伦敦aq数据（起始时间2018-03-31-16）</span><br><span class="line">    url = &apos;https://biendata.com/competition/airquality/ld/2018-03-31-16/2018-06-11-23/2k0d1d8&apos;</span><br><span class="line">    # url = &apos;http://kdd.caiyunapp.com/competition/2k0d1d8/ld/2018-03-31-16/2018-06-11-23/airquality&apos;</span><br><span class="line">    respones= requests.get(url)</span><br><span class="line">    with open (data_path + &quot;ld_aq+.csv&quot;,&apos;w&apos;) as f:</span><br><span class="line">        f.write(respones.text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    bj_aq_more = pd.read_csv(data_path + &apos;bj_aq_more.csv&apos;)</span><br><span class="line">    bj_aq_1718 = pd.read_csv(data_path + &apos;beijing_17_18_aq.csv&apos;)</span><br><span class="line">    bj_aq_0203 = pd.read_csv(data_path + &apos;beijing_201802_201803_aq.csv&apos;)</span><br><span class="line"></span><br><span class="line">    ld_aq = pd.read_csv(data_path + &apos;London_historical_aqi_forecast_stations_20180331.csv&apos;,index_col=0)</span><br><span class="line">    ld_other = pd.read_csv(data_path + &apos;London_historical_aqi_other_stations_20180331.csv&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    bj_aq = bj_aq_1718.append(bj_aq_0203).append(bj_aq_more)</span><br><span class="line">    del bj_aq_1718,bj_aq_0203,bj_aq_more</span><br><span class="line">    bj_aq.rename(columns=&#123;&apos;stationId&apos;:&apos;station_id&apos;,&apos;utc_time&apos;:&apos;time&apos;&#125;,inplace=True)</span><br><span class="line">    ld_aq.rename(columns=&#123;&apos;MeasurementDateGMT&apos;:&apos;time&apos;,&apos;PM2.5 (ug/m3)&apos;:&apos;PM2.5&apos;,&apos;PM10 (ug/m3)&apos;:&apos;PM10&apos;,&apos;NO2 (ug/m3)&apos;:&apos;NO2&apos;&#125;,inplace=True)</span><br><span class="line">    ld_aq[&apos;time&apos;] = pd.to_datetime(ld_aq[&apos;time&apos;]).astype(str)</span><br><span class="line">    ld_aq_more = pd.read_csv(data_path+&apos;ld_aq_more.csv&apos;)</span><br><span class="line">    ld_aq_more[&apos;time&apos;] = pd.to_datetime(ld_aq_more[&apos;time&apos;]).astype(str)</span><br><span class="line">    ld_other.rename(columns=&#123;&apos;MeasurementDateGMT&apos;:&apos;time&apos;,&apos;PM2.5 (ug/m3)&apos;:&apos;PM2.5&apos;,&apos;PM10 (ug/m3)&apos;:&apos;PM10&apos;,&apos;NO2 (ug/m3)&apos;:&apos;NO2&apos;,&apos;Station_ID&apos;:&apos;station_id&apos;&#125;,inplace=True)</span><br><span class="line">    ld_other.drop([&apos;Unnamed: 5&apos;,&apos;Unnamed: 6&apos;],axis=1,inplace=True)</span><br><span class="line">    ld_other[&apos;time&apos;] = pd.to_datetime(ld_other[&apos;time&apos;]).astype(str)</span><br><span class="line">    ld_aq = ld_aq.append(ld_other).append(ld_aq_more)</span><br><span class="line"></span><br><span class="line">    bj_aq1 = pd.read_csv(data_path + &apos;bj_aq+.csv&apos;)</span><br><span class="line">    ld_aq1 = pd.read_csv(data_path + &apos;ld_aq+.csv&apos;)</span><br><span class="line"></span><br><span class="line">    del bj_aq1[&apos;id&apos;]</span><br><span class="line">    bj_aq1.rename(columns=&#123;&apos;PM25_Concentration&apos;:&apos;PM2.5&apos;,&apos;PM10_Concentration&apos;:&apos;PM10&apos;,&apos;NO2_Concentration&apos;:&apos;NO2&apos;,</span><br><span class="line">                           &apos;CO_Concentration&apos;:&apos;CO&apos;,&apos;O3_Concentration&apos;:&apos;O3&apos;,&apos;SO2_Concentration&apos;:&apos;SO2&apos;&#125;,inplace=True)</span><br><span class="line">    bj_aq = bj_aq.append(bj_aq1)</span><br><span class="line">    bj_aq[&apos;station_id&apos;] = bj_aq[&apos;station_id&apos;].str[:-3]</span><br><span class="line">    del bj_aq1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ld_aq1.drop([&apos;id&apos;,&apos;CO_Concentration&apos;,&apos;O3_Concentration&apos;,&apos;SO2_Concentration&apos;],axis=1,inplace=True)</span><br><span class="line">    ld_aq1.rename(columns=&#123;&apos;NO2_Concentration&apos;:&apos;NO2&apos;,&apos;PM25_Concentration&apos;:&apos;PM2.5&apos;,&apos;PM10_Concentration&apos;:&apos;PM10&apos;&#125;,inplace=True)</span><br><span class="line">    ld_aq = ld_aq.append(ld_aq1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    aq = bj_aq.append(ld_aq).drop_duplicates([&apos;station_id&apos;,&apos;time&apos;])</span><br><span class="line">    aq = aq[~aq[&apos;station_id&apos;].isnull()]</span><br><span class="line">    aq.to_hdf(data_path+&apos;aq.hdf&apos;,&apos;w&apos;, complib=&apos;blosc&apos;, complevel=5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    print(&apos;更新完毕....&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##########################################grid数据更新（更新天气预报）#######################################</span><br><span class="line"># 更新api grid数据</span><br><span class="line">def update_meo_grid():</span><br><span class="line"></span><br><span class="line">    dates = [str(date)[:10] for date in pd.date_range(&apos;2018-04-07&apos;,&apos;2018-06-05&apos;)]</span><br><span class="line">    for date in dates:</span><br><span class="line">        if date &gt; time.strftime(&quot;%Y-%m-%d&quot;, time.gmtime()):</span><br><span class="line">            continue</span><br><span class="line">        result_path = data_path + &quot;meo_grid_&#123;&#125;.csv&quot;.format(date)</span><br><span class="line">        if not os.path.exists(result_path):</span><br><span class="line">            # 北京meo_grid数据（起始时间2018-04-09-22）</span><br><span class="line">            url = &apos;http://kdd.caiyunapp.com/competition/forecast/bj/&#123;&#125;-22/2k0d1d8&apos;.format(date)</span><br><span class="line">            respones = requests.get(url)</span><br><span class="line">            if respones.text == &apos;None&apos;:</span><br><span class="line">                print(&apos;北京&#123;&#125;的数据api不存在&apos;.format(date))</span><br><span class="line">            else:</span><br><span class="line">                bj_result = pd.read_csv(StringIO(respones.text))</span><br><span class="line">                bj_result.drop([&apos;id&apos;, &apos;weather&apos;], axis=1, inplace=True)</span><br><span class="line">                bj_result.rename(columns=&#123;&apos;station_id&apos;: &apos;station_name&apos;, &apos;forecast_time&apos;: &apos;time&apos;&#125;, inplace=True)</span><br><span class="line">                bj_result = station_dict.merge(bj_result, on=&apos;station_name&apos;, how=&apos;inner&apos;)</span><br><span class="line">                del bj_result[&apos;station_name&apos;]</span><br><span class="line">                # result.to_csv(result_path, index=False)</span><br><span class="line">                print(&apos;正在更新北京&#123;&#125;的数据...&apos;.format(date))</span><br><span class="line"></span><br><span class="line">            # 伦敦meo_grid数据（起始时间2018-04-09-22）</span><br><span class="line">            url = &apos;http://kdd.caiyunapp.com/competition/forecast/ld/&#123;&#125;-22/2k0d1d8&apos;.format(date)</span><br><span class="line">            respones = requests.get(url)</span><br><span class="line">            if respones.text == &apos;None&apos;:</span><br><span class="line">                print(&apos;伦敦&#123;&#125;的数据api不存在&apos;.format(date))</span><br><span class="line">            else:</span><br><span class="line">                ld_result = pd.read_csv(StringIO(respones.text))</span><br><span class="line">                ld_result.drop([&apos;id&apos;, &apos;weather&apos;], axis=1, inplace=True)</span><br><span class="line">                ld_result.rename(columns=&#123;&apos;station_id&apos;: &apos;station_name&apos;, &apos;forecast_time&apos;: &apos;time&apos;&#125;, inplace=True)</span><br><span class="line">                ld_result = station_dict.merge(ld_result, on=&apos;station_name&apos;, how=&apos;inner&apos;)</span><br><span class="line">                del ld_result[&apos;station_name&apos;]</span><br><span class="line">                # result.to_csv(result_path,index=False)</span><br><span class="line">                print(&apos;正在更新伦敦&#123;&#125;的数据...&apos;.format(date))</span><br><span class="line">                result = pd.concat([bj_result, ld_result])</span><br><span class="line">                if (date &gt; &apos;2018-04-07&apos;) &amp; (date &lt; &apos;2018-04-23&apos;):</span><br><span class="line">                    temp = result[&apos;wind_direction&apos;]</span><br><span class="line">                    result[&apos;wind_direction&apos;] = result[&apos;wind_speed&apos;]</span><br><span class="line">                    result[&apos;wind_speed&apos;] = temp</span><br><span class="line">                result.to_csv(result_path, index=False)</span><br><span class="line">        else:</span><br><span class="line">            print(&apos;&#123;&#125;的数据已存在&apos;.format(date))</span><br><span class="line"></span><br><span class="line"># 更新历史grid数据</span><br><span class="line">def update_meo_grid2():</span><br><span class="line">    bj_meo_grid = pd.read_hdf(data_path + &apos;bj_meo_grid.hdf&apos;)</span><br><span class="line">    ld_meo_grid = pd.read_hdf(data_path + &apos;ld_meo_grid.hdf&apos;)</span><br><span class="line"></span><br><span class="line">    bj_meo_grid.drop([&apos;latitude&apos;, &apos;longitude&apos;, &apos;weather&apos;], axis=1, inplace=True)</span><br><span class="line">    ld_meo_grid.drop([&apos;latitude&apos;, &apos;longitude&apos;, &apos;weather&apos;], axis=1, inplace=True)</span><br><span class="line">    dates = [str(date)[:10] for date in pd.date_range(&apos;2017-01-01&apos;,&apos;2018-04-01&apos;)]</span><br><span class="line">    for date in dates:</span><br><span class="line">        start_time = date_add_hours(date, 0)[:10] + &apos; 23:00:00&apos;</span><br><span class="line">        end_time = date_add_hours(date, 48)[:10] + &apos; 23:00:00&apos;</span><br><span class="line">        result_path = data_path + &quot;meo_grid_&#123;&#125;.csv&quot;.format(date)</span><br><span class="line">        if not os.path.exists(result_path):</span><br><span class="line">            try:</span><br><span class="line">                bj_result = bj_meo_grid[(bj_meo_grid[&apos;time&apos;]&gt;=start_time) &amp; (bj_meo_grid[&apos;time&apos;]&lt;end_time)].copy()</span><br><span class="line">                bj_result = station_dict.merge(bj_result, on=&apos;station_name&apos;, how=&apos;inner&apos;)</span><br><span class="line">                del bj_result[&apos;station_name&apos;]</span><br><span class="line">                print(&apos;正在更新北京&#123;&#125;的数据...&apos;.format(date))</span><br><span class="line">            except:</span><br><span class="line">                print(&apos;北京&#123;&#125;的数据更新失败&apos;.format(date))</span><br><span class="line">            try:</span><br><span class="line">                ld_result = ld_meo_grid[(ld_meo_grid[&apos;time&apos;]&gt;=start_time) &amp; (ld_meo_grid[&apos;time&apos;]&lt;end_time)].copy()</span><br><span class="line">                ld_result = station_dict.merge(ld_result, on=&apos;station_name&apos;, how=&apos;inner&apos;)</span><br><span class="line">                del ld_result[&apos;station_name&apos;]</span><br><span class="line">                print(&apos;正在更新伦敦&#123;&#125;的数据...&apos;.format(date))</span><br><span class="line">            except:</span><br><span class="line">                print(&apos;伦敦&#123;&#125;的数据更新失败&apos;.format(date))</span><br><span class="line">            result = pd.concat([bj_result, ld_result])</span><br><span class="line">            result.to_csv(result_path, index=False)</span><br><span class="line">        else:</span><br><span class="line">            print(&apos;&#123;&#125;的数据已存在&apos;.format(date))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">aq = pd.read_hdf(data_path+&apos;aq.hdf&apos;)</span><br><span class="line">temp = aq[[&apos;CO&apos;, &apos;NO2&apos;, &apos;O3&apos;, &apos;PM10&apos;, &apos;PM2.5&apos;, &apos;SO2&apos;]].copy()</span><br><span class="line">temp[temp&lt;0] = np.nan</span><br><span class="line">aq[[&apos;CO&apos;, &apos;NO2&apos;, &apos;O3&apos;, &apos;PM10&apos;, &apos;PM2.5&apos;, &apos;SO2&apos;]] = temp</span><br><span class="line">aq2 = aq.copy()</span><br><span class="line">aq[[&apos;CO&apos;, &apos;NO2&apos;, &apos;O3&apos;, &apos;PM10&apos;, &apos;PM2.5&apos;, &apos;SO2&apos;]] = np.log(aq[[&apos;CO&apos;, &apos;NO2&apos;, &apos;O3&apos;, &apos;PM10&apos;, &apos;PM2.5&apos;, &apos;SO2&apos;]]+100)</span><br><span class="line"></span><br><span class="line">station_info = pd.read_csv(data_path+&apos;station_info.csv&apos;)</span><br><span class="line">station_info[&apos;sitetype&apos;] = LabelEncoder().fit_transform(station_info[&apos;sitetype&apos;])</span><br><span class="line">holidays = pd.read_csv(data_path + &apos;holidays.csv&apos;)</span><br><span class="line">aq = aq.merge(station_info[[&apos;station_id&apos;,&apos;sitetype&apos;,&apos;city&apos;]],on=&apos;station_id&apos;,how=&apos;left&apos;)</span><br><span class="line">aq[&apos;hour&apos;] = pd.to_datetime(aq[&apos;time&apos;]).dt.hour</span><br><span class="line">aq[&apos;date&apos;] = aq[&apos;time&apos;].str[:10]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bj_station_id = [&apos;aotizhongxin&apos;, &apos;badaling&apos;, &apos;beibuxinqu&apos;, &apos;daxing&apos;, &apos;dingling&apos;,</span><br><span class="line">       &apos;donggaocun&apos;, &apos;dongsi&apos;, &apos;dongsihuan&apos;, &apos;fangshan&apos;, &apos;fengtaihuayuan&apos;,</span><br><span class="line">       &apos;guanyuan&apos;, &apos;gucheng&apos;, &apos;huairou&apos;, &apos;liulihe&apos;, &apos;mentougou&apos;, &apos;miyun&apos;,</span><br><span class="line">       &apos;miyunshuiku&apos;, &apos;nansanhuan&apos;, &apos;nongzhanguan&apos;, &apos;pingchang&apos;, &apos;pinggu&apos;,</span><br><span class="line">       &apos;qianmen&apos;, &apos;shunyi&apos;, &apos;tiantan&apos;, &apos;tongzhou&apos;, &apos;wanliu&apos;,</span><br><span class="line">       &apos;wanshouxigong&apos;, &apos;xizhimenbei&apos;, &apos;yanqin&apos;, &apos;yizhuang&apos;,</span><br><span class="line">       &apos;yongdingmennei&apos;, &apos;yongledian&apos;, &apos;yufa&apos;, &apos;yungang&apos;, &apos;zhiwuyuan&apos;]</span><br><span class="line">ld_station_id = [&apos;CD1&apos;, &apos;BL0&apos;, &apos;GR4&apos;, &apos;MY7&apos;, &apos;HV1&apos;, &apos;GN3&apos;, &apos;GR9&apos;, &apos;LW2&apos;, &apos;GN0&apos;,</span><br><span class="line">       &apos;KF1&apos;, &apos;CD9&apos;, &apos;ST5&apos;, &apos;TH4&apos;, &apos;LH0&apos;, &apos;HR1&apos;, &apos;TD5&apos;, &apos;CT3&apos;, &apos;GB0&apos;,</span><br><span class="line">       &apos;CR8&apos;, &apos;RB7&apos;, &apos;BX1&apos;, &apos;BX9&apos;, &apos;KC1&apos;, &apos;CT2&apos;]</span><br><span class="line">station_id = [&apos;aotizhongxin&apos;, &apos;badaling&apos;, &apos;beibuxinqu&apos;, &apos;daxing&apos;, &apos;dingling&apos;,</span><br><span class="line">       &apos;donggaocun&apos;, &apos;dongsi&apos;, &apos;dongsihuan&apos;, &apos;fangshan&apos;, &apos;fengtaihuayuan&apos;,</span><br><span class="line">       &apos;guanyuan&apos;, &apos;gucheng&apos;, &apos;huairou&apos;, &apos;liulihe&apos;, &apos;mentougou&apos;, &apos;miyun&apos;,</span><br><span class="line">       &apos;miyunshuiku&apos;, &apos;nansanhuan&apos;, &apos;nongzhanguan&apos;, &apos;pingchang&apos;, &apos;pinggu&apos;,</span><br><span class="line">       &apos;qianmen&apos;, &apos;shunyi&apos;, &apos;tiantan&apos;, &apos;tongzhou&apos;, &apos;wanliu&apos;,</span><br><span class="line">       &apos;wanshouxigong&apos;, &apos;xizhimenbei&apos;, &apos;yanqin&apos;, &apos;yizhuang&apos;,</span><br><span class="line">       &apos;yongdingmennei&apos;, &apos;yongledian&apos;, &apos;yufa&apos;, &apos;yungang&apos;, &apos;zhiwuyuan&apos;,</span><br><span class="line">       &apos;CD1&apos;, &apos;BL0&apos;, &apos;GR4&apos;, &apos;MY7&apos;, &apos;HV1&apos;, &apos;GN3&apos;, &apos;GR9&apos;, &apos;LW2&apos;, &apos;GN0&apos;,</span><br><span class="line">       &apos;KF1&apos;, &apos;CD9&apos;, &apos;ST5&apos;, &apos;TH4&apos;, &apos;LH0&apos;, &apos;HR1&apos;, &apos;TD5&apos;, &apos;CT3&apos;, &apos;GB0&apos;,</span><br><span class="line">       &apos;CR8&apos;, &apos;RB7&apos;, &apos;BX1&apos;, &apos;BX9&apos;, &apos;KC1&apos;, &apos;CT2&apos;</span><br><span class="line">              ]</span><br><span class="line">stationName = [&apos;beijing_grid_303&apos;, &apos;beijing_grid_303&apos;, &apos;beijing_grid_282&apos;, &apos;beijing_grid_303&apos;, &apos;beijing_grid_304&apos;,</span><br><span class="line"> &apos;beijing_grid_324&apos;,  &apos;beijing_grid_283&apos;,  &apos;beijing_grid_263&apos;, &apos;beijing_grid_262&apos;,  &apos;beijing_grid_282&apos;, &apos;beijing_grid_239&apos;,</span><br><span class="line"> &apos;beijing_grid_261&apos;, &apos;beijing_grid_238&apos;,&apos;beijing_grid_301&apos;,&apos;beijing_grid_323&apos;,&apos;beijing_grid_366&apos;, &apos;beijing_grid_368&apos;,</span><br><span class="line"> &apos;beijing_grid_264&apos;, &apos;beijing_grid_240&apos;, &apos;beijing_grid_452&apos;, &apos;beijing_grid_349&apos;, &apos;beijing_grid_392&apos;, &apos;beijing_grid_225&apos;,</span><br><span class="line"> &apos;beijing_grid_265&apos;, &apos;beijing_grid_224&apos;, &apos;beijing_grid_414&apos;, &apos;beijing_grid_452&apos;, &apos;beijing_grid_385&apos;, &apos;beijing_grid_278&apos;,</span><br><span class="line"> &apos;beijing_grid_216&apos;, &apos;beijing_grid_303&apos;, &apos;beijing_grid_303&apos;, &apos;beijing_grid_283&apos;, &apos;beijing_grid_303&apos;, &apos;beijing_grid_324&apos;,</span><br><span class="line"> &apos;london_grid_472&apos;, &apos;london_grid_472&apos;, &apos;london_grid_409&apos;, &apos;london_grid_409&apos;, &apos;london_grid_388&apos;, &apos;london_grid_409&apos;,</span><br><span class="line"> &apos;london_grid_409&apos;, &apos;london_grid_408&apos;, &apos;london_grid_451&apos;, &apos;london_grid_451&apos;, &apos;london_grid_451&apos;, &apos;london_grid_430&apos;,</span><br><span class="line"> &apos;london_grid_451&apos;, &apos;london_grid_368&apos;, &apos;london_grid_472&apos;, &apos;london_grid_346&apos;, &apos;london_grid_388&apos;, &apos;london_grid_388&apos;,</span><br><span class="line"> &apos;london_grid_430&apos;, &apos;london_grid_452&apos;, &apos;london_grid_366&apos;, &apos;london_grid_408&apos;, &apos;london_grid_430&apos;, &apos;london_grid_388&apos;]</span><br><span class="line"></span><br><span class="line">############################### 工具函数 ###########################</span><br><span class="line"># 合并节约内存</span><br><span class="line">def concat(L):</span><br><span class="line">    result = None</span><br><span class="line">    for l in L:</span><br><span class="line">        if result is None:</span><br><span class="line">            result = l</span><br><span class="line">        else:</span><br><span class="line">            result[l.columns.tolist()] = l</span><br><span class="line">    return result</span><br><span class="line"># groupby 直接拼接</span><br><span class="line">def groupby(data,stat,key,value,func):</span><br><span class="line">    key = key if type(key)==list else [key]</span><br><span class="line">    data_temp = data[key].copy()</span><br><span class="line">    feat = stat.groupby(key,as_index=False)[value].agg(&#123;&apos;feat&apos;:func&#125;)</span><br><span class="line">    data_temp = data_temp.merge(feat,on=key,how=&apos;left&apos;)</span><br><span class="line">    return data_temp[&apos;feat&apos;].values</span><br><span class="line"># 相差的小时数</span><br><span class="line">def diff_of_hours(time1,time2):</span><br><span class="line">    hours = (parse(time1) - parse(time2)).total_seconds()//3600</span><br><span class="line">    return abs(hours)</span><br><span class="line">############################### 预处理函数 ###########################</span><br><span class="line">def pre_treatment(data_key):</span><br><span class="line">    result_path = cache_path + &apos;data_&#123;&#125;.hdf&apos;.format(data_key)</span><br><span class="line">    if os.path.exists(result_path) &amp; 1:</span><br><span class="line">        data = pd.read_hdf(result_path, &apos;w&apos;)</span><br><span class="line">    else:</span><br><span class="line">        times = pd.date_range(data_key,date_add_days(data_key,2),freq=&apos;H&apos;)[:-1]</span><br><span class="line">        data = pd.DataFrame(index=times,columns=station_id).unstack().reset_index().drop(0,axis=1)</span><br><span class="line">        data.columns = [&apos;station_id&apos;,&apos;time&apos;]</span><br><span class="line">        data = data.merge(station_info, on=&apos;station_id&apos;, how=&apos;left&apos;)</span><br><span class="line">        data[&apos;hour&apos;] = data[&apos;time&apos;].dt.hour</span><br><span class="line">        data[&apos;month&apos;] = data[&apos;time&apos;].dt.month</span><br><span class="line">        data[&apos;year&apos;] = data[&apos;time&apos;].dt.year</span><br><span class="line">        data[&apos;day_of_week&apos;] = data[&apos;time&apos;].dt.dayofweek</span><br><span class="line">        data[&apos;day_of_month&apos;] = data[&apos;time&apos;].dt.day</span><br><span class="line">        data[&apos;day_of_year&apos;] = data[&apos;time&apos;].dt.dayofyear</span><br><span class="line">        data[&apos;time&apos;] = data[&apos;time&apos;].astype(str)</span><br><span class="line">        data[&apos;date&apos;] = data[&apos;time&apos;].str[:10]</span><br><span class="line">        data[&apos;diff_of_hour&apos;] = (data[&apos;date&apos;]!=data_key).astype(int)*24+data[&apos;hour&apos;]</span><br><span class="line">        data = data.merge(holidays,on=&apos;date&apos;,how=&apos;left&apos;)</span><br><span class="line">        data.reset_index(drop=True, inplace=True)</span><br><span class="line">        data.to_hdf(result_path, &apos;w&apos;, complib=&apos;blosc&apos;, complevel=5)</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">############################### 预处理函数 ###########################</span><br><span class="line"># 24个小时前的数据</span><br><span class="line">def get_24hour_feat(data,data_key,replace):</span><br><span class="line">    result_path = cache_path + &apos;24hour_feat_&#123;&#125;_&#123;&#125;hours_ago.hdf&apos;.format(data_key,1)</span><br><span class="line">    if os.path.exists(result_path) &amp; (not replace):</span><br><span class="line">        feat = pd.read_hdf(result_path, &apos;w&apos;)</span><br><span class="line">    else:</span><br><span class="line">        start_time = date_add_hours(data_key, -25)</span><br><span class="line">        end_time1 = date_add_hours(data_key, -1)</span><br><span class="line">        end_time0 = date_add_hours(data_key, -2)</span><br><span class="line">        bj_aq = aq[(aq[&apos;city&apos;]==1) &amp; (aq[&apos;time&apos;] &lt; end_time1) &amp; (aq[&apos;time&apos;] &gt;= start_time)].copy()</span><br><span class="line">        ld_aq = aq[(aq[&apos;city&apos;] == 0) &amp; (aq[&apos;time&apos;] &lt; end_time0) &amp; (aq[&apos;time&apos;] &gt;= start_time)].copy()</span><br><span class="line">        data_temp = bj_aq.append(ld_aq)</span><br><span class="line">        feat = data[[&apos;station_id&apos;,&apos;city&apos;,&apos;sitetype&apos;]].copy()</span><br><span class="line">        for label in [&apos;PM2.5&apos;,&apos;PM10&apos;,&apos;O3&apos;]:</span><br><span class="line">            result_temp = data_temp.set_index([&apos;station_id&apos;, &apos;time&apos;])[label].unstack()</span><br><span class="line">            result_temp.columns = [&apos;&#123;&#125;_&#123;&#125;hour_last&apos;.format(label,c[11:13]) for c in result_temp.columns]</span><br><span class="line">            feat = feat.merge(result_temp.reset_index(),on=&apos;station_id&apos;,how=&apos;left&apos;)</span><br><span class="line">        for label in [&apos;PM2.5&apos;,&apos;PM10&apos;,&apos;O3&apos;]:</span><br><span class="line">            result_temp = data_temp.groupby([&apos;city&apos;, &apos;time&apos;])[label].mean().unstack()</span><br><span class="line">            result_temp.columns = [&apos;&#123;&#125;_&#123;&#125;hour_last_city&apos;.format(label,c[11:13]) for c in result_temp.columns]</span><br><span class="line">            feat = feat.merge(result_temp.reset_index(),on=&apos;city&apos;,how=&apos;left&apos;)</span><br><span class="line">        # for label in [&apos;PM2.5&apos;,&apos;PM10&apos;,&apos;O3&apos;]:</span><br><span class="line">        #     result_temp = data_temp.groupby([&apos;sitetype&apos;, &apos;time&apos;])[label].mean().unstack()</span><br><span class="line">        #     result_temp.columns = [&apos;&#123;&#125;_&#123;&#125;hour_last_sitetype&apos;.format(label,c[11:13]) for c in result_temp.columns]</span><br><span class="line">        #     feat = feat.merge(result_temp.reset_index(),on=&apos;sitetype&apos;,how=&apos;left&apos;)</span><br><span class="line">        feat.to_hdf(result_path, &apos;w&apos;, complib=&apos;blosc&apos;, complevel=5)</span><br><span class="line">    return feat</span><br><span class="line"></span><br><span class="line"># 一个月内对应小时的值</span><br><span class="line">def get_nday_mean_feat(data,data_key,n,replace):</span><br><span class="line">    result_path = cache_path + &apos;&#123;&#125;day_mean_feat&#123;&#125;_&#123;&#125;hours_age.hdf&apos;.format(n,data_key,1)</span><br><span class="line">    if os.path.exists(result_path) &amp; (not replace):</span><br><span class="line">        feat = pd.read_hdf(result_path, &apos;w&apos;)</span><br><span class="line">    else:</span><br><span class="line">        start_time = date_add_hours(data_key, -1-24*n)</span><br><span class="line">        end_time = date_add_hours(data_key, -1)</span><br><span class="line">        data_temp = aq[(aq[&apos;time&apos;]&lt;end_time) &amp; (aq[&apos;time&apos;]&gt;=start_time)]</span><br><span class="line">        feat = data[[&apos;station_id&apos;,&apos;hour&apos;,&apos;date&apos;,&apos;city&apos;]].copy()</span><br><span class="line">        for label in [&apos;PM2.5&apos;,&apos;PM10&apos;,&apos;O3&apos;]:</span><br><span class="line">            # feat[&apos;&#123;&#125;day_&#123;&#125;_mean&apos;.format(n,label)] = groupby(feat,data_temp,[&apos;station_id&apos;],label,np.mean)</span><br><span class="line">            # feat[&apos;&#123;&#125;day_&#123;&#125;_std&apos;.format(n,label)] = groupby(feat, data_temp, [&apos;station_id&apos;], label, np.std)</span><br><span class="line">            feat[&apos;&#123;&#125;day_hour_&#123;&#125;_mean&apos;.format(n,label)] = groupby(feat, data_temp, [&apos;station_id&apos;,&apos;hour&apos;], label, np.mean)</span><br><span class="line">        for label in [&apos;PM2.5&apos;,&apos;PM10&apos;,&apos;O3&apos;]:</span><br><span class="line">            # feat[&apos;&#123;&#125;day_&#123;&#125;_mean_city&apos;.format(n,label)] = groupby(feat,data_temp,[&apos;station_id&apos;],label,np.mean)</span><br><span class="line">            # feat[&apos;&#123;&#125;day_&#123;&#125;_std_city&apos;.format(n,label)] = groupby(feat, data_temp, [&apos;station_id&apos;], label, np.std)</span><br><span class="line">            feat[&apos;&#123;&#125;day_&#123;&#125;_mean_city&apos;.format(n,label)] = groupby(feat, data_temp, [&apos;city&apos;,&apos;date&apos;], label, np.mean)</span><br><span class="line">        for label in [&apos;PM2.5&apos;,&apos;PM10&apos;,&apos;O3&apos;]:</span><br><span class="line">            # feat[&apos;&#123;&#125;day_&#123;&#125;_mean_city&apos;.format(n,label)] = groupby(feat,data_temp,[&apos;station_id&apos;],label,np.mean)</span><br><span class="line">            # feat[&apos;&#123;&#125;day_&#123;&#125;_std_city&apos;.format(n,label)] = groupby(feat, data_temp, [&apos;station_id&apos;], label, np.std)</span><br><span class="line">            feat[&apos;&#123;&#125;day_hour_&#123;&#125;_mean_city&apos;.format(n,label)] = groupby(feat, data_temp, [&apos;city&apos;,&apos;hour&apos;], label, np.mean)</span><br><span class="line">        feat.to_hdf(result_path, &apos;w&apos;, complib=&apos;blosc&apos;, complevel=5)</span><br><span class="line">    return feat</span><br><span class="line"></span><br><span class="line"># 天气特征</span><br><span class="line">def get_weather_feat(data,data_key,replace):</span><br><span class="line">    result_path = cache_path + &apos;weather_feat&#123;&#125;.hdf&apos;.format(data_key)</span><br><span class="line">    if os.path.exists(result_path) &amp; (not replace):</span><br><span class="line">        feat = pd.read_hdf(result_path, &apos;w&apos;)</span><br><span class="line">    else:</span><br><span class="line">        data_temp = data[[&apos;station_id&apos;,&apos;time&apos;]].copy()</span><br><span class="line">        end_time = date_add_hours(data_key, -2)</span><br><span class="line">        try:</span><br><span class="line">            weather = pd.read_csv(r&apos;C:\Users\csw\Desktop\python\kdd\data\meo_grid_api\meo_grid_&#123;&#125;.csv&apos;.format(end_time[:10]))</span><br><span class="line">            date_time = data_temp[&apos;time&apos;].copy()</span><br><span class="line">            feat_columns = weather.columns.copy()</span><br><span class="line">            for i in [-18,-12,-6,-4,-3,-2,-1,0,1,2,3]:</span><br><span class="line">                weather.columns = [c+&apos;_ahead&#123;&#125;&apos;.format(i) if c not in [&apos;station_id&apos;,&apos;time&apos;] else c for c in feat_columns]</span><br><span class="line">                data_temp[&apos;time&apos;] = date_time.apply(lambda x: date_add_hours(x,i))</span><br><span class="line">                data_temp = data_temp.merge(weather,on=[&apos;station_id&apos;,&apos;time&apos;],how=&apos;left&apos;)</span><br><span class="line">            data_temp[&apos;temperature_diff_1&apos;] = data_temp[&apos;temperature_ahead0&apos;] - data_temp[&apos;temperature_ahead-1&apos;]</span><br><span class="line">            data_temp[&apos;temperature_diff_2&apos;] = data_temp[&apos;temperature_ahead0&apos;] - data_temp[&apos;temperature_ahead-2&apos;]</span><br><span class="line">            data_temp[&apos;temperature_diff_21&apos;] = data_temp[&apos;temperature_ahead-1&apos;] - data_temp[&apos;temperature_ahead-2&apos;]</span><br><span class="line">            data_temp[&apos;temperature_diff_3&apos;] = data_temp[&apos;temperature_ahead0&apos;] - data_temp[&apos;temperature_ahead-3&apos;]</span><br><span class="line">            data_temp[&apos;temperature_diff_31&apos;] = data_temp[&apos;temperature_ahead-2&apos;] - data_temp[&apos;temperature_ahead-3&apos;]</span><br><span class="line">            data_temp[&apos;humidity_diff_1&apos;] = (data_temp[&apos;humidity_ahead0&apos;] - data_temp[&apos;humidity_ahead-1&apos;])/data_temp[&apos;humidity_ahead0&apos;]</span><br><span class="line">            feat = data_temp.drop([&apos;station_id&apos;,&apos;time&apos;],axis=1)</span><br><span class="line">        except:</span><br><span class="line">            feat = pd.DataFrame()</span><br><span class="line">            print(&apos;&#123;&#125;的天气数据为空。&apos;.format(end_time[:10]))</span><br><span class="line">        feat.to_hdf(result_path, &apos;w&apos;, complib=&apos;blosc&apos;, complevel=5)</span><br><span class="line">    return feat</span><br><span class="line"></span><br><span class="line"># 添加标签</span><br><span class="line">def get_label(result):</span><br><span class="line">    return result.merge(aq2[[&apos;station_id&apos;,&apos;time&apos;,&apos;PM2.5&apos;,&apos;PM10&apos;,&apos;O3&apos;]],on=[&apos;station_id&apos;,&apos;time&apos;],how=&apos;left&apos;)</span><br><span class="line"></span><br><span class="line"># 二次处理特征</span><br><span class="line">def second_feat(result):</span><br><span class="line">    try:</span><br><span class="line">        result[&apos;PM2.5_22hour_last_city/PM2.5_21hour_last_city_rate&apos;] = result[&apos;PM2.5_22hour_last_city&apos;] / result[&apos;PM2.5_21hour_last_city&apos;]</span><br><span class="line">        result[&apos;PM10_22hour_last_city/PM10_21hour_last_city_rate&apos;] = result[&apos;PM10_22hour_last&apos;] / result[&apos;PM10_21hour_last_city&apos;]</span><br><span class="line">        result[&apos;O3_22hour_last/O3_21hour_last_rate&apos;] = result[&apos;O3_22hour_last_city&apos;] / result[&apos;O3_21hour_last_city&apos;]</span><br><span class="line">        result[&apos;PM2.5_21hour_last/PM2.5_20hour_last_rate&apos;] = result[&apos;PM2.5_21hour_last&apos;]/result[&apos;PM2.5_20hour_last&apos;]</span><br><span class="line">        result[&apos;PM10_21hour_last/PM10_20hour_last_rate&apos;] = result[&apos;PM10_21hour_last&apos;] / result[&apos;PM10_20hour_last&apos;]</span><br><span class="line">        result[&apos;O3_21hour_last/O3_20hour_last_rate&apos;] = result[&apos;O3_21hour_last&apos;] / result[&apos;O3_20hour_last&apos;]</span><br><span class="line">        result[&apos;30day_PM2.5_mean/60day_PM2.5_mean_rate&apos;] = result[&apos;30day_PM2.5_mean_city&apos;] / result[&apos;60day_PM2.5_mean_city&apos;]</span><br><span class="line">        result[&apos;30day_PM10_mean/60day_PM10_mean_rate&apos;] = result[&apos;30day_PM10_mean_city&apos;] / result[&apos;60day_PM10_mean_city&apos;]</span><br><span class="line">        result[&apos;30day_O3_mean/60day_O3_mean_rate&apos;] = result[&apos;30day_O3_mean_city&apos;] / result[&apos;60day_O3_mean_city&apos;]</span><br><span class="line">        result[&apos;3day_PM2.5_mean/7day_PM2.5_mean_rate&apos;] = result[&apos;3day_PM2.5_mean_city&apos;] / result[&apos;7day_PM2.5_mean_city&apos;]</span><br><span class="line">        result[&apos;3day_PM10_mean/7day_PM10_mean_rate&apos;] = result[&apos;3day_PM10_mean_city&apos;] / result[&apos;7day_PM10_mean_city&apos;]</span><br><span class="line">        result[&apos;3day_O3_mean/7day_O3_mean_rate&apos;] = result[&apos;3day_O3_mean_city&apos;] / result[&apos;7day_O3_mean_city&apos;]</span><br><span class="line">        result[&apos;1day_PM2.5_mean_city/2day_PM2.5_mean_city_rate&apos;] = result[&apos;1day_PM2.5_mean_city&apos;] / result[&apos;2day_PM2.5_mean_city&apos;]</span><br><span class="line">        result[&apos;1day_PM10_mean_city/2day_PM10_mean_city_rate&apos;] = result[&apos;1day_PM10_mean_city&apos;] / result[&apos;2day_PM10_mean_city&apos;]</span><br><span class="line">        result[&apos;1day_O3_mean_city/2day_O3_mean_city_rate&apos;] = result[&apos;1day_O3_mean_city&apos;] / result[&apos;2day_O3_mean_city&apos;]</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">def make_feat(data_key,silent=0,replace=False):</span><br><span class="line">    # data_key = hashlib.md5(data.to_string().encode()).hexdigest()</span><br><span class="line">    print(end=&apos;&apos;) if silent else print(&apos;数据key为：&#123;&#125;&apos;.format(data_key))</span><br><span class="line">    result_path = cache_path + &apos;feat_set_&#123;&#125;_&#123;&#125;hour_ago.hdf&apos;.format(data_key,1)</span><br><span class="line">    if os.path.exists(result_path) &amp; (not replace):</span><br><span class="line">        result = pd.read_hdf(result_path, &apos;w&apos;)</span><br><span class="line">    else:</span><br><span class="line">        data = pre_treatment(data_key)</span><br><span class="line"></span><br><span class="line">        result = [data]</span><br><span class="line">        # print(&apos;开始构造特征...&apos;)</span><br><span class="line">        result.append(get_24hour_feat(data,data_key,replace))               # 24个小时前的数据</span><br><span class="line">        for i in [1,2,3,7,15,30,60,360]:</span><br><span class="line">            result.append(get_nday_mean_feat(data,data_key,i,replace))      # 一个月内对应小时的值</span><br><span class="line">        result.append(get_weather_feat(data, data_key,replace))             # 天气特征</span><br><span class="line"></span><br><span class="line">        # print(&apos;开始合并特征...&apos;)</span><br><span class="line">        result = concat(result)</span><br><span class="line"></span><br><span class="line">        result = second_feat(result)</span><br><span class="line">        # print(&apos;添加label&apos;)</span><br><span class="line">        result = get_label(result)</span><br><span class="line">        # print(&apos;存储数据...&apos;)</span><br><span class="line">        result = convert_dtypes(result, result.columns, slient=True)</span><br><span class="line">        result.to_hdf(result_path, &apos;w&apos;, complib=&apos;blosc&apos;, complevel=5)</span><br><span class="line">    print(end=&apos;&apos;) if silent else print(&apos;特征矩阵大小：&#123;&#125;&apos;.format(result.shape))</span><br><span class="line">    # print(&apos;生成特征一共用时&#123;&#125;秒&apos;.format(time.time() - t0))</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">up_date()</span><br><span class="line">update_meo_grid()</span><br><span class="line">update_meo_grid2()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hours = 1</span><br><span class="line">data_feat = []</span><br><span class="line">start_date = &apos;2018-05-05&apos;</span><br><span class="line">days = 400</span><br><span class="line">data_feat_url = cache_path + &apos;data_feat_&#123;&#125;_&#123;&#125;days.hdf&apos;.format(start_date,days)</span><br><span class="line">if os.path.exists(data_feat_url):</span><br><span class="line">    data_feat = pd.read_hdf(data_feat_url, &apos;w&apos;)</span><br><span class="line">else:</span><br><span class="line">    for i in tqdm(range(days)):</span><br><span class="line">        data_feat.append(make_feat(date_add_days(start_date, i*(-1))))</span><br><span class="line">    data_feat = pd.concat(data_feat,axis=0)</span><br><span class="line">    data_feat.to_hdf(data_feat_url, &apos;w&apos;, complib=&apos;blosc&apos;, complevel=5)</span><br><span class="line"></span><br><span class="line">train_feat = data_feat[data_feat[&apos;time&apos;]&lt;&apos;2018-04-10 00:00:00&apos;]</span><br><span class="line">eval_feat = data_feat[data_feat[&apos;time&apos;]&gt;=&apos;2018-04-10 00:00:00&apos;]</span><br><span class="line"></span><br><span class="line"># weather_columns = []</span><br><span class="line"># for i in [&apos;&apos;,&apos;&apos;,&apos;&apos;,&apos;&apos;,&apos;&apos;,&apos;&apos;]:</span><br><span class="line"></span><br><span class="line">predictors = [c for c in train_feat.columns if c not in ([&apos;station_id&apos;, &apos;time&apos;,&apos;date&apos;, &apos;PM2.5&apos;, &apos;PM10&apos;, &apos;O3&apos;,&apos;city&apos;,&apos;duoyun&apos;, &apos;yangsha&apos;, &apos;qing&apos;, &apos;fuchen&apos;, &apos;yin&apos;, &apos;zhenyu&apos;, &apos;zhenxue&apos;,</span><br><span class="line">       &apos;yujiaxue&apos;, &apos;wu&apos;, &apos;mai&apos;])]</span><br><span class="line">params = &#123;</span><br><span class="line">    &apos;learning_rate&apos;: 0.01,</span><br><span class="line">    &apos;boosting_type&apos;: &apos;gbdt&apos;,</span><br><span class="line">    # &apos;objective&apos;: &apos;regression&apos;,</span><br><span class="line">    &apos;application&apos;: &apos;mape&apos;,</span><br><span class="line">    &apos;metric&apos;: &apos;map&apos;,</span><br><span class="line">    &apos;sub_feature&apos;: 0.7,</span><br><span class="line">    &apos;num_leaves&apos;: 60,</span><br><span class="line">    &apos;min_data&apos;: 100,</span><br><span class="line">    &apos;min_hessian&apos;: 1,</span><br><span class="line">    &apos;verbose&apos;: -1,</span><br><span class="line">&#125;</span><br><span class="line">model_dict = &#123;&#125;</span><br><span class="line">def f1(x): return np.log(x+1)</span><br><span class="line">def f2(x): return np.log(x+1)</span><br><span class="line">def f3(x): return np.log(x+100)</span><br><span class="line">def f4(x): return np.exp(x)-1</span><br><span class="line">def f5(x): return np.exp(x)-1</span><br><span class="line">def f6(x): return np.exp(x)-100</span><br><span class="line">encode = &#123;&apos;PM2.5&apos;:f1,&apos;PM10&apos;:f2,&apos;O3&apos;:f3&#125;</span><br><span class="line">decode = &#123;&apos;PM2.5&apos;:f4,&apos;PM10&apos;:f5,&apos;O3&apos;:f6&#125;</span><br><span class="line">for label in [&apos;PM2.5&apos;,&apos;PM10&apos;,&apos;O3&apos;]:</span><br><span class="line">    lgb_train = lgb.Dataset(train_feat[train_feat[label] &gt; 0][predictors],encode[label](train_feat[train_feat[label] &gt; 0][label]))</span><br><span class="line">    lgb_eval = lgb.Dataset(eval_feat[eval_feat[label] &gt; 0][predictors], encode[label](eval_feat[eval_feat[label] &gt; 0][label]))</span><br><span class="line"></span><br><span class="line">    gbm = lgb.train(params,</span><br><span class="line">                    lgb_train,</span><br><span class="line">                    num_boost_round=5000,</span><br><span class="line">                    valid_sets=lgb_eval,</span><br><span class="line">                    verbose_eval = 100,</span><br><span class="line">                    early_stopping_rounds = 100)</span><br><span class="line">    feat_imp = pd.Series(gbm.feature_importance(), index=predictors).sort_values(ascending=False)</span><br><span class="line">    model_dict[label] = gbm</span><br><span class="line"></span><br><span class="line">pickle.dump((model_dict,predictors),open(data_path+&apos;lightgbm_weather_best_eval.model&apos;,&apos;wb+&apos;))</span><br><span class="line">model_dict,predictors = pickle.load(open(data_path+&apos;lightgbm_weather_best_eval.model&apos;, &apos;rb+&apos;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(&apos;生成测试集&apos;)</span><br><span class="line">def get_test_feat(date):</span><br><span class="line">    test_feat = make_feat(date_add_days(date[:10],1),replace=True)</span><br><span class="line">    test_feat = pd.concat([train_feat[:0],test_feat])</span><br><span class="line">    return test_feat</span><br><span class="line"></span><br><span class="line">print(&apos;生成预测结果&apos;)</span><br><span class="line">def get_submission(test_feat,model_dict,decode):</span><br><span class="line">    for label in [&apos;PM2.5&apos;, &apos;PM10&apos;, &apos;O3&apos;]:</span><br><span class="line">        pred = model_dict[label].predict(test_feat[predictors])</span><br><span class="line">        test_feat[label] = decode[label](pred)</span><br><span class="line">    test_feat[&apos;test_id&apos;] = test_feat[&apos;station_id&apos;].apply(lambda x: x if len(x)&lt;11 else x[:10])</span><br><span class="line">    test_feat[&apos;test_id&apos;] = list(map(lambda x,y: y if x==0 else y+&apos;_aq&apos;, test_feat[&apos;city&apos;],test_feat[&apos;test_id&apos;]))</span><br><span class="line">    test_feat[&apos;test_id&apos;] = test_feat[&apos;test_id&apos;] + &apos;#&apos; + test_feat[&apos;diff_of_hour&apos;].astype(int).astype(str)</span><br><span class="line">    submission = pd.read_csv(data_path + &apos;sample_submissioin.csv&apos;)</span><br><span class="line">    submission = submission[[&apos;test_id&apos;]].merge(test_feat[[&apos;test_id&apos;,&apos;PM2.5&apos;,&apos;PM10&apos;,&apos;O3&apos;]],on=&apos;test_id&apos;,how=&apos;left&apos;)</span><br><span class="line">    if (submission[[&apos;PM2.5&apos;,&apos;PM10&apos;,&apos;O3&apos;]]&lt;0).sum().sum()&gt;0:</span><br><span class="line">        print(&apos;存在负数，请检查！！！&apos;)</span><br><span class="line">    return submission</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hours = 1</span><br><span class="line">utc_date = date_add_hours(datetime.datetime.now().strftime(&apos;%Y-%m-%d %H:%M:%S&apos;),-8)</span><br><span class="line">print(&apos;现在是UTC时间：&#123;&#125;&apos;.format(utc_date))</span><br><span class="line">print(&apos;距离待预测时间还有&#123;&#125;个小时&apos;.format(diff_of_hours(date_add_days(utc_date,1),utc_date)+1))</span><br><span class="line"></span><br><span class="line">test_feat = get_test_feat(utc_date)</span><br><span class="line">submission = get_submission(test_feat,model_dict, decode)</span><br><span class="line"></span><br><span class="line">sub_url = r&apos;../submission/sub&#123;&#125;.csv&apos;.format(datetime.datetime.now().strftime(&apos;%Y%m%d_%H%M%S&apos;))</span><br><span class="line">submission.to_csv(sub_url,index=False,  float_format=&apos;%.4f&apos;)</span><br><span class="line">print(submission[[&apos;PM2.5&apos;,&apos;PM10&apos;,&apos;O3&apos;]].mean())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line">files=&#123;&apos;files&apos;: open(sub_url,&apos;rb&apos;)&#125;</span><br><span class="line">data = &#123;</span><br><span class="line">    &quot;user_id&quot;: &quot;piupiu&quot;,</span><br><span class="line">    &quot;team_token&quot;: &quot;739a5c2029a031c0d0709ba0b7d438968a458b783420c4179f1ee1b8e7380d08&quot;,</span><br><span class="line">    &quot;description&quot;: &apos;log1&apos;,</span><br><span class="line">    &quot;filename&quot;: sub_url.split(&apos;\\&apos;)[-1],</span><br><span class="line">&#125;</span><br><span class="line">url = &apos;https://biendata.com/competition/kdd_2018_submit/&apos;</span><br><span class="line">response = requests.post(url, files=files, data=data)</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;源代码分享&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://paradoxallen.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="python" scheme="https://paradoxallen.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>机器学习数学基础(3)——概率论与数理统计</title>
    <link href="https://paradoxallen.github.io/54638/"/>
    <id>https://paradoxallen.github.io/54638/</id>
    <published>2018-06-09T16:00:00.000Z</published>
    <updated>2018-07-10T09:27:36.397Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/uZxEGRS.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/uZxEGRS.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="数学基础" scheme="https://paradoxallen.github.io/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="机器学习" scheme="https://paradoxallen.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="概率论与数理统计" scheme="https://paradoxallen.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>机器学习数学基础(2)——线性代数</title>
    <link href="https://paradoxallen.github.io/16092/"/>
    <id>https://paradoxallen.github.io/16092/</id>
    <published>2018-06-08T16:00:00.000Z</published>
    <updated>2018-07-05T09:34:15.623Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/RqAIyFu.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/RqAIyFu.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="数学基础" scheme="https://paradoxallen.github.io/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="线性代数" scheme="https://paradoxallen.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
      <category term="机器学习" scheme="https://paradoxallen.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习数学基础(1)——高等数学</title>
    <link href="https://paradoxallen.github.io/11038/"/>
    <id>https://paradoxallen.github.io/11038/</id>
    <published>2018-06-07T16:00:00.000Z</published>
    <updated>2018-07-03T10:40:28.374Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/9MPH6WS.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/9MPH6WS.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="数学基础" scheme="https://paradoxallen.github.io/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="机器学习" scheme="https://paradoxallen.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="高等数学" scheme="https://paradoxallen.github.io/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>机器学习数学基础(0)——目录</title>
    <link href="https://paradoxallen.github.io/31404/"/>
    <id>https://paradoxallen.github.io/31404/</id>
    <published>2018-06-06T16:00:00.000Z</published>
    <updated>2018-06-29T12:29:14.844Z</updated>
    
    <content type="html"><![CDATA[<p><strong>高等数学</strong></p><p><strong>线性代数</strong><br>行列式<br>矩阵<br>向量<br>线性方程组<br>矩阵的特征值和特征向量<br>二次型</p><p><strong>概率论和数理统计</strong><br>随机事件和概率<br>随机变量及其概率分布<br>多维随机变量及其分布<br>随机变量的数字特征<br>数理统计的基本概念</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;高等数学&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线性代数&lt;/strong&gt;&lt;br&gt;行列式&lt;br&gt;矩阵&lt;br&gt;向量&lt;br&gt;线性方程组&lt;br&gt;矩阵的特征值和特征向量&lt;br&gt;二次型&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;概率论和数理统计&lt;/strong&gt;&lt;br&gt;
      
    
    </summary>
    
      <category term="数学基础" scheme="https://paradoxallen.github.io/categories/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="机器学习" scheme="https://paradoxallen.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="目录" scheme="https://paradoxallen.github.io/tags/%E7%9B%AE%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>关于机器学习在大气科学的应用</title>
    <link href="https://paradoxallen.github.io/21048/"/>
    <id>https://paradoxallen.github.io/21048/</id>
    <published>2018-05-06T16:00:00.000Z</published>
    <updated>2018-06-13T04:55:26.430Z</updated>
    
    <content type="html"><![CDATA[<p>前阵子阅读了院里一位博士研究生师兄的一篇有关基于神经网络算法对北京近五年的常规探空数据进行自组织分类，并揭示出大气污染物在不同边界层结构下的演变规律和相关机制的文章<a href="https://www.atmos-chem-phys.net/18/6771/2018/" target="_blank" rel="noopener">《Self-organized classification of boundary layer meteorology and associated characteristics of air quality in Beijing》</a>，看完顿时心生膜拜之情；</p><p>然后恰巧也是那个时候吕教授在院群上也转发了一篇关于机器学习预测火势甚至天气的公众号文章<a href="https://mp.weixin.qq.com/s?__biz=MjM5ODE1NDYyMA==&amp;mid=2653384819&amp;idx=2&amp;sn=523f27cb9442ab4af27137edd1280248&amp;chksm=bd1cc8608a6b4176d7cae939f794e082cf86b5bf0ac0deb53790f507f563f588b2148687957c&amp;mpshare=1&amp;scene=1&amp;srcid=0517RYcQWk5dWJCcqoI7jLCe#rd" target="_blank" rel="noopener">《机器学习成功解决“蝴蝶效应”！以后你终于可以相信天气预报了》</a>。</p><p>加之自己报名了一个<a href="https://mp.weixin.qq.com/s?__biz=MzIzMjQyNzQ5MA==&amp;mid=2247487345&amp;idx=1&amp;sn=4acb8978a2d95f0a1926c0e07021bec3&amp;chksm=e89455fcdfe3dcea645499d9321177a99ea713ffe06fe4af9d18c8506dd285755be2a1640539&amp;mpshare=1&amp;scene=1&amp;srcid=04151pmRgGqnfZDpvBL9EKKk#rd" target="_blank" rel="noopener">“预测北京和伦敦两个城市的空气质量”的KDD Cup 2018</a>但是因为自己报名太晚，组队不成（其实更深层的是之前关于机器学习的内容已经忘得差不多了。。。）</p><p>如此的机缘巧合，感觉将机器学习应用于大气科学将前途无量。我自己也想在这一方向进行深入了解，接下来我会进行相关内容的学习。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前阵子阅读了院里一位博士研究生师兄的一篇有关基于神经网络算法对北京近五年的常规探空数据进行自组织分类，并揭示出大气污染物在不同边界层结构下的演变规律和相关机制的文章&lt;a href=&quot;https://www.atmos-chem-phys.net/18/6771/2018/&quot;
      
    
    </summary>
    
      <category term="个人随笔" scheme="https://paradoxallen.github.io/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="机器学习" scheme="https://paradoxallen.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="大气科学" scheme="https://paradoxallen.github.io/tags/%E5%A4%A7%E6%B0%94%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>统计推断(零) 章节简介</title>
    <link href="https://paradoxallen.github.io/5451/"/>
    <id>https://paradoxallen.github.io/5451/</id>
    <published>2018-03-31T16:00:00.000Z</published>
    <updated>2018-06-03T16:17:44.275Z</updated>
    
    <content type="html"><![CDATA[<p>《统计推断(翻译版·原书第2版)》从概率论的基础开始，通过例子与习题的旁征博引，引进了大量近代统计处理的新技术和一些国内同类教材中不常见而又广为使用的分布。</p><p>其内容既包括工科概率入门、经典统计和现代统计的基础，又加进了不少近代统计中数据处理的实用方法和思想，例如：Bootstrap再抽样法、刀切(Jackkrlife)估计、EM算法、Logistic回归、稳健(Robest)回归、Markov链、Monte Carlo方法等。</p><p>它的统计内容与国内流行的教材相比，理论较深，模型较多，案例的涉及面要广，理论的应用面要丰富，统计思想的阐述与算法更为具体。</p><p>《统计推断(翻译版·原书第2版)》可作为工科、管理类学科专业本科生、研究生的教材或参考书，也可供教师、工程技术人员自学之用。</p><a id="more"></a><hr><h3 id="章节简介"><a href="#章节简介" class="headerlink" title="章节简介"></a><strong>章节简介</strong></h3><p><strong>出版说明</strong><br><strong>第2版序</strong><br><strong>第1版序</strong><br><strong>译后序</strong><br><strong>第1章 概率论</strong><br>1.1 集合论<br>1.2 概率论基础<br>1.2.1 公理化基础<br>1.2.2 概率演算<br>1.2.3 计数<br>1.2.4 枚举结果<br>1.3 条件概率与独立性<br>1.4 随机变量<br>1.5 分布函数<br>1.6 概率密度函数和概率质量函数<br>1.7 习题<br>1.8 杂录<br><strong>第2章 变换和期望</strong><br>2.1 随机变量函数的分布<br>2.2 期望<br>2.3 矩和矩母函数<br>2.4 积分号下的求导<br>2.5 习题<br>2.6 杂录<br>2.6.1 矩列的唯一性<br>2.6.2 其他母函数<br>2.6.3 矩母函数能否唯一地确定分布？<br><strong>第3章 常见分布族</strong><br>3.1 引言<br>3.2 离散分布<br>3.3 连续分布<br>3.4 指数族<br>3.5 位置与尺度族<br>3.6 不等式与恒等式<br>3.6.1 概率不等式<br>3.6.2 恒等式<br>3.7 习题<br>3.8 杂录<br>3.8.1 Poisson假设<br>3.8.2 Chebychev不等式及其改进<br>3.8.3 再谈指数族<br><strong>第4章 多维随机变量</strong><br>4.1 联合分布与边缘分布<br>4.2 条件分布与独立性<br>4.3 二维变换<br>4.4 多层模型与混合分布<br>4.5 协方差与相关<br>4.6 多维分布<br>4.7 不等式<br>4.7.1 数值不等式<br>4.7.2 函数不等式<br>4.8 习题<br>4.9 杂录<br>4.9.1 交换悖论<br>4.9.2 算术－几何－调和平均值不等式<br>8.3.1 错误概率与功效函数<br>8.3.2 最大功效检验<br>8.3.3 并－检验与交－并检验的真实水平<br>8.3.4 P-值<br>8.3.5 损失函数最优性<br>8.4 习题<br>8.5 杂录<br>8.5.1 单调功效函数<br>8.5.2 似然比作为证据<br>8.5.3 P-值和后验概率<br>8.5.4 置信集P-值<br><strong>第9章 区间估计</strong><br>9.1 引言<br>9.2 区间估计量的求法<br>9.2.1 反转一个检验统计量<br>9.2.2 枢轴量<br>9.2.3 枢轴化累积分布函数<br>9.2.4 Bayes区间<br>9.3 区间估计量的评价方法<br>9.3.1 尺寸和覆盖概率<br>9.3.2 与检验相关的最优性<br>9.3.3 Bayes最优<br>9.3.4 损失函数最优<br>9.4 习题<br>9.5 杂录<br>9.5.1 置信方法<br>9.5.2 离散分布中的置信区间<br>9.5.3 Fieller定理<br>9.5.4 其他区间如何?<br><strong>第10章 渐近评价</strong><br>10.1 点估计<br>10.1.1 相合性<br>10.1.2 有效性<br>10.1.3 计算与比较<br>10.1.4 自助法标准误差<br>10.2 稳健性<br>10.2.1 均值和中位数<br>10.2.2 M_估计量<br>10.3 假设检验<br>10.3.1 LRT的渐近分布<br>10.3.2 其他大样本检验<br>10.4 区间估计<br>10.4.1 近似极大似然区间<br>10.4.2 其他大样本区间<br>10.5 习题<br>10.6 杂录<br>10.6.1 超有效性<br>10.6.2 适当的正则性条件<br>10.6.3 再谈自助法<br>10.6.4 影响函数<br>10.6.5 自助法区间<br>10.6.6 稳健区间<br><strong>第11章 方差分析和回归分析</strong><br>11.1 引言<br>11.2 一种方式分组的方差分析<br>11.2.1 模型和分布假定<br>11.2.2 经典的ANOVA假设<br>11.2.3 均值的线性组合的推断<br>11.2.4 ANOVAF检验<br>11.2.5 对比的同时估计<br>11.2.6 平方和的分解<br>11.3 简单线性回归<br>11.3.1 最小二乘：数学解<br>11.3.2 最佳线性无偏估计：统计解<br>11.3.3 模型和分布假定<br>11.3.4 正态误差下的估计和检验<br>11.3.5 在给定点x=x0处的估计和预测<br>11.3.6 同时估计和置信带<br>11.4 习题<br>11.5 杂录<br>11.5.1 Cochran定理<br>11.5.2 多重比较<br>11.5.3 随机化完全区组设计<br>11.5.4 其他类型的方差分析<br>11.5.5 置信带的形状<br>11.5.6 Stein悖论<br><strong>第12章 回归模型</strong><br>12.1 引言<br>12.2 变量有误差时的回归<br>12.2.1 函数关系和结构关系<br>12.2.2 最小二乘解<br>12.2.3 极大似然估计<br>12.2.4 置信集<br>12.3 罗吉斯蒂克回归<br>12.3.1 模型<br>12.3.2 估计<br>12.4 稳健回归<br>12.5 习题<br>12.6 杂录<br>12.6.1 函数和结构的意义<br>12.6.2 EIV模型中常规最小乘的相合性<br>12.6.3 EIV模型中的工具变量<br>12.6.4 罗吉斯蒂克似然方程<br>12.6.5 再谈稳健回归<br><strong>附录 计算机代数</strong><br><strong>常用分布表</strong><br><strong>参考文献</strong><br><strong>作者索引</strong><br><strong>名词索引</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《统计推断(翻译版·原书第2版)》从概率论的基础开始，通过例子与习题的旁征博引，引进了大量近代统计处理的新技术和一些国内同类教材中不常见而又广为使用的分布。&lt;/p&gt;
&lt;p&gt;其内容既包括工科概率入门、经典统计和现代统计的基础，又加进了不少近代统计中数据处理的实用方法和思想，例如：Bootstrap再抽样法、刀切(Jackkrlife)估计、EM算法、Logistic回归、稳健(Robest)回归、Markov链、Monte Carlo方法等。&lt;/p&gt;
&lt;p&gt;它的统计内容与国内流行的教材相比，理论较深，模型较多，案例的涉及面要广，理论的应用面要丰富，统计思想的阐述与算法更为具体。&lt;/p&gt;
&lt;p&gt;《统计推断(翻译版·原书第2版)》可作为工科、管理类学科专业本科生、研究生的教材或参考书，也可供教师、工程技术人员自学之用。&lt;/p&gt;
    
    </summary>
    
      <category term="应用统计" scheme="https://paradoxallen.github.io/categories/%E5%BA%94%E7%94%A8%E7%BB%9F%E8%AE%A1/"/>
    
    
      <category term="统计" scheme="https://paradoxallen.github.io/tags/%E7%BB%9F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>机器学习预测房价代码</title>
    <link href="https://paradoxallen.github.io/40260/"/>
    <id>https://paradoxallen.github.io/40260/</id>
    <published>2017-12-24T16:00:00.000Z</published>
    <updated>2018-08-02T06:56:16.264Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;&apos;</span><br><span class="line">analysis</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">import seaborn as sns</span><br><span class="line">from scipy import stats</span><br><span class="line">from scipy.stats import skew</span><br><span class="line">from scipy.stats import norm</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line">from sklearn.manifold import TSNE</span><br><span class="line">from sklearn.cluster import KMeans</span><br><span class="line">from sklearn.decomposition import PCA</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line"></span><br><span class="line">train_df = pd.read_csv(&quot;F:/cs/python/code/houseprice/all/train.csv&quot;)</span><br><span class="line">test_df = pd.read_csv(&quot;F:/cs/python/code/houseprice/all/test.csv&quot;)</span><br><span class="line"></span><br><span class="line">#scaning data</span><br><span class="line">#train data:1460*81 </span><br><span class="line">#test data: 14559*80</span><br><span class="line"></span><br><span class="line">#transtype</span><br><span class="line">all_df = pd.concat((train_df.loc[:,&apos;MSSubClass&apos;:&apos;SaleCondition&apos;], test_df.loc[:,&apos;MSSubClass&apos;:&apos;SaleCondition&apos;]), axis=0,ignore_index=True)</span><br><span class="line">all_df[&apos;MSSubClass&apos;] = all_df[&apos;MSSubClass&apos;].astype(str)</span><br><span class="line"></span><br><span class="line">quantitative = [f for f in all_df.columns if all_df.dtypes[f] != &apos;object&apos;]</span><br><span class="line">qualitative = [f for f in all_df.columns if all_df.dtypes[f] == &apos;object&apos;]</span><br><span class="line"></span><br><span class="line">print(&quot;quantitative: &#123;&#125;, qualitative: &#123;&#125;&quot; .format (len(quantitative),len(qualitative)))</span><br><span class="line"></span><br><span class="line">#missing data processing</span><br><span class="line">#large in amount depose</span><br><span class="line">#little in amount avarage</span><br><span class="line">#middle of the missing data treat as one-hot</span><br><span class="line">missing = all_df.isnull().sum()</span><br><span class="line"></span><br><span class="line">missing.sort_values(inplace=True,ascending=False)</span><br><span class="line">missing = missing[missing &gt; 0]</span><br><span class="line"></span><br><span class="line">types = all_df[missing.index].dtypes</span><br><span class="line"></span><br><span class="line">percent = (all_df[missing.index].isnull().sum()/all_df[missing.index].isnull().count()).sort_values(ascending=False)</span><br><span class="line"></span><br><span class="line">missing_data = pd.concat([missing, percent,types], axis=1, keys=[&apos;Total&apos;, &apos;Percent&apos;,&apos;Types&apos;])</span><br><span class="line">missing_data.sort_values(&apos;Total&apos;,ascending=False,inplace=True)</span><br><span class="line">missing_data</span><br><span class="line"></span><br><span class="line">missing.plot.bar()</span><br><span class="line"></span><br><span class="line">#analysis</span><br><span class="line">#single var</span><br><span class="line">train_df.describe()[&apos;SalePrice&apos;]</span><br><span class="line"></span><br><span class="line">#skewness and kurtosis</span><br><span class="line">print(&quot;Skewness: %f&quot; % train_df[&apos;SalePrice&apos;].skew())</span><br><span class="line">print(&quot;Kurtosis: %f&quot; % train_df[&apos;SalePrice&apos;].kurt())</span><br><span class="line"></span><br><span class="line">#conrver</span><br><span class="line">corrmat = train_df.corr()</span><br><span class="line"></span><br><span class="line">#saleprice correlation matrix</span><br><span class="line">k = 10 #number of variables for heatmap</span><br><span class="line">cols = corrmat.nlargest(k, &apos;SalePrice&apos;)[&apos;SalePrice&apos;].index</span><br><span class="line">cm = np.corrcoef(train_df[cols].values.T)</span><br><span class="line">sns.set(font_scale=1.25)</span><br><span class="line">hm = sns.heatmap(cm, cbar=True, annot=True, square=True, fmt=&apos;.2f&apos;, annot_kws=&#123;&apos;size&apos;: 10&#125;, yticklabels=cols.values, xticklabels=cols.values)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">## both corr and missing</span><br><span class="line">missing_data.index.intersection(cols)</span><br><span class="line"></span><br><span class="line">missing_data.loc[missing_data.index.intersection(cols)]</span><br><span class="line"></span><br><span class="line">#dealing with missing data</span><br><span class="line">all_df = all_df.drop((missing_data[missing_data[&apos;Total&apos;] &gt; 1]).index,1)</span><br><span class="line"># df_train = df_train.drop(df_train.loc[df_train[&apos;Electrical&apos;].isnull()].index)</span><br><span class="line">all_df.isnull().sum().max() #just checking that there&apos;s no missing data missing...</span><br><span class="line"># missing 1 replace with average</span><br><span class="line"></span><br><span class="line">#normal probability plot</span><br><span class="line">sns.distplot(train_df[&apos;SalePrice&apos;], fit=norm);</span><br><span class="line">fig = plt.figure()</span><br><span class="line">res = stats.probplot(train_df[&apos;SalePrice&apos;], plot=plt)</span><br><span class="line"></span><br><span class="line">#log</span><br><span class="line">train_df[&apos;SalePrice&apos;] = np.log(train_df[&apos;SalePrice&apos;])</span><br><span class="line"></span><br><span class="line">#histogram and normal probability plot</span><br><span class="line">sns.distplot(train_df[&apos;SalePrice&apos;], fit=norm);</span><br><span class="line">fig = plt.figure()</span><br><span class="line">res = stats.probplot(train_df[&apos;SalePrice&apos;], plot=plt)</span><br><span class="line"></span><br><span class="line">#observe every var</span><br><span class="line">quantitative = [f for f in all_df.columns if all_df.dtypes[f] != &apos;object&apos;]</span><br><span class="line">qualitative = [f for f in all_df.columns if all_df.dtypes[f] == &apos;object&apos;]</span><br><span class="line">print(&quot;quantitative: &#123;&#125;, qualitative: &#123;&#125;&quot; .format (len(quantitative),len(qualitative)))</span><br><span class="line"></span><br><span class="line">f = pd.melt(all_df, value_vars=quantitative)</span><br><span class="line">g = sns.FacetGrid(f, col=&quot;variable&quot;,  col_wrap=2, sharex=False, sharey=False)</span><br><span class="line">g = g.map(sns.distplot, &quot;value&quot;)</span><br><span class="line"></span><br><span class="line">#LotArea,BsmtUnfSF,1stFlrSF,TotalBsmtSF,KitchenAbvGr can be improved by log</span><br><span class="line">#skewness</span><br><span class="line">all_df[quantitative].apply(lambda x: skew(x.dropna())).sort_values(ascending=False)</span><br><span class="line"></span><br><span class="line">#quantity charctive analysis</span><br><span class="line">#Analysis of variance</span><br><span class="line">train = all_df.loc[train_df.index]</span><br><span class="line">train[&apos;SalePrice&apos;] = train_df.SalePrice</span><br><span class="line"></span><br><span class="line">def anova(frame):</span><br><span class="line">    anv = pd.DataFrame()</span><br><span class="line">    anv[&apos;feature&apos;] = qualitative</span><br><span class="line">    pvals = []</span><br><span class="line">    for c in qualitative:</span><br><span class="line">        samples = []</span><br><span class="line">        for cls in frame[c].unique():</span><br><span class="line">            s = frame[frame[c] == cls][&apos;SalePrice&apos;].values</span><br><span class="line">            samples.append(s)</span><br><span class="line">        pval = stats.f_oneway(*samples)[1]</span><br><span class="line">        pvals.append(pval)</span><br><span class="line">    anv[&apos;pval&apos;] = pvals</span><br><span class="line">    return anv.sort_values(&apos;pval&apos;)</span><br><span class="line"></span><br><span class="line">a = anova(train)</span><br><span class="line">a[&apos;disparity&apos;] = np.log(1./a[&apos;pval&apos;].values)</span><br><span class="line">sns.barplot(data=a, x=&apos;feature&apos;, y=&apos;disparity&apos;)</span><br><span class="line">x=plt.xticks(rotation=90)</span><br><span class="line"></span><br><span class="line">#quality charctive analysis</span><br><span class="line">def encode(frame, feature):</span><br><span class="line">    ordering = pd.DataFrame()</span><br><span class="line">    ordering[&apos;val&apos;] = frame[feature].unique()</span><br><span class="line">    ordering.index = ordering.val</span><br><span class="line">    ordering[&apos;spmean&apos;] = frame[[feature, &apos;SalePrice&apos;]].groupby(feature).mean()[&apos;SalePrice&apos;]</span><br><span class="line">    ordering = ordering.sort_values(&apos;spmean&apos;)</span><br><span class="line">    ordering[&apos;ordering&apos;] = range(1, ordering.shape[0]+1)</span><br><span class="line">    ordering = ordering[&apos;ordering&apos;].to_dict()</span><br><span class="line">    </span><br><span class="line">    for cat, o in ordering.items():</span><br><span class="line">        frame.loc[frame[feature] == cat, feature+&apos;_E&apos;] = o</span><br><span class="line">    </span><br><span class="line">qual_encoded = []</span><br><span class="line">for q in qualitative:  </span><br><span class="line">    encode(train, q)</span><br><span class="line">    qual_encoded.append(q+&apos;_E&apos;)</span><br><span class="line">print(qual_encoded)</span><br><span class="line"></span><br><span class="line"># choose raws of having missing data</span><br><span class="line">missing_data = all_df.isnull().sum()</span><br><span class="line">missing_data = missing_data[missing_data&gt;0]</span><br><span class="line">ids = all_df[missing_data.index].isnull()</span><br><span class="line"># index (0), columns (1)</span><br><span class="line">all_df.loc[ids[ids.any(axis=1)].index][missing_data.index]</span><br><span class="line"></span><br><span class="line"># nan still nan</span><br><span class="line">train.loc[1379,&apos;Electrical_E&apos;]</span><br><span class="line"></span><br><span class="line">#corr computing</span><br><span class="line">def spearman(frame, features):</span><br><span class="line">    spr = pd.DataFrame()</span><br><span class="line">    spr[&apos;feature&apos;] = features</span><br><span class="line">    #Signature: a.corr(other, method=&apos;pearson&apos;, min_periods=None)</span><br><span class="line">    #Docstring:</span><br><span class="line">    #Compute correlation with `other` Series, excluding missing values</span><br><span class="line">    # 计算特征和 SalePrice的 斯皮尔曼 相关系数</span><br><span class="line">    spr[&apos;spearman&apos;] = [frame[f].corr(frame[&apos;SalePrice&apos;], &apos;spearman&apos;) for f in features]</span><br><span class="line">    spr = spr.sort_values(&apos;spearman&apos;)</span><br><span class="line">    plt.figure(figsize=(6, 0.25*len(features))) # width, height</span><br><span class="line">    sns.barplot(data=spr, y=&apos;feature&apos;, x=&apos;spearman&apos;, orient=&apos;h&apos;)</span><br><span class="line">    </span><br><span class="line">features = quantitative + qual_encoded</span><br><span class="line">spearman(train, features)</span><br><span class="line"># OverallQual Neighborhood GrLiveArea have bing influence on price</span><br><span class="line"></span><br><span class="line">#corr between vars</span><br><span class="line">plt.figure(1)</span><br><span class="line">corr = train[quantitative+[&apos;SalePrice&apos;]].corr()</span><br><span class="line">sns.heatmap(corr)</span><br><span class="line">plt.figure(2)</span><br><span class="line">corr = train[qual_encoded+[&apos;SalePrice&apos;]].corr()</span><br><span class="line">sns.heatmap(corr)</span><br><span class="line">plt.figure(3)</span><br><span class="line"># [31,27]</span><br><span class="line">corr = pd.DataFrame(np.zeros([len(quantitative)+1, len(qual_encoded)+1]), index=quantitative+[&apos;SalePrice&apos;], columns=qual_encoded+[&apos;SalePrice&apos;])</span><br><span class="line">for q1 in quantitative+[&apos;SalePrice&apos;]:</span><br><span class="line">    for q2 in qual_encoded+[&apos;SalePrice&apos;]:</span><br><span class="line">        corr.loc[q1, q2] = train[q1].corr(train[q2])</span><br><span class="line">sns.heatmap(corr)</span><br><span class="line"></span><br><span class="line">#Pairplots</span><br><span class="line">def pairplot(x, y, **kwargs):</span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    ts = pd.DataFrame(&#123;&apos;time&apos;: x, &apos;val&apos;: y&#125;)</span><br><span class="line">    ts = ts.groupby(&apos;time&apos;).mean()</span><br><span class="line">    ts.plot(ax=ax)</span><br><span class="line">    plt.xticks(rotation=90)</span><br><span class="line">    </span><br><span class="line">f = pd.melt(train, id_vars=[&apos;SalePrice&apos;], value_vars=quantitative+qual_encoded)</span><br><span class="line">g = sns.FacetGrid(f, col=&quot;variable&quot;,  col_wrap=2, sharex=False, sharey=False, size=5)</span><br><span class="line">g = g.map(pairplot, &quot;value&quot;, &quot;SalePrice&quot;)</span><br><span class="line"></span><br><span class="line">#price departing</span><br><span class="line">a = train[&apos;SalePrice&apos;]</span><br><span class="line">a.plot.hist()</span><br><span class="line"></span><br><span class="line">features = quantitative</span><br><span class="line"></span><br><span class="line">standard = train[train[&apos;SalePrice&apos;] &lt; np.log(200000)]</span><br><span class="line">pricey = train[train[&apos;SalePrice&apos;] &gt;= np.log(200000)]</span><br><span class="line"></span><br><span class="line">diff = pd.DataFrame()</span><br><span class="line">diff[&apos;feature&apos;] = features</span><br><span class="line">diff[&apos;difference&apos;] = [(pricey[f].fillna(0.).mean() - standard[f].fillna(0.).mean())/(standard[f].fillna(0.).mean())</span><br><span class="line">                      for f in features]</span><br><span class="line"></span><br><span class="line">sns.barplot(data=diff, x=&apos;feature&apos;, y=&apos;difference&apos;)</span><br><span class="line">x=plt.xticks(rotation=90)</span><br><span class="line"></span><br><span class="line">#classfing</span><br><span class="line">features = quantitative + qual_encoded</span><br><span class="line">model = TSNE(n_components=2, random_state=0, perplexity=50)</span><br><span class="line">X = train[features].fillna(0.).values</span><br><span class="line">tsne = model.fit_transform(X)</span><br><span class="line"></span><br><span class="line">std = StandardScaler()</span><br><span class="line">s = std.fit_transform(X)</span><br><span class="line">pca = PCA(n_components=30)</span><br><span class="line">pca.fit(s)</span><br><span class="line">pc = pca.transform(s)</span><br><span class="line">kmeans = KMeans(n_clusters=5)</span><br><span class="line">kmeans.fit(pc)</span><br><span class="line"></span><br><span class="line">fr = pd.DataFrame(&#123;&apos;tsne1&apos;: tsne[:,0], &apos;tsne2&apos;: tsne[:, 1], &apos;cluster&apos;: kmeans.labels_&#125;)</span><br><span class="line">sns.lmplot(data=fr, x=&apos;tsne1&apos;, y=&apos;tsne2&apos;, hue=&apos;cluster&apos;, fit_reg=False)</span><br><span class="line">print(np.sum(pca.explained_variance_ratio_))</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">model</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">import seaborn as sns</span><br><span class="line">from scipy import stats</span><br><span class="line">from scipy.stats import skew</span><br><span class="line">from scipy.stats import norm</span><br><span class="line">import matplotlib</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line">from sklearn.manifold import TSNE</span><br><span class="line">from sklearn.cluster import KMeans</span><br><span class="line">from sklearn.decomposition import PCA</span><br><span class="line">from sklearn.preprocessing import StandardScaler</span><br><span class="line"></span><br><span class="line">train_df = pd.read_csv(&quot;F:/cs/python/code/houseprice/all/train.csv&quot;)</span><br><span class="line">test_df = pd.read_csv(&quot;F:/cs/python/code/houseprice/all/test.csv&quot;)</span><br><span class="line"></span><br><span class="line">#feature engineering</span><br><span class="line">all_df = pd.concat((train_df.loc[:,&apos;MSSubClass&apos;:&apos;SaleCondition&apos;], test_df.loc[:,&apos;MSSubClass&apos;:&apos;SaleCondition&apos;]), axis=0,ignore_index=True)</span><br><span class="line">all_df[&apos;MSSubClass&apos;] = all_df[&apos;MSSubClass&apos;].astype(str)</span><br><span class="line">quantitative = [f for f in all_df.columns if all_df.dtypes[f] != &apos;object&apos;]</span><br><span class="line">qualitative = [f for f in all_df.columns if all_df.dtypes[f] == &apos;object&apos;]</span><br><span class="line"></span><br><span class="line">#dealing missing data</span><br><span class="line">missing = all_df.isnull().sum()</span><br><span class="line">missing.sort_values(inplace=True,ascending=False)</span><br><span class="line">missing = missing[missing &gt; 0]</span><br><span class="line"></span><br><span class="line">#missing 1 replaced with average</span><br><span class="line">all_df = all_df.drop(missing[missing&gt;1].index,1)</span><br><span class="line"></span><br><span class="line">all_df.isnull().sum()[all_df.isnull().sum()&gt;0]</span><br><span class="line"></span><br><span class="line">#dealing log(GrLivArea、1stFlrSF、2ndFlrSF、TotalBsmtSF、LotArea、KitchenAbvGr、GarageArea )</span><br><span class="line">logfeatures = [&apos;GrLivArea&apos;,&apos;1stFlrSF&apos;,&apos;2ndFlrSF&apos;,&apos;TotalBsmtSF&apos;,&apos;LotArea&apos;,&apos;KitchenAbvGr&apos;,&apos;GarageArea&apos;]</span><br><span class="line"></span><br><span class="line">for logfeature in logfeatures:</span><br><span class="line">    all_df[logfeature] = np.log1p(all_df[logfeature].values)</span><br><span class="line"></span><br><span class="line">#dealing boolean var</span><br><span class="line">all_df[&apos;HasBasement&apos;] = all_df[&apos;TotalBsmtSF&apos;].apply(lambda x: 1 if x &gt; 0 else 0)</span><br><span class="line">all_df[&apos;HasGarage&apos;] = all_df[&apos;GarageArea&apos;].apply(lambda x: 1 if x &gt; 0 else 0)</span><br><span class="line">all_df[&apos;Has2ndFloor&apos;] = all_df[&apos;2ndFlrSF&apos;].apply(lambda x: 1 if x &gt; 0 else 0)</span><br><span class="line">all_df[&apos;HasWoodDeck&apos;] = all_df[&apos;WoodDeckSF&apos;].apply(lambda x: 1 if x &gt; 0 else 0)</span><br><span class="line">all_df[&apos;HasPorch&apos;] = all_df[&apos;OpenPorchSF&apos;].apply(lambda x: 1 if x &gt; 0 else 0)</span><br><span class="line">all_df[&apos;HasPool&apos;] = all_df[&apos;PoolArea&apos;].apply(lambda x: 1 if x &gt; 0 else 0)</span><br><span class="line">all_df[&apos;IsNew&apos;] = all_df[&apos;YearBuilt&apos;].apply(lambda x: 1 if x &gt; 2000 else 0)</span><br><span class="line"></span><br><span class="line">quantitative = [f for f in all_df.columns if all_df.dtypes[f] != &apos;object&apos;]</span><br><span class="line">qualitative = [f for f in all_df.columns if all_df.dtypes[f] == &apos;object&apos;]</span><br><span class="line"></span><br><span class="line">#encode quanlity</span><br><span class="line">all_dummy_df = pd.get_dummies(all_df)</span><br><span class="line"></span><br><span class="line">#standize var</span><br><span class="line">all_dummy_df.isnull().sum().sum()</span><br><span class="line"></span><br><span class="line">mean_cols = all_dummy_df.mean()</span><br><span class="line">all_dummy_df = all_dummy_df.fillna(mean_cols)</span><br><span class="line"></span><br><span class="line">all_dummy_df.isnull().sum().sum()</span><br><span class="line"></span><br><span class="line">X = all_dummy_df[quantitative]</span><br><span class="line">std = StandardScaler()</span><br><span class="line">s = std.fit_transform(X)</span><br><span class="line"></span><br><span class="line">all_dummy_df[quantitative] = s</span><br><span class="line"></span><br><span class="line">dummy_train_df = all_dummy_df.loc[train_df.index]</span><br><span class="line">dummy_test_df = all_dummy_df.loc[test_df.index]</span><br><span class="line"></span><br><span class="line">y_train = np.log(train_df.SalePrice)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#model predicting</span><br><span class="line">#ridge regression</span><br><span class="line">from sklearn.linear_model import Ridge</span><br><span class="line">from sklearn.model_selection import cross_val_score</span><br><span class="line">y_train.values</span><br><span class="line"></span><br><span class="line">def rmse_cv(model):</span><br><span class="line">    rmse= np.sqrt(-cross_val_score(model, dummy_train_df, y_train.values, scoring=&quot;neg_mean_squared_error&quot;, cv = 5))</span><br><span class="line">    return(rmse)</span><br><span class="line">alphas = np.logspace(-3, 2, 50)</span><br><span class="line">cv_ridge = []</span><br><span class="line">coefs = []</span><br><span class="line">for alpha in alphas:</span><br><span class="line">    model = Ridge(alpha = alpha)</span><br><span class="line">    model.fit(dummy_train_df,y_train)</span><br><span class="line">    cv_ridge.append(rmse_cv(model).mean())</span><br><span class="line">    coefs.append(model.coef_)</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">cv_ridge = pd.Series(cv_ridge, index = alphas)</span><br><span class="line">cv_ridge.plot(title = &quot;Validation - Just Do It&quot;)</span><br><span class="line">plt.xlabel(&quot;alpha&quot;)</span><br><span class="line">plt.ylabel(&quot;rmse&quot;)</span><br><span class="line"># plt.plot(alphas, cv_ridge)</span><br><span class="line"># plt.title(&quot;Alpha vs CV Error&quot;)</span><br><span class="line"></span><br><span class="line">#ridge trace picture</span><br><span class="line"># matplotlib.rcParams[&apos;figure.figsize&apos;] = (12.0, 12.0)</span><br><span class="line">ax = plt.gca()</span><br><span class="line"></span><br><span class="line"># ax.set_color_cycle([&apos;b&apos;, &apos;r&apos;, &apos;g&apos;, &apos;c&apos;, &apos;k&apos;, &apos;y&apos;, &apos;m&apos;])</span><br><span class="line"></span><br><span class="line">ax.plot(alphas, coefs)</span><br><span class="line">ax.set_xscale(&apos;log&apos;)</span><br><span class="line">ax.set_xlim(ax.get_xlim()[::-1])  # reverse axis</span><br><span class="line">plt.xlabel(&apos;alpha&apos;)</span><br><span class="line">plt.ylabel(&apos;weights&apos;)</span><br><span class="line">plt.title(&apos;Ridge coefficients as a function of the regularization&apos;)</span><br><span class="line">plt.axis(&apos;tight&apos;)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">#lesso :can choose some of feature</span><br><span class="line">from sklearn.linear_model import Lasso,LassoCV</span><br><span class="line"></span><br><span class="line"># alphas = np.logspace(-3, 2, 50)</span><br><span class="line"># alphas = [1, 0.1, 0.001, 0.0005]</span><br><span class="line">alphas = np.logspace(-4, -2, 100)</span><br><span class="line">cv_lasso = []</span><br><span class="line">coefs = []</span><br><span class="line">for alpha in alphas:</span><br><span class="line">    model = Lasso(alpha = alpha,max_iter=5000)</span><br><span class="line">    model.fit(dummy_train_df,y_train)</span><br><span class="line">    cv_lasso.append(rmse_cv(model).mean())</span><br><span class="line">    coefs.append(model.coef_)</span><br><span class="line"></span><br><span class="line">cv_lasso = pd.Series(cv_lasso, index = alphas)</span><br><span class="line">cv_lasso.plot(title = &quot;Validation - Just Do It&quot;)</span><br><span class="line">plt.xlabel(&quot;alpha&quot;)</span><br><span class="line">plt.ylabel(&quot;rmse&quot;)</span><br><span class="line"># plt.plot(alphas, cv_ridge)</span><br><span class="line"># plt.title(&quot;Alpha vs CV Error&quot;</span><br><span class="line"></span><br><span class="line">print(cv_lasso.min(), cv_lasso.argmin())</span><br><span class="line"></span><br><span class="line">model = Lasso(alpha = 0.00058,max_iter=5000)</span><br><span class="line">model.fit(dummy_train_df,y_train)</span><br><span class="line">Lasso(alpha=0.00058, copy_X=True, fit_intercept=True, max_iter=5000,</span><br><span class="line">   normalize=False, positive=False, precompute=False, random_state=None,</span><br><span class="line">   selection=&apos;cyclic&apos;, tol=0.0001, warm_start=False)</span><br><span class="line">coef = pd.Series(model.coef_, index = dummy_train_df.columns)</span><br><span class="line">print(&quot;Lasso picked &quot; + str(sum(coef != 0)) + &quot; variables and eliminated the other &quot; +  str(sum(coef == 0)) + &quot; variables&quot;)</span><br><span class="line"></span><br><span class="line">imp_coef = pd.concat([coef.sort_values().head(10),</span><br><span class="line">                     coef.sort_values().tail(10)])</span><br><span class="line">matplotlib.rcParams[&apos;figure.figsize&apos;] = (8.0, 10.0)</span><br><span class="line">imp_coef.plot(kind = &quot;barh&quot;)</span><br><span class="line">plt.title(&quot;Coefficients in the Lasso Model&quot;)</span><br><span class="line"></span><br><span class="line">#Elastic Net :connect with lasso and ridge</span><br><span class="line"></span><br><span class="line">from sklearn.linear_model import ElasticNet,ElasticNetCV</span><br><span class="line">elastic = ElasticNetCV(l1_ratio=[.1, .5, .7, .9, .95, .99, 1], </span><br><span class="line">                                    alphas=[0.001, 0.05, 0.1, 0.3, 1, 3, 5, 10, 15, 30, 50, 75], cv=5,max_iter=5000)</span><br><span class="line">elastic.fit(dummy_train_df, y_train)</span><br><span class="line">ElasticNetCV(alphas=[0.001, 0.05, 0.1, 0.3, 1, 3, 5, 10, 15, 30, 50, 75],</span><br><span class="line">       copy_X=True, cv=5, eps=0.001, fit_intercept=True,</span><br><span class="line">       l1_ratio=[0.1, 0.5, 0.7, 0.9, 0.95, 0.99, 1], max_iter=5000,</span><br><span class="line">       n_alphas=100, n_jobs=1, normalize=False, positive=False,</span><br><span class="line">       precompute=&apos;auto&apos;, random_state=None, selection=&apos;cyclic&apos;,</span><br><span class="line">       tol=0.0001, verbose=0)</span><br><span class="line">rmse_cv(elastic).mean()</span><br><span class="line"></span><br><span class="line">#feature engineering 2 (another methon)</span><br><span class="line">import utils</span><br><span class="line">train_df_munged,label_df,test_df_munged = utils.feature_engineering()</span><br><span class="line"></span><br><span class="line">test_df = pd.read_csv(&apos;../input/test.csv&apos;)</span><br><span class="line">from sklearn.metrics import mean_squared_error,make_scorer</span><br><span class="line">from sklearn.model_selection import cross_val_score</span><br><span class="line"># 定义自己的score函数</span><br><span class="line">def my_custom_loss_func(ground_truth, predictions):</span><br><span class="line">    return np.sqrt(mean_squared_error(np.exp(ground_truth), np.exp(predictions)))</span><br><span class="line"></span><br><span class="line">my_loss_func  = make_scorer(my_custom_loss_func, greater_is_better=False)</span><br><span class="line">def rmse_cv2(model):</span><br><span class="line">    rmse= np.sqrt(-cross_val_score(model, train_df_munged, label_df.SalePrice, scoring=&apos;neg_mean_squared_error&apos;, cv = 5))</span><br><span class="line">    return(rmse)</span><br><span class="line"></span><br><span class="line">#ridge2</span><br><span class="line">from sklearn.linear_model import RidgeCV,Ridge</span><br><span class="line">alphas = np.logspace(-3, 2, 100)</span><br><span class="line">model_ridge = RidgeCV(alphas=alphas).fit(train_df_munged, label_df.SalePrice)</span><br><span class="line"># Run prediction on training set to get a rough idea of how well it does.</span><br><span class="line">pred_Y_ridge = model_ridge.predict(train_df_munged)</span><br><span class="line">print(&quot;Ridge score on training set: &quot;, model_ridge.score(train_df_munged,label_df.SalePrice))</span><br><span class="line">print(&quot;cross_validation: &quot;,rmse_cv2(model_ridge).mean())</span><br><span class="line"></span><br><span class="line">#lasso2</span><br><span class="line">from sklearn.linear_model import Lasso,LassoCV</span><br><span class="line">model_lasso = LassoCV(eps=0.0001,max_iter=20000).fit(train_df_munged, label_df.SalePrice)</span><br><span class="line"># Run prediction on training set to get a rough idea of how well it does.</span><br><span class="line">pred_Y_lasso = model_lasso.predict(train_df_munged)</span><br><span class="line">print(&quot;Lasso score on training set: &quot;, model_lasso.score(train_df_munged,label_df.SalePrice))</span><br><span class="line"></span><br><span class="line">print(&quot;cross_validation: &quot;,rmse_cv2(model_lasso).mean())</span><br><span class="line"></span><br><span class="line">#Elastic Net</span><br><span class="line">from sklearn.linear_model import ElasticNet,ElasticNetCV</span><br><span class="line">model_elastic = ElasticNetCV(l1_ratio=[.1, .5, .7, .9, .95, .99, 1], </span><br><span class="line">                                    alphas=[0.001, 0.05, 0.1, 0.3, 1, 3, 5, 10, 15, 30, 50, 75], cv=5,max_iter=10000)</span><br><span class="line">model_elastic.fit(train_df_munged, label_df.SalePrice)</span><br><span class="line">ElasticNetCV(alphas=[0.001, 0.05, 0.1, 0.3, 1, 3, 5, 10, 15, 30, 50, 75],</span><br><span class="line">       copy_X=True, cv=5, eps=0.001, fit_intercept=True,</span><br><span class="line">       l1_ratio=[0.1, 0.5, 0.7, 0.9, 0.95, 0.99, 1], max_iter=10000,</span><br><span class="line">       n_alphas=100, n_jobs=1, normalize=False, positive=False,</span><br><span class="line">       precompute=&apos;auto&apos;, random_state=None, selection=&apos;cyclic&apos;,</span><br><span class="line">       tol=0.0001, verbose=0)</span><br><span class="line"># Run prediction on training set to get a rough idea of how well it does.</span><br><span class="line">pred_Y_elastic = model_elastic.predict(train_df_munged)</span><br><span class="line">print(&quot;Elastic score on training set: &quot;, model_elastic.score(train_df_munged,label_df.SalePrice))</span><br><span class="line"></span><br><span class="line">print(&quot;cross_validation: &quot;,rmse_cv2(model_elastic).mean())</span><br><span class="line"></span><br><span class="line">#XGBoost</span><br><span class="line"># XGBoost -- I did some &quot;manual&quot; cross-validation here but should really find</span><br><span class="line"># these hyperparameters using CV. ;-)</span><br><span class="line"></span><br><span class="line">import xgboost as xgb</span><br><span class="line"></span><br><span class="line">model_xgb = xgb.XGBRegressor(</span><br><span class="line">                 colsample_bytree=0.2,</span><br><span class="line">                 gamma=0.0,</span><br><span class="line">                 learning_rate=0.05,</span><br><span class="line">                 max_depth=6,</span><br><span class="line">                 min_child_weight=1.5,</span><br><span class="line">                 n_estimators=7200,                                                                  </span><br><span class="line">                 reg_alpha=0.9,</span><br><span class="line">                 reg_lambda=0.6,</span><br><span class="line">                 subsample=0.2,</span><br><span class="line">                 seed=42,</span><br><span class="line">                 silent=1)</span><br><span class="line"></span><br><span class="line">model_xgb.fit(train_df_munged, label_df.SalePrice)</span><br><span class="line"></span><br><span class="line"># Run prediction on training set to get a rough idea of how well it does.</span><br><span class="line">pred_Y_xgb = model_xgb.predict(train_df_munged)</span><br><span class="line">print(&quot;XGBoost score on training set: &quot;, model_xgb.score(train_df_munged,label_df.SalePrice)) # 过拟合</span><br><span class="line"></span><br><span class="line">print(&quot;cross_validation: &quot;,rmse_cv2(model_xgb).mean())</span><br><span class="line"></span><br><span class="line">print(&quot;score: &quot;,mean_squared_error(model_xgb.predict(train_df_munged),label_df.SalePrice))</span><br><span class="line"></span><br><span class="line">#Ensemble</span><br><span class="line">from sklearn.linear_model import LinearRegression</span><br><span class="line"># Create linear regression object</span><br><span class="line">regr = LinearRegression()</span><br><span class="line">train_x = np.concatenate(</span><br><span class="line">    (pred_Y_lasso[np.newaxis, :].T,pred_Y_ridge[np.newaxis, :].T,</span><br><span class="line">     pred_Y_elastic[np.newaxis, :].T,pred_Y_xgb[np.newaxis, :].T), axis=1)</span><br><span class="line">regr.fit(train_x,label_df.SalePrice)</span><br><span class="line">LinearRegression(copy_X=True, fit_intercept=True, n_jobs=1, normalize=False)</span><br><span class="line">regr.coef_</span><br><span class="line"></span><br><span class="line">print(&quot;Ensemble score on training set: &quot;, regr.score(train_x,label_df.SalePrice)) # overfitting</span><br><span class="line"></span><br><span class="line">print(&quot;score: &quot;,mean_squared_error(regr.predict(train_x),label_df.SalePrice))</span><br><span class="line"></span><br><span class="line">#submit</span><br><span class="line">model_lasso.predict(test_df_munged)[np.newaxis, :].T</span><br><span class="line"></span><br><span class="line">test_x = np.concatenate(</span><br><span class="line">(model_lasso.predict(test_df_munged)[np.newaxis, :].T,model_ridge.predict(test_df_munged)[np.newaxis, :].T,</span><br><span class="line">                           model_elastic.predict(test_df_munged)[np.newaxis, :].T, model_xgb.predict(test_df_munged)[np.newaxis, :].T)</span><br><span class="line">        ,axis=1)</span><br><span class="line">y_final = regr.predict(test_x)</span><br><span class="line">y_final</span><br><span class="line"></span><br><span class="line">submission_df = pd.DataFrame(data= &#123;&apos;Id&apos; : test_df.Id, &apos;SalePrice&apos;: np.exp(y_final)&#125;)</span><br><span class="line">submission_df.to_csv(&quot;bag-4.csv&quot;,index=False) # conceal index</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="机器学习" scheme="https://paradoxallen.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://paradoxallen.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>异步IO</title>
    <link href="https://paradoxallen.github.io/41954/"/>
    <id>https://paradoxallen.github.io/41954/</id>
    <published>2017-12-09T16:00:00.000Z</published>
    <updated>2018-08-05T06:46:09.794Z</updated>
    
    <content type="html"><![CDATA[<p>在IO编程一节中，我们已经知道，CPU的速度远远快于磁盘、网络等IO。在一个线程中，CPU执行代码的速度极快，然而，一旦遇到IO操作，如读写文件、发送网络数据时，就需要等待IO操作完成，才能继续进行下一步操作。这种情况称为同步IO。</p><p>在IO操作的过程中，当前线程被挂起，而其他需要CPU执行的代码就无法被当前线程执行了。</p><p>因为一个IO操作就阻塞了当前线程，导致其他代码无法执行，所以我们必须使用多线程或者多进程来并发执行代码，为多个用户服务。每个用户都会分配一个线程，如果遇到IO导致线程被挂起，其他用户的线程不受影响。</p><p>多线程和多进程的模型虽然解决了并发问题，但是系统不能无上限地增加线程。由于系统切换线程的开销也很大，所以，一旦线程数量过多，CPU的时间就花在线程切换上了，真正运行代码的时间就少了，结果导致性能严重下降。</p><p>由于我们要解决的问题是CPU高速执行能力和IO设备的龟速严重不匹配，多线程和多进程只是解决这一问题的一种方法。</p><p>另一种解决IO问题的方法是异步IO。当代码需要执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了。一段时间后，当IO返回结果时，再通知CPU进行处理。</p><p>可以想象如果按普通顺序写出的代码实际上是没法完成异步IO的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">do_some_code()</span><br><span class="line">f = open(&apos;/path/to/file&apos;, &apos;r&apos;)</span><br><span class="line">r = f.read() # &lt;== 线程停在此处等待IO操作结果</span><br><span class="line"># IO操作完成后线程才能继续执行:</span><br><span class="line">do_some_code(r)</span><br></pre></td></tr></table></figure></p><p>所以，同步IO模型的代码是无法实现异步IO模型的。</p><p>异步IO模型需要一个消息循环，在消息循环中，主线程不断地重复“读取消息-处理消息”这一过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">loop = get_event_loop()</span><br><span class="line">while True:</span><br><span class="line">    event = loop.get_event()</span><br><span class="line">    process_event(event)</span><br></pre></td></tr></table></figure></p><p>消息模型其实早在应用在桌面应用程序中了。一个GUI程序的主线程就负责不停地读取消息并处理消息。所有的键盘、鼠标等消息都被发送到GUI程序的消息队列中，然后由GUI程序的主线程处理。</p><p>由于GUI线程处理键盘、鼠标等消息的速度非常快，所以用户感觉不到延迟。某些时候，GUI线程在一个消息处理的过程中遇到问题导致一次消息处理时间过长，此时，用户会感觉到整个GUI程序停止响应了，敲键盘、点鼠标都没有反应。这种情况说明在消息模型中，处理一个消息必须非常迅速，否则，主线程将无法及时处理消息队列中的其他消息，导致程序看上去停止响应。</p><p>消息模型是如何解决同步IO必须等待IO操作这一问题的呢？当遇到IO操作时，代码只负责发出IO请求，不等待IO结果，然后直接结束本轮消息处理，进入下一轮消息处理过程。当IO操作完成后，将收到一条“IO完成”的消息，处理该消息时就可以直接获取IO操作结果。</p><p>在“发出IO请求”到收到“IO完成”的这段时间里，同步IO模型下，主线程只能挂起，但异步IO模型下，主线程并没有休息，而是在消息循环中继续处理其他消息。这样，在异步IO模型下，一个线程就可以同时处理多个IO请求，并且没有切换线程的操作。对于大多数IO密集型的应用程序，使用异步IO将大大提升系统的多任务处理能力。</p><a id="more"></a><hr><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>在学习异步IO模型前，我们先来了解协程。</p><p>协程，又称微线程，纤程。英文名Coroutine。</p><p>协程的概念很早就提出来了，但直到最近几年才在某些语言（如Lua）中得到广泛应用。</p><p>子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。</p><p>所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。</p><p>子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。</p><p>协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p><p>注意，在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似CPU的中断。比如子程序A、B：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def A():</span><br><span class="line">    print(&apos;1&apos;)</span><br><span class="line">    print(&apos;2&apos;)</span><br><span class="line">    print(&apos;3&apos;)</span><br><span class="line"></span><br><span class="line">def B():</span><br><span class="line">    print(&apos;x&apos;)</span><br><span class="line">    print(&apos;y&apos;)</span><br><span class="line">    print(&apos;z&apos;)</span><br></pre></td></tr></table></figure></p><p>假设由协程执行，在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A，结果可能是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">x</span><br><span class="line">y</span><br><span class="line">3</span><br><span class="line">z</span><br></pre></td></tr></table></figure></p><p>但是在A中是没有调用B的，所以协程的调用比函数调用理解起来要难一些。</p><p>看起来A、B的执行有点像多线程，但协程的特点在于是一个线程执行，那和多线程比，协程有何优势？</p><p>最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p><p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p><p>因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</p><p>Python对协程的支持是通过generator实现的。</p><p>在generator中，我们不但可以通过for循环来迭代，还可以不断调用next()函数获取由yield语句返回的下一个值。</p><p>但是Python的yield不但可以返回一个值，它还可以接收调用者发出的参数。</p><p>来看例子：</p><p>传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。</p><p>如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def consumer():</span><br><span class="line">    r = &apos;&apos;</span><br><span class="line">    while True:</span><br><span class="line">        n = yield r</span><br><span class="line">        if not n:</span><br><span class="line">            return</span><br><span class="line">        print(&apos;[CONSUMER] Consuming %s...&apos; % n)</span><br><span class="line">        r = &apos;200 OK&apos;</span><br><span class="line"></span><br><span class="line">def produce(c):</span><br><span class="line">    c.send(None)</span><br><span class="line">    n = 0</span><br><span class="line">    while n &lt; 5:</span><br><span class="line">        n = n + 1</span><br><span class="line">        print(&apos;[PRODUCER] Producing %s...&apos; % n)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        print(&apos;[PRODUCER] Consumer return: %s&apos; % r)</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line">c = consumer()</span><br><span class="line">produce(c)</span><br></pre></td></tr></table></figure></p><p>执行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[PRODUCER] Producing 1...</span><br><span class="line">[CONSUMER] Consuming 1...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 2...</span><br><span class="line">[CONSUMER] Consuming 2...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 3...</span><br><span class="line">[CONSUMER] Consuming 3...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 4...</span><br><span class="line">[CONSUMER] Consuming 4...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br><span class="line">[PRODUCER] Producing 5...</span><br><span class="line">[CONSUMER] Consuming 5...</span><br><span class="line">[PRODUCER] Consumer return: 200 OK</span><br></pre></td></tr></table></figure></p><p>注意到consumer函数是一个generator，把一个consumer传入produce后：</p><ol><li><p>首先调用c.send(None)启动生成器；</p></li><li><p>然后，一旦生产了东西，通过c.send(n)切换到consumer执行；</p></li><li><p>consumer通过yield拿到消息，处理，又通过yield把结果传回；</p></li><li><p>produce拿到consumer处理的结果，继续生产下一条消息；</p></li><li><p>produce决定不生产了，通过c.close()关闭consumer，整个过程结束。</p></li></ol><p>整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。</p><p>最后套用Donald Knuth的一句话总结协程的特点：</p><p>“子程序就是协程的一种特例。”</p><hr><h2 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h2><p>asyncio是Python 3.4版本引入的标准库，直接内置了对异步IO的支持。</p><p>asyncio的编程模型就是一个消息循环。我们从asyncio模块中直接获取一个EventLoop的引用，然后把需要执行的协程扔到EventLoop中执行，就实现了异步IO。</p><p>用asyncio实现Hello world代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">@asyncio.coroutine</span><br><span class="line">def hello():</span><br><span class="line">    print(&quot;Hello world!&quot;)</span><br><span class="line">    # 异步调用asyncio.sleep(1):</span><br><span class="line">    r = yield from asyncio.sleep(1)</span><br><span class="line">    print(&quot;Hello again!&quot;)</span><br><span class="line"></span><br><span class="line"># 获取EventLoop:</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"># 执行coroutine</span><br><span class="line">loop.run_until_complete(hello())</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure></p><p>@asyncio.coroutine把一个generator标记为coroutine类型，然后，我们就把这个coroutine扔到EventLoop中执行。</p><p>hello()会首先打印出Hello world!，然后，yield from语法可以让我们方便地调用另一个generator。由于asyncio.sleep()也是一个coroutine，所以线程不会等待asyncio.sleep()，而是直接中断并执行下一个消息循环。当asyncio.sleep()返回时，线程就可以从yield from拿到返回值（此处是None），然后接着执行下一行语句。</p><p>把asyncio.sleep(1)看成是一个耗时1秒的IO操作，在此期间，主线程并未等待，而是去执行EventLoop中其他可以执行的coroutine了，因此可以实现并发执行。</p><p>我们用Task封装两个coroutine试试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">@asyncio.coroutine</span><br><span class="line">def hello():</span><br><span class="line">    print(&apos;Hello world! (%s)&apos; % threading.currentThread())</span><br><span class="line">    yield from asyncio.sleep(1)</span><br><span class="line">    print(&apos;Hello again! (%s)&apos; % threading.currentThread())</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">tasks = [hello(), hello()]</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure></p><p>观察执行过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hello world! (&lt;_MainThread(MainThread, started 140735195337472)&gt;)</span><br><span class="line">Hello world! (&lt;_MainThread(MainThread, started 140735195337472)&gt;)</span><br><span class="line">(暂停约1秒)</span><br><span class="line">Hello again! (&lt;_MainThread(MainThread, started 140735195337472)&gt;)</span><br><span class="line">Hello again! (&lt;_MainThread(MainThread, started 140735195337472)&gt;)</span><br></pre></td></tr></table></figure></p><p>由打印的当前线程名称可以看出，两个coroutine是由同一个线程并发执行的。</p><p>如果把asyncio.sleep()换成真正的IO操作，则多个coroutine就可以由一个线程并发执行。</p><p>我们用asyncio的异步网络连接来获取sina、sohu和163的网站首页：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">@asyncio.coroutine</span><br><span class="line">def wget(host):</span><br><span class="line">    print(&apos;wget %s...&apos; % host)</span><br><span class="line">    connect = asyncio.open_connection(host, 80)</span><br><span class="line">    reader, writer = yield from connect</span><br><span class="line">    header = &apos;GET / HTTP/1.0\r\nHost: %s\r\n\r\n&apos; % host</span><br><span class="line">    writer.write(header.encode(&apos;utf-8&apos;))</span><br><span class="line">    yield from writer.drain()</span><br><span class="line">    while True:</span><br><span class="line">        line = yield from reader.readline()</span><br><span class="line">        if line == b&apos;\r\n&apos;:</span><br><span class="line">            break</span><br><span class="line">        print(&apos;%s header &gt; %s&apos; % (host, line.decode(&apos;utf-8&apos;).rstrip()))</span><br><span class="line">    # Ignore the body, close the socket</span><br><span class="line">    writer.close()</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">tasks = [wget(host) for host in [&apos;www.sina.com.cn&apos;, &apos;www.sohu.com&apos;, &apos;www.163.com&apos;]]</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">wget www.sohu.com...</span><br><span class="line">wget www.sina.com.cn...</span><br><span class="line">wget www.163.com...</span><br><span class="line">(等待一段时间)</span><br><span class="line">(打印出sohu的header)</span><br><span class="line">www.sohu.com header &gt; HTTP/1.1 200 OK</span><br><span class="line">www.sohu.com header &gt; Content-Type: text/html</span><br><span class="line">...</span><br><span class="line">(打印出sina的header)</span><br><span class="line">www.sina.com.cn header &gt; HTTP/1.1 200 OK</span><br><span class="line">www.sina.com.cn header &gt; Date: Wed, 20 May 2015 04:56:33 GMT</span><br><span class="line">...</span><br><span class="line">(打印出163的header)</span><br><span class="line">www.163.com header &gt; HTTP/1.0 302 Moved Temporarily</span><br><span class="line">www.163.com header &gt; Server: Cdn Cache Server V2.0</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>可见3个连接由一个线程通过coroutine并发完成。</p><p><strong>小结</strong><br>asyncio提供了完善的异步IO支持；</p><p>异步操作需要在coroutine中通过yield from完成；</p><p>多个coroutine可以封装成一组Task然后并发执行。</p><hr><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>用asyncio提供的@asyncio.coroutine可以把一个generator标记为coroutine类型，然后在coroutine内部用yield from调用另一个coroutine实现异步操作。</p><p>为了简化并更好地标识异步IO，从Python 3.5开始引入了新的语法async和await，可以让coroutine的代码更简洁易读。</p><p>请注意，async和await是针对coroutine的新语法，要使用新的语法，只需要做两步简单的替换：</p><ol><li><p>把@asyncio.coroutine替换为async；</p></li><li><p>把yield from替换为await。</p></li></ol><p>让我们对比一下上一节的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@asyncio.coroutine</span><br><span class="line">def hello():</span><br><span class="line">    print(&quot;Hello world!&quot;)</span><br><span class="line">    r = yield from asyncio.sleep(1)</span><br><span class="line">    print(&quot;Hello again!&quot;)</span><br></pre></td></tr></table></figure></p><p>用新语法重新编写如下：</p><p>async def hello():<br>    print(“Hello world!”)<br>    r = await asyncio.sleep(1)<br>    print(“Hello again!”)<br>剩下的代码保持不变。</p><p><strong>小结</strong><br>Python从3.5版本开始为asyncio提供了async和await的新语法；</p><p>注意新语法只能用在Python 3.5以及后续版本，如果使用3.4版本，则仍需使用上一节的方案。</p><hr><h2 id="aiohttp"><a href="#aiohttp" class="headerlink" title="aiohttp"></a>aiohttp</h2><p>asyncio可以实现单线程并发IO操作。如果仅用在客户端，发挥的威力不大。如果把asyncio用在服务器端，例如Web服务器，由于HTTP连接就是IO操作，因此可以用单线程+coroutine实现多用户的高并发支持。</p><p>asyncio实现了TCP、UDP、SSL等协议，aiohttp则是基于asyncio实现的HTTP框架。</p><p>先安装aiohttp：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install aiohttp</span><br></pre></td></tr></table></figure></p><p>然后编写一个HTTP服务器，分别处理以下URL：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/ - 首页返回b&apos;&lt;h1&gt;Index&lt;/h1&gt;&apos;；</span><br><span class="line"></span><br><span class="line">/hello/&#123;name&#125; - 根据URL参数返回文本hello, %s!。</span><br></pre></td></tr></table></figure></p><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">from aiohttp import web</span><br><span class="line"></span><br><span class="line">async def index(request):</span><br><span class="line">    await asyncio.sleep(0.5)</span><br><span class="line">    return web.Response(body=b&apos;&lt;h1&gt;Index&lt;/h1&gt;&apos;)</span><br><span class="line"></span><br><span class="line">async def hello(request):</span><br><span class="line">    await asyncio.sleep(0.5)</span><br><span class="line">    text = &apos;&lt;h1&gt;hello, %s!&lt;/h1&gt;&apos; % request.match_info[&apos;name&apos;]</span><br><span class="line">    return web.Response(body=text.encode(&apos;utf-8&apos;))</span><br><span class="line"></span><br><span class="line">async def init(loop):</span><br><span class="line">    app = web.Application(loop=loop)</span><br><span class="line">    app.router.add_route(&apos;GET&apos;, &apos;/&apos;, index)</span><br><span class="line">    app.router.add_route(&apos;GET&apos;, &apos;/hello/&#123;name&#125;&apos;, hello)</span><br><span class="line">    srv = await loop.create_server(app.make_handler(), &apos;127.0.0.1&apos;, 8000)</span><br><span class="line">    print(&apos;Server started at http://127.0.0.1:8000...&apos;)</span><br><span class="line">    return srv</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(init(loop))</span><br><span class="line">loop.run_forever()</span><br></pre></td></tr></table></figure></p><p>注意aiohttp的初始化函数init()也是一个coroutine，loop.create_server()则利用asyncio创建TCP服务。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在IO编程一节中，我们已经知道，CPU的速度远远快于磁盘、网络等IO。在一个线程中，CPU执行代码的速度极快，然而，一旦遇到IO操作，如读写文件、发送网络数据时，就需要等待IO操作完成，才能继续进行下一步操作。这种情况称为同步IO。&lt;/p&gt;
&lt;p&gt;在IO操作的过程中，当前线程被挂起，而其他需要CPU执行的代码就无法被当前线程执行了。&lt;/p&gt;
&lt;p&gt;因为一个IO操作就阻塞了当前线程，导致其他代码无法执行，所以我们必须使用多线程或者多进程来并发执行代码，为多个用户服务。每个用户都会分配一个线程，如果遇到IO导致线程被挂起，其他用户的线程不受影响。&lt;/p&gt;
&lt;p&gt;多线程和多进程的模型虽然解决了并发问题，但是系统不能无上限地增加线程。由于系统切换线程的开销也很大，所以，一旦线程数量过多，CPU的时间就花在线程切换上了，真正运行代码的时间就少了，结果导致性能严重下降。&lt;/p&gt;
&lt;p&gt;由于我们要解决的问题是CPU高速执行能力和IO设备的龟速严重不匹配，多线程和多进程只是解决这一问题的一种方法。&lt;/p&gt;
&lt;p&gt;另一种解决IO问题的方法是异步IO。当代码需要执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了。一段时间后，当IO返回结果时，再通知CPU进行处理。&lt;/p&gt;
&lt;p&gt;可以想象如果按普通顺序写出的代码实际上是没法完成异步IO的：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;do_some_code()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;f = open(&amp;apos;/path/to/file&amp;apos;, &amp;apos;r&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;r = f.read() # &amp;lt;== 线程停在此处等待IO操作结果&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# IO操作完成后线程才能继续执行:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;do_some_code(r)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;所以，同步IO模型的代码是无法实现异步IO模型的。&lt;/p&gt;
&lt;p&gt;异步IO模型需要一个消息循环，在消息循环中，主线程不断地重复“读取消息-处理消息”这一过程：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;loop = get_event_loop()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;while True:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    event = loop.get_event()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    process_event(event)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;消息模型其实早在应用在桌面应用程序中了。一个GUI程序的主线程就负责不停地读取消息并处理消息。所有的键盘、鼠标等消息都被发送到GUI程序的消息队列中，然后由GUI程序的主线程处理。&lt;/p&gt;
&lt;p&gt;由于GUI线程处理键盘、鼠标等消息的速度非常快，所以用户感觉不到延迟。某些时候，GUI线程在一个消息处理的过程中遇到问题导致一次消息处理时间过长，此时，用户会感觉到整个GUI程序停止响应了，敲键盘、点鼠标都没有反应。这种情况说明在消息模型中，处理一个消息必须非常迅速，否则，主线程将无法及时处理消息队列中的其他消息，导致程序看上去停止响应。&lt;/p&gt;
&lt;p&gt;消息模型是如何解决同步IO必须等待IO操作这一问题的呢？当遇到IO操作时，代码只负责发出IO请求，不等待IO结果，然后直接结束本轮消息处理，进入下一轮消息处理过程。当IO操作完成后，将收到一条“IO完成”的消息，处理该消息时就可以直接获取IO操作结果。&lt;/p&gt;
&lt;p&gt;在“发出IO请求”到收到“IO完成”的这段时间里，同步IO模型下，主线程只能挂起，但异步IO模型下，主线程并没有休息，而是在消息循环中继续处理其他消息。这样，在异步IO模型下，一个线程就可以同时处理多个IO请求，并且没有切换线程的操作。对于大多数IO密集型的应用程序，使用异步IO将大大提升系统的多任务处理能力。&lt;/p&gt;
    
    </summary>
    
      <category term="编程相关" scheme="https://paradoxallen.github.io/categories/%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="python" scheme="https://paradoxallen.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python访问数据库</title>
    <link href="https://paradoxallen.github.io/55836/"/>
    <id>https://paradoxallen.github.io/55836/</id>
    <published>2017-12-01T16:00:00.000Z</published>
    <updated>2018-08-03T14:12:01.851Z</updated>
    
    <content type="html"><![CDATA[<p>程序运行的时候，数据都是在内存中的。当程序终止的时候，通常都需要将数据保存到磁盘上，无论是保存到本地磁盘，还是通过网络保存到服务器上，最终都会将数据写入磁盘文件。</p><p>而如何定义数据的存储格式就是一个大问题。如果我们自己来定义存储格式，比如保存一个班级所有学生的成绩单：</p><p>名字    成绩<br>Michael    99<br>Bob        85<br>Bart    59<br>Lisa    87<br>你可以用一个文本文件保存，一行保存一个学生，用,隔开：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Michael,99</span><br><span class="line">Bob,85</span><br><span class="line">Bart,59</span><br><span class="line">Lisa,87</span><br></pre></td></tr></table></figure></p><p>你还可以用JSON格式保存，也是文本文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;&quot;name&quot;:&quot;Michael&quot;,&quot;score&quot;:99&#125;,</span><br><span class="line">    &#123;&quot;name&quot;:&quot;Bob&quot;,&quot;score&quot;:85&#125;,</span><br><span class="line">    &#123;&quot;name&quot;:&quot;Bart&quot;,&quot;score&quot;:59&#125;,</span><br><span class="line">    &#123;&quot;name&quot;:&quot;Lisa&quot;,&quot;score&quot;:87&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>你还可以定义各种保存格式，但是问题来了：</p><p>存储和读取需要自己实现，JSON还是标准，自己定义的格式就各式各样了；</p><p>不能做快速查询，只有把数据全部读到内存中才能自己遍历，但有时候数据的大小远远超过了内存（比如蓝光电影，40GB的数据），根本无法全部读入内存。</p><p>为了便于程序保存和读取数据，而且，能直接通过条件快速查询到指定的数据，就出现了数据库（Database）这种专门用于集中存储和查询的软件。</p><p>数据库软件诞生的历史非常久远，早在1950年数据库就诞生了。经历了网状数据库，层次数据库，我们现在广泛使用的关系数据库是20世纪70年代基于关系模型的基础上诞生的。</p><p>关系模型有一套复杂的数学理论，但是从概念上是十分容易理解的。举个学校的例子：</p><p>假设某个XX省YY市ZZ县第一实验小学有3个年级，要表示出这3个年级，可以在Excel中用一个表格画出来</p><p>每个年级又有若干个班级，要把所有班级表示出来，可以在Excel中再画一个表格</p><p>这两个表格有个映射关系，就是根据Grade_ID可以在班级表中查找到对应的所有班级</p><p>也就是Grade表的每一行对应Class表的多行，在关系数据库中，这种基于表（Table）的一对多的关系就是关系数据库的基础。</p><p>根据某个年级的ID就可以查找所有班级的行，这种查询语句在关系数据库中称为SQL语句，可以写成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM classes WHERE grade_id = &apos;1&apos;;</span><br></pre></td></tr></table></figure></p><p>结果也是一个表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">grade_id | class_id | name</span><br><span class="line"></span><br><span class="line">1        | 11       | 一年级一班</span><br><span class="line"></span><br><span class="line">1        | 12       | 一年级二班</span><br><span class="line"></span><br><span class="line">1        | 13       | 一年级三班</span><br></pre></td></tr></table></figure><p>类似的，Class表的一行记录又可以关联到Student表的多行记录</p><h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><p>也许还听说过NoSQL数据库，很多NoSQL宣传其速度和规模远远超过关系数据库，所以很多同学觉得有了NoSQL是否就不需要SQL了呢？千万不要被忽悠了，连SQL都不明白怎么可能搞明白NoSQL呢？</p><h3 id="数据库类别"><a href="#数据库类别" class="headerlink" title="数据库类别"></a>数据库类别</h3><p>既然我们要使用关系数据库，就必须选择一个关系数据库。目前广泛使用的关系数据库也就这么几种：</p><p>付费的商用数据库：</p><p>Oracle，典型的高富帅；</p><p>SQL Server，微软自家产品，Windows定制专款；</p><p>DB2，IBM的产品，听起来挺高端；</p><p>Sybase，曾经跟微软是好基友，后来关系破裂，现在家境惨淡。</p><p>这些数据库都是不开源而且付费的，最大的好处是花了钱出了问题可以找厂家解决，不过在Web的世界里，常常需要部署成千上万的数据库服务器，当然不能把大把大把的银子扔给厂家，所以，无论是Google、Facebook，还是国内的BAT，无一例外都选择了免费的开源数据库：</p><p>MySQL，大家都在用，一般错不了；</p><p>PostgreSQL，学术气息有点重，其实挺不错，但知名度没有MySQL高；</p><p>sqlite，嵌入式数据库，适合桌面和移动应用。</p><p>作为Python开发工程师，选择哪个免费数据库呢？当然是MySQL。因为MySQL普及率最高，出了错，可以很容易找到解决方法。而且，围绕MySQL有一大堆监控和运维的工具，安装和使用很方便。</p><p>从MySQL官方网站下载并安装MySQL Community Server 5.6，这个版本是免费的，其他高级版本是要收钱的。</p><a id="more"></a><hr><h2 id="使用SQLite"><a href="#使用SQLite" class="headerlink" title="使用SQLite"></a>使用SQLite</h2><p>SQLite是一种嵌入式数据库，它的数据库就是一个文件。由于SQLite本身是C写的，而且体积很小，所以，经常被集成到各种应用程序中，甚至在iOS和Android的App中都可以集成。</p><p>Python就内置了SQLite3，所以，在Python中使用SQLite，不需要安装任何东西，直接使用。</p><p>在使用SQLite前，我们先要搞清楚几个概念：</p><p>表是数据库中存放关系数据的集合，一个数据库里面通常都包含多个表，比如学生的表，班级的表，学校的表，等等。表和表之间通过外键关联。</p><p>要操作关系数据库，首先需要连接到数据库，一个数据库连接称为Connection；</p><p>连接到数据库后，需要打开游标，称之为Cursor，通过Cursor执行SQL语句，然后，获得执行结果。</p><p>Python定义了一套操作数据库的API接口，任何数据库要连接到Python，只需要提供符合Python标准的数据库驱动即可。</p><p>由于SQLite的驱动内置在Python标准库中，所以可以直接来操作SQLite数据库。</p><p>在Python交互式命令行实践一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 导入SQLite驱动:</span><br><span class="line">&gt;&gt;&gt; import sqlite3</span><br><span class="line"># 连接到SQLite数据库</span><br><span class="line"># 数据库文件是test.db</span><br><span class="line"># 如果文件不存在，会自动在当前目录创建:</span><br><span class="line">&gt;&gt;&gt; conn = sqlite3.connect(&apos;test.db&apos;)</span><br><span class="line"># 创建一个Cursor:</span><br><span class="line">&gt;&gt;&gt; cursor = conn.cursor()</span><br><span class="line"># 执行一条SQL语句，创建user表:</span><br><span class="line">&gt;&gt;&gt; cursor.execute(&apos;create table user (id varchar(20) primary key, name varchar(20))&apos;)</span><br><span class="line">&lt;sqlite3.Cursor object at 0x10f8aa260&gt;</span><br><span class="line"># 继续执行一条SQL语句，插入一条记录:</span><br><span class="line">&gt;&gt;&gt; cursor.execute(&apos;insert into user (id, name) values (\&apos;1\&apos;, \&apos;Michael\&apos;)&apos;)</span><br><span class="line">&lt;sqlite3.Cursor object at 0x10f8aa260&gt;</span><br><span class="line"># 通过rowcount获得插入的行数:</span><br><span class="line">&gt;&gt;&gt; cursor.rowcount</span><br><span class="line">1</span><br><span class="line"># 关闭Cursor:</span><br><span class="line">&gt;&gt;&gt; cursor.close()</span><br><span class="line"># 提交事务:</span><br><span class="line">&gt;&gt;&gt; conn.commit()</span><br><span class="line"># 关闭Connection:</span><br><span class="line">&gt;&gt;&gt; conn.close()</span><br></pre></td></tr></table></figure></p><p>再试试查询记录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; conn = sqlite3.connect(&apos;test.db&apos;)</span><br><span class="line">&gt;&gt;&gt; cursor = conn.cursor()</span><br><span class="line"># 执行查询语句:</span><br><span class="line">&gt;&gt;&gt; cursor.execute(&apos;select * from user where id=?&apos;, (&apos;1&apos;,))</span><br><span class="line">&lt;sqlite3.Cursor object at 0x10f8aa340&gt;</span><br><span class="line"># 获得查询结果集:</span><br><span class="line">&gt;&gt;&gt; values = cursor.fetchall()</span><br><span class="line">&gt;&gt;&gt; values</span><br><span class="line">[(&apos;1&apos;, &apos;Michael&apos;)]</span><br><span class="line">&gt;&gt;&gt; cursor.close()</span><br><span class="line">&gt;&gt;&gt; conn.close()</span><br></pre></td></tr></table></figure></p><p>使用Python的DB-API时，只要搞清楚Connection和Cursor对象，打开后一定记得关闭，就可以放心地使用。</p><p>使用Cursor对象执行insert，update，delete语句时，执行结果由rowcount返回影响的行数，就可以拿到执行结果。</p><p>使用Cursor对象执行select语句时，通过featchall()可以拿到结果集。结果集是一个list，每个元素都是一个tuple，对应一行记录。</p><p>如果SQL语句带有参数，那么需要把参数按照位置传递给execute()方法，有几个?占位符就必须对应几个参数，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cursor.execute(&apos;select * from user where name=? and pwd=?&apos;, (&apos;abc&apos;, &apos;password&apos;))</span><br></pre></td></tr></table></figure></p><p>SQLite支持常见的标准SQL语句以及几种常见的数据类型。具体文档请参阅SQLite官方网站。</p><p><strong>小结</strong><br>在Python中操作数据库时，要先导入数据库对应的驱动，然后，通过Connection对象和Cursor对象操作数据。</p><p>要确保打开的Connection对象和Cursor对象都正确地被关闭，否则，资源就会泄露。</p><p>如何才能确保出错的情况下也关闭掉Connection对象和Cursor对象呢？请回忆try:…except:…finally:…的用法。</p><hr><h2 id="使用MySQL"><a href="#使用MySQL" class="headerlink" title="使用MySQL"></a>使用MySQL</h2><p>MySQL是Web世界中使用最广泛的数据库服务器。SQLite的特点是轻量级、可嵌入，但不能承受高并发访问，适合桌面和移动应用。而MySQL是为服务器端设计的数据库，能承受高并发访问，同时占用的内存也远远大于SQLite。</p><p>此外，MySQL内部有多种数据库引擎，最常用的引擎是支持数据库事务的InnoDB。</p><h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><p>可以直接从MySQL官方网站下载最新的Community Server 5.6.x版本。MySQL是跨平台的，选择对应的平台下载安装文件，安装即可。</p><p>安装时，MySQL会提示输入root用户的口令，请务必记清楚。如果怕记不住，就把口令设置为password。</p><p>在Windows上，安装时请选择UTF-8编码，以便正确地处理中文。</p><p>在Mac或Linux上，需要编辑MySQL的配置文件，把数据库默认的编码全部改为UTF-8。MySQL的配置文件默认存放在/etc/my.cnf或者/etc/mysql/my.cnf：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set = utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">default-storage-engine = INNODB</span><br><span class="line">character-set-server = utf8</span><br><span class="line">collation-server = utf8_general_ci</span><br></pre></td></tr></table></figure></p><p>重启MySQL后，可以通过MySQL的客户端命令行检查编码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -u root -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;%char%&apos;;</span><br><span class="line">+--------------------------+--------------------------------------------------------+</span><br><span class="line">| Variable_name            | Value                                                  |</span><br><span class="line">+--------------------------+--------------------------------------------------------+</span><br><span class="line">| character_set_client     | utf8                                                   |</span><br><span class="line">| character_set_connection | utf8                                                   |</span><br><span class="line">| character_set_database   | utf8                                                   |</span><br><span class="line">| character_set_filesystem | binary                                                 |</span><br><span class="line">| character_set_results    | utf8                                                   |</span><br><span class="line">| character_set_server     | utf8                                                   |</span><br><span class="line">| character_set_system     | utf8                                                   |</span><br><span class="line">| character_sets_dir       | /usr/local/mysql-5.1.65-osx10.6-x86_64/share/charsets/ |</span><br><span class="line">+--------------------------+--------------------------------------------------------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>看到utf8字样就表示编码设置正确。</p><p>注：如果MySQL的版本≥5.5.3，可以把编码设置为utf8mb4，utf8mb4和utf8完全兼容，但它支持最新的Unicode标准，可以显示emoji字符。</p><h3 id="安装MySQL驱动"><a href="#安装MySQL驱动" class="headerlink" title="安装MySQL驱动"></a>安装MySQL驱动</h3><p>由于MySQL服务器以独立的进程运行，并通过网络对外服务，所以，需要支持Python的MySQL驱动来连接到MySQL服务器。MySQL官方提供了mysql-connector-python驱动，但是安装的时候需要给pip命令加上参数–allow-external：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install mysql-connector-python --allow-external mysql-connector-python</span><br></pre></td></tr></table></figure></p><p>如果上面的命令安装失败，可以试试另一个驱动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install mysql-connector</span><br></pre></td></tr></table></figure></p><p>我们演示如何连接到MySQL服务器的test数据库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 导入MySQL驱动:</span><br><span class="line">&gt;&gt;&gt; import mysql.connector</span><br><span class="line"># 注意把password设为你的root口令:</span><br><span class="line">&gt;&gt;&gt; conn = mysql.connector.connect(user=&apos;root&apos;, password=&apos;password&apos;, database=&apos;test&apos;)</span><br><span class="line">&gt;&gt;&gt; cursor = conn.cursor()</span><br><span class="line"># 创建user表:</span><br><span class="line">&gt;&gt;&gt; cursor.execute(&apos;create table user (id varchar(20) primary key, name varchar(20))&apos;)</span><br><span class="line"># 插入一行记录，注意MySQL的占位符是%s:</span><br><span class="line">&gt;&gt;&gt; cursor.execute(&apos;insert into user (id, name) values (%s, %s)&apos;, [&apos;1&apos;, &apos;Michael&apos;])</span><br><span class="line">&gt;&gt;&gt; cursor.rowcount</span><br><span class="line">1</span><br><span class="line"># 提交事务:</span><br><span class="line">&gt;&gt;&gt; conn.commit()</span><br><span class="line">&gt;&gt;&gt; cursor.close()</span><br><span class="line"># 运行查询:</span><br><span class="line">&gt;&gt;&gt; cursor = conn.cursor()</span><br><span class="line">&gt;&gt;&gt; cursor.execute(&apos;select * from user where id = %s&apos;, (&apos;1&apos;,))</span><br><span class="line">&gt;&gt;&gt; values = cursor.fetchall()</span><br><span class="line">&gt;&gt;&gt; values</span><br><span class="line">[(&apos;1&apos;, &apos;Michael&apos;)]</span><br><span class="line"># 关闭Cursor和Connection:</span><br><span class="line">&gt;&gt;&gt; cursor.close()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; conn.close()</span><br></pre></td></tr></table></figure></p><p>由于Python的DB-API定义都是通用的，所以，操作MySQL的数据库代码和SQLite类似。</p><p><strong>小结</strong><br>执行INSERT等操作后要调用commit()提交事务；</p><p>MySQL的SQL占位符是%s。</p><hr><h2 id="使用SQLAlchemy"><a href="#使用SQLAlchemy" class="headerlink" title="使用SQLAlchemy"></a>使用SQLAlchemy</h2><p>数据库表是一个二维表，包含多行多列。把一个表的内容用Python的数据结构表示出来的话，可以用一个list表示多行，list的每一个元素是tuple，表示一行记录，比如，包含id和name的user表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    (&apos;1&apos;, &apos;Michael&apos;),</span><br><span class="line">    (&apos;2&apos;, &apos;Bob&apos;),</span><br><span class="line">    (&apos;3&apos;, &apos;Adam&apos;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>Python的DB-API返回的数据结构就是像上面这样表示的。</p><p>但是用tuple表示一行很难看出表的结构。如果把一个tuple用class实例来表示，就可以更容易地看出表的结构来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class User(object):</span><br><span class="line">    def __init__(self, id, name):</span><br><span class="line">        self.id = id</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    User(&apos;1&apos;, &apos;Michael&apos;),</span><br><span class="line">    User(&apos;2&apos;, &apos;Bob&apos;),</span><br><span class="line">    User(&apos;3&apos;, &apos;Adam&apos;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>这就是传说中的ORM技术：Object-Relational Mapping，把关系数据库的表结构映射到对象上。是不是很简单？</p><p>但是由谁来做这个转换呢？所以ORM框架应运而生。</p><p>在Python中，最有名的ORM框架是SQLAlchemy。我们来看看SQLAlchemy的用法。</p><p>首先通过pip安装SQLAlchemy：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install sqlalchemy</span><br></pre></td></tr></table></figure></p><p>然后，利用上次我们在MySQL的test数据库中创建的user表，用SQLAlchemy来试试：</p><p>第一步，导入SQLAlchemy，并初始化DBSession：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 导入:</span><br><span class="line">from sqlalchemy import Column, String, create_engine</span><br><span class="line">from sqlalchemy.orm import sessionmaker</span><br><span class="line">from sqlalchemy.ext.declarative import declarative_base</span><br><span class="line"></span><br><span class="line"># 创建对象的基类:</span><br><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line"># 定义User对象:</span><br><span class="line">class User(Base):</span><br><span class="line">    # 表的名字:</span><br><span class="line">    __tablename__ = &apos;user&apos;</span><br><span class="line"></span><br><span class="line">    # 表的结构:</span><br><span class="line">    id = Column(String(20), primary_key=True)</span><br><span class="line">    name = Column(String(20))</span><br><span class="line"></span><br><span class="line"># 初始化数据库连接:</span><br><span class="line">engine = create_engine(&apos;mysql+mysqlconnector://root:password@localhost:3306/test&apos;)</span><br><span class="line"># 创建DBSession类型:</span><br><span class="line">DBSession = sessionmaker(bind=engine)</span><br></pre></td></tr></table></figure></p><p>以上代码完成SQLAlchemy的初始化和具体每个表的class定义。如果有多个表，就继续定义其他class，例如School：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class School(Base):</span><br><span class="line">    __tablename__ = &apos;school&apos;</span><br><span class="line">    id = ...</span><br><span class="line">    name = ...</span><br></pre></td></tr></table></figure></p><p>create_engine()用来初始化数据库连接。SQLAlchemy用一个字符串表示连接信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;数据库类型+数据库驱动名称://用户名:口令@机器地址:端口号/数据库名&apos;</span><br></pre></td></tr></table></figure></p><p>你只需要根据需要替换掉用户名、口令等信息即可。</p><p>下面，我们看看如何向数据库表中添加一行记录。</p><p>由于有了ORM，我们向数据库表中添加一行记录，可以视为添加一个User对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 创建session对象:</span><br><span class="line">session = DBSession()</span><br><span class="line"># 创建新User对象:</span><br><span class="line">new_user = User(id=&apos;5&apos;, name=&apos;Bob&apos;)</span><br><span class="line"># 添加到session:</span><br><span class="line">session.add(new_user)</span><br><span class="line"># 提交即保存到数据库:</span><br><span class="line">session.commit()</span><br><span class="line"># 关闭session:</span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure></p><p>可见，关键是获取session，然后把对象添加到session，最后提交并关闭。DBSession对象可视为当前数据库连接。</p><p>如何从数据库表中查询数据呢？有了ORM，查询出来的可以不再是tuple，而是User对象。SQLAlchemy提供的查询接口如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建Session:</span><br><span class="line">session = DBSession()</span><br><span class="line"># 创建Query查询，filter是where条件，最后调用one()返回唯一行，如果调用all()则返回所有行:</span><br><span class="line">user = session.query(User).filter(User.id==&apos;5&apos;).one()</span><br><span class="line"># 打印类型和对象的name属性:</span><br><span class="line">print(&apos;type:&apos;, type(user))</span><br><span class="line">print(&apos;name:&apos;, user.name)</span><br><span class="line"># 关闭Session:</span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure></p><p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type: &lt;class &apos;__main__.User&apos;&gt;</span><br><span class="line">name: Bob</span><br></pre></td></tr></table></figure></p><p>可见，ORM就是把数据库表的行与相应的对象建立关联，互相转换。</p><p>由于关系数据库的多个表还可以用外键实现一对多、多对多等关联，相应地，ORM框架也可以提供两个对象之间的一对多、多对多等功能。</p><p>例如，如果一个User拥有多个Book，就可以定义一对多关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class User(Base):</span><br><span class="line">    __tablename__ = &apos;user&apos;</span><br><span class="line"></span><br><span class="line">    id = Column(String(20), primary_key=True)</span><br><span class="line">    name = Column(String(20))</span><br><span class="line">    # 一对多:</span><br><span class="line">    books = relationship(&apos;Book&apos;)</span><br><span class="line"></span><br><span class="line">class Book(Base):</span><br><span class="line">    __tablename__ = &apos;book&apos;</span><br><span class="line"></span><br><span class="line">    id = Column(String(20), primary_key=True)</span><br><span class="line">    name = Column(String(20))</span><br><span class="line">    # “多”的一方的book表是通过外键关联到user表的:</span><br><span class="line">    user_id = Column(String(20), ForeignKey(&apos;user.id&apos;))</span><br></pre></td></tr></table></figure></p><p>当我们查询一个User对象时，该对象的books属性将返回一个包含若干个Book对象的list。</p><p><strong>小结</strong><br>ORM框架的作用就是把数据库表的一行记录与一个对象互相做自动转换。</p><p>正确使用ORM的前提是了解关系数据库的原理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;程序运行的时候，数据都是在内存中的。当程序终止的时候，通常都需要将数据保存到磁盘上，无论是保存到本地磁盘，还是通过网络保存到服务器上，最终都会将数据写入磁盘文件。&lt;/p&gt;
&lt;p&gt;而如何定义数据的存储格式就是一个大问题。如果我们自己来定义存储格式，比如保存一个班级所有学生的成绩单：&lt;/p&gt;
&lt;p&gt;名字    成绩&lt;br&gt;Michael    99&lt;br&gt;Bob        85&lt;br&gt;Bart    59&lt;br&gt;Lisa    87&lt;br&gt;你可以用一个文本文件保存，一行保存一个学生，用,隔开：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Michael,99&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Bob,85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Bart,59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Lisa,87&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;你还可以用JSON格式保存，也是文本文件：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&amp;quot;name&amp;quot;:&amp;quot;Michael&amp;quot;,&amp;quot;score&amp;quot;:99&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&amp;quot;name&amp;quot;:&amp;quot;Bob&amp;quot;,&amp;quot;score&amp;quot;:85&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&amp;quot;name&amp;quot;:&amp;quot;Bart&amp;quot;,&amp;quot;score&amp;quot;:59&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&amp;quot;name&amp;quot;:&amp;quot;Lisa&amp;quot;,&amp;quot;score&amp;quot;:87&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;你还可以定义各种保存格式，但是问题来了：&lt;/p&gt;
&lt;p&gt;存储和读取需要自己实现，JSON还是标准，自己定义的格式就各式各样了；&lt;/p&gt;
&lt;p&gt;不能做快速查询，只有把数据全部读到内存中才能自己遍历，但有时候数据的大小远远超过了内存（比如蓝光电影，40GB的数据），根本无法全部读入内存。&lt;/p&gt;
&lt;p&gt;为了便于程序保存和读取数据，而且，能直接通过条件快速查询到指定的数据，就出现了数据库（Database）这种专门用于集中存储和查询的软件。&lt;/p&gt;
&lt;p&gt;数据库软件诞生的历史非常久远，早在1950年数据库就诞生了。经历了网状数据库，层次数据库，我们现在广泛使用的关系数据库是20世纪70年代基于关系模型的基础上诞生的。&lt;/p&gt;
&lt;p&gt;关系模型有一套复杂的数学理论，但是从概念上是十分容易理解的。举个学校的例子：&lt;/p&gt;
&lt;p&gt;假设某个XX省YY市ZZ县第一实验小学有3个年级，要表示出这3个年级，可以在Excel中用一个表格画出来&lt;/p&gt;
&lt;p&gt;每个年级又有若干个班级，要把所有班级表示出来，可以在Excel中再画一个表格&lt;/p&gt;
&lt;p&gt;这两个表格有个映射关系，就是根据Grade_ID可以在班级表中查找到对应的所有班级&lt;/p&gt;
&lt;p&gt;也就是Grade表的每一行对应Class表的多行，在关系数据库中，这种基于表（Table）的一对多的关系就是关系数据库的基础。&lt;/p&gt;
&lt;p&gt;根据某个年级的ID就可以查找所有班级的行，这种查询语句在关系数据库中称为SQL语句，可以写成：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SELECT * FROM classes WHERE grade_id = &amp;apos;1&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;结果也是一个表：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;grade_id | class_id | name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1        | 11       | 一年级一班&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1        | 12       | 一年级二班&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1        | 13       | 一年级三班&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;类似的，Class表的一行记录又可以关联到Student表的多行记录&lt;/p&gt;
&lt;h3 id=&quot;NoSQL&quot;&gt;&lt;a href=&quot;#NoSQL&quot; class=&quot;headerlink&quot; title=&quot;NoSQL&quot;&gt;&lt;/a&gt;NoSQL&lt;/h3&gt;&lt;p&gt;也许还听说过NoSQL数据库，很多NoSQL宣传其速度和规模远远超过关系数据库，所以很多同学觉得有了NoSQL是否就不需要SQL了呢？千万不要被忽悠了，连SQL都不明白怎么可能搞明白NoSQL呢？&lt;/p&gt;
&lt;h3 id=&quot;数据库类别&quot;&gt;&lt;a href=&quot;#数据库类别&quot; class=&quot;headerlink&quot; title=&quot;数据库类别&quot;&gt;&lt;/a&gt;数据库类别&lt;/h3&gt;&lt;p&gt;既然我们要使用关系数据库，就必须选择一个关系数据库。目前广泛使用的关系数据库也就这么几种：&lt;/p&gt;
&lt;p&gt;付费的商用数据库：&lt;/p&gt;
&lt;p&gt;Oracle，典型的高富帅；&lt;/p&gt;
&lt;p&gt;SQL Server，微软自家产品，Windows定制专款；&lt;/p&gt;
&lt;p&gt;DB2，IBM的产品，听起来挺高端；&lt;/p&gt;
&lt;p&gt;Sybase，曾经跟微软是好基友，后来关系破裂，现在家境惨淡。&lt;/p&gt;
&lt;p&gt;这些数据库都是不开源而且付费的，最大的好处是花了钱出了问题可以找厂家解决，不过在Web的世界里，常常需要部署成千上万的数据库服务器，当然不能把大把大把的银子扔给厂家，所以，无论是Google、Facebook，还是国内的BAT，无一例外都选择了免费的开源数据库：&lt;/p&gt;
&lt;p&gt;MySQL，大家都在用，一般错不了；&lt;/p&gt;
&lt;p&gt;PostgreSQL，学术气息有点重，其实挺不错，但知名度没有MySQL高；&lt;/p&gt;
&lt;p&gt;sqlite，嵌入式数据库，适合桌面和移动应用。&lt;/p&gt;
&lt;p&gt;作为Python开发工程师，选择哪个免费数据库呢？当然是MySQL。因为MySQL普及率最高，出了错，可以很容易找到解决方法。而且，围绕MySQL有一大堆监控和运维的工具，安装和使用很方便。&lt;/p&gt;
&lt;p&gt;从MySQL官方网站下载并安装MySQL Community Server 5.6，这个版本是免费的，其他高级版本是要收钱的。&lt;/p&gt;
    
    </summary>
    
      <category term="编程相关" scheme="https://paradoxallen.github.io/categories/%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="python" scheme="https://paradoxallen.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python电子邮件</title>
    <link href="https://paradoxallen.github.io/53901/"/>
    <id>https://paradoxallen.github.io/53901/</id>
    <published>2017-11-27T16:00:00.000Z</published>
    <updated>2018-08-05T06:29:33.771Z</updated>
    
    <content type="html"><![CDATA[<p>Email的历史比Web还要久远，直到现在，Email也是互联网上应用非常广泛的服务。</p><p>几乎所有的编程语言都支持发送和接收电子邮件，但是，先等等，在我们开始编写代码之前，有必要搞清楚电子邮件是如何在互联网上运作的。</p><p>我们来看看传统邮件是如何运作的。假设你现在在北京，要给一个香港的朋友发一封信，怎么做呢？</p><p>首先你得写好信，装进信封，写上地址，贴上邮票，然后就近找个邮局，把信仍进去。</p><p>信件会从就近的小邮局转运到大邮局，再从大邮局往别的城市发，比如先发到天津，再走海运到达香港，也可能走京九线到香港，但是你不用关心具体路线，你只需要知道一件事，就是信件走得很慢，至少要几天时间。</p><p>信件到达香港的某个邮局，也不会直接送到朋友的家里，因为邮局的叔叔是很聪明的，他怕你的朋友不在家，一趟一趟地白跑，所以，信件会投递到你的朋友的邮箱里，邮箱可能在公寓的一层，或者家门口，直到你的朋友回家的时候检查邮箱，发现信件后，就可以取到邮件了。</p><p>电子邮件的流程基本上也是按上面的方式运作的，只不过速度不是按天算，而是按秒算。</p><p>现在我们回到电子邮件，假设我们自己的电子邮件地址是<a href="mailto:me@163.com" target="_blank" rel="noopener">me@163.com</a>，对方的电子邮件地址是<a href="mailto:friend@sina.com" target="_blank" rel="noopener">friend@sina.com</a>（注意地址都是虚构的哈），现在我们用Outlook或者Foxmail之类的软件写好邮件，填上对方的Email地址，点“发送”，电子邮件就发出去了。这些电子邮件软件被称为MUA：Mail User Agent——邮件用户代理。</p><p>Email从MUA发出去，不是直接到达对方电脑，而是发到MTA：Mail Transfer Agent——邮件传输代理，就是那些Email服务提供商，比如网易、新浪等等。由于我们自己的电子邮件是163.com，所以，Email首先被投递到网易提供的MTA，再由网易的MTA发到对方服务商，也就是新浪的MTA。这个过程中间可能还会经过别的MTA，但是我们不关心具体路线，我们只关心速度。</p><p>Email到达新浪的MTA后，由于对方使用的是@sina.com的邮箱，因此，新浪的MTA会把Email投递到邮件的最终目的地MDA：Mail Delivery Agent——邮件投递代理。Email到达MDA后，就静静地躺在新浪的某个服务器上，存放在某个文件或特殊的数据库里，我们将这个长期保存邮件的地方称之为电子邮箱。</p><p>同普通邮件类似，Email不会直接到达对方的电脑，因为对方电脑不一定开机，开机也不一定联网。对方要取到邮件，必须通过MUA从MDA上把邮件取到自己的电脑上。</p><p>所以，一封电子邮件的旅程就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发件人 -&gt; MUA -&gt; MTA -&gt; MTA -&gt; 若干个MTA -&gt; MDA &lt;- MUA &lt;- 收件人</span><br></pre></td></tr></table></figure></p><p>有了上述基本概念，要编写程序来发送和接收邮件，本质上就是：</p><ol><li><p>编写MUA把邮件发到MTA；</p></li><li><p>编写MUA从MDA上收邮件。</p></li></ol><p>发邮件时，MUA和MTA使用的协议就是<strong>SMTP</strong>：Simple Mail Transfer Protocol，后面的MTA到另一个MTA也是用SMTP协议。</p><p>收邮件时，MUA和MDA使用的协议有两种：<strong>POP</strong>：Post Office Protocol，目前版本是3，俗称POP3；<strong>IMAP</strong>：Internet Message Access Protocol，目前版本是4，优点是不但能取邮件，还可以直接操作MDA上存储的邮件，比如从收件箱移到垃圾箱，等等。</p><p>邮件客户端软件在发邮件时，会让你先配置SMTP服务器，也就是你要发到哪个MTA上。假设你正在使用163的邮箱，你就不能直接发到新浪的MTA上，因为它只服务新浪的用户，所以，你得填163提供的SMTP服务器地址：smtp.163.com，为了证明你是163的用户，SMTP服务器还要求你填写邮箱地址和邮箱口令，这样，MUA才能正常地把Email通过SMTP协议发送到MTA。</p><p>类似的，从MDA收邮件时，MDA服务器也要求验证你的邮箱口令，确保不会有人冒充你收取你的邮件，所以，Outlook之类的邮件客户端会要求你填写POP3或IMAP服务器地址、邮箱地址和口令，这样，MUA才能顺利地通过POP或IMAP协议从MDA取到邮件。</p><p>在使用Python收发邮件前，请先准备好至少两个电子邮件，如<a href="mailto:xxx@163.com" target="_blank" rel="noopener">xxx@163.com</a>，<a href="mailto:xxx@sina.com" target="_blank" rel="noopener">xxx@sina.com</a>，<a href="mailto:xxx@qq.com" target="_blank" rel="noopener">xxx@qq.com</a>等，注意两个邮箱不要用同一家邮件服务商。</p><p>最后特别注意，目前大多数邮件服务商都需要手动打开SMTP发信和POP收信的功能，否则只允许在网页登录</p><a id="more"></a><hr><h2 id="SMTP发送邮件"><a href="#SMTP发送邮件" class="headerlink" title="SMTP发送邮件"></a>SMTP发送邮件</h2><p>SMTP是发送邮件的协议，Python内置对SMTP的支持，可以发送纯文本邮件、HTML邮件以及带附件的邮件。</p><p>Python对SMTP支持有smtplib和email两个模块，email负责构造邮件，smtplib负责发送邮件。</p><p>首先，我们来构造一个最简单的纯文本邮件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from email.mime.text import MIMEText</span><br><span class="line">msg = MIMEText(&apos;hello, send by Python...&apos;, &apos;plain&apos;, &apos;utf-8&apos;)</span><br></pre></td></tr></table></figure></p><p>注意到构造MIMEText对象时，第一个参数就是邮件正文，第二个参数是MIME的subtype，传入’plain’表示纯文本，最终的MIME就是’text/plain’，最后一定要用utf-8编码保证多语言兼容性。</p><p>然后，通过SMTP发出去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 输入Email地址和口令:</span><br><span class="line">from_addr = input(&apos;From: &apos;)</span><br><span class="line">password = input(&apos;Password: &apos;)</span><br><span class="line"># 输入收件人地址:</span><br><span class="line">to_addr = input(&apos;To: &apos;)</span><br><span class="line"># 输入SMTP服务器地址:</span><br><span class="line">smtp_server = input(&apos;SMTP server: &apos;)</span><br><span class="line"></span><br><span class="line">import smtplib</span><br><span class="line">server = smtplib.SMTP(smtp_server, 25) # SMTP协议默认端口是25</span><br><span class="line">server.set_debuglevel(1)</span><br><span class="line">server.login(from_addr, password)</span><br><span class="line">server.sendmail(from_addr, [to_addr], msg.as_string())</span><br><span class="line">server.quit()</span><br></pre></td></tr></table></figure></p><p>我们用set_debuglevel(1)就可以打印出和SMTP服务器交互的所有信息。SMTP协议就是简单的文本命令和响应。login()方法用来登录SMTP服务器，sendmail()方法就是发邮件，由于可以一次发给多个人，所以传入一个list，邮件正文是一个str，as_string()把MIMEText对象变成str。</p><p>如果一切顺利，就可以在收件人信箱中收到我们刚发送的Email：</p><p>仔细观察，发现如下问题：</p><ol><li>邮件没有主题；</li><li>收件人的名字没有显示为友好的名字，比如Mr Green <a href="mailto:&#103;&#114;&#101;&#101;&#110;&#64;&#x65;&#120;&#x61;&#109;&#112;&#x6c;&#x65;&#46;&#99;&#x6f;&#x6d;" target="_blank" rel="noopener">&#103;&#114;&#101;&#101;&#110;&#64;&#x65;&#120;&#x61;&#109;&#112;&#x6c;&#x65;&#46;&#99;&#x6f;&#x6d;</a>；</li><li>明明收到了邮件，却提示不在收件人中。</li></ol><p>这是因为邮件主题、如何显示发件人、收件人等信息并不是通过SMTP协议发给MTA，而是包含在发给MTA的文本中的，所以，我们必须把From、To和Subject添加到MIMEText中，才是一封完整的邮件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from email import encoders</span><br><span class="line">from email.header import Header</span><br><span class="line">from email.mime.text import MIMEText</span><br><span class="line">from email.utils import parseaddr, formataddr</span><br><span class="line"></span><br><span class="line">import smtplib</span><br><span class="line"></span><br><span class="line">def _format_addr(s):</span><br><span class="line">    name, addr = parseaddr(s)</span><br><span class="line">    return formataddr((Header(name, &apos;utf-8&apos;).encode(), addr))</span><br><span class="line"></span><br><span class="line">from_addr = input(&apos;From: &apos;)</span><br><span class="line">password = input(&apos;Password: &apos;)</span><br><span class="line">to_addr = input(&apos;To: &apos;)</span><br><span class="line">smtp_server = input(&apos;SMTP server: &apos;)</span><br><span class="line"></span><br><span class="line">msg = MIMEText(&apos;hello, send by Python...&apos;, &apos;plain&apos;, &apos;utf-8&apos;)</span><br><span class="line">msg[&apos;From&apos;] = _format_addr(&apos;Python爱好者 &lt;%s&gt;&apos; % from_addr)</span><br><span class="line">msg[&apos;To&apos;] = _format_addr(&apos;管理员 &lt;%s&gt;&apos; % to_addr)</span><br><span class="line">msg[&apos;Subject&apos;] = Header(&apos;来自SMTP的问候……&apos;, &apos;utf-8&apos;).encode()</span><br><span class="line"></span><br><span class="line">server = smtplib.SMTP(smtp_server, 25)</span><br><span class="line">server.set_debuglevel(1)</span><br><span class="line">server.login(from_addr, password)</span><br><span class="line">server.sendmail(from_addr, [to_addr], msg.as_string())</span><br><span class="line">server.quit()</span><br></pre></td></tr></table></figure></p><p>我们编写了一个函数_format_addr()来格式化一个邮件地址。注意不能简单地传入name <a href="mailto:&#x61;&#x64;&#x64;&#114;&#x40;&#101;&#x78;&#97;&#x6d;&#x70;&#108;&#x65;&#46;&#99;&#111;&#x6d;" target="_blank" rel="noopener">&#x61;&#x64;&#x64;&#114;&#x40;&#101;&#x78;&#97;&#x6d;&#x70;&#108;&#x65;&#46;&#99;&#111;&#x6d;</a>，因为如果包含中文，需要通过Header对象进行编码。</p><p>msg[‘To’]接收的是字符串而不是list，如果有多个邮件地址，用,分隔即可。</p><p>再发送一遍邮件，就可以在收件人邮箱中看到正确的标题、发件人和收件人：</p><p>你看到的收件人的名字很可能不是我们传入的管理员，因为很多邮件服务商在显示邮件时，会把收件人名字自动替换为用户注册的名字，但是其他收件人名字的显示不受影响。</p><p>如果我们查看Email的原始内容，可以看到如下经过编码的邮件头：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">From: =?utf-8?b?UHl0aG9u54ix5aW96ICF?= &lt;xxxxxx@163.com&gt;</span><br><span class="line">To: =?utf-8?b?566h55CG5ZGY?= &lt;xxxxxx@qq.com&gt;</span><br><span class="line">Subject: =?utf-8?b?5p2l6IeqU01UUOeahOmXruWAmeKApuKApg==?=</span><br></pre></td></tr></table></figure></p><p>这就是经过Header对象编码的文本，包含utf-8编码信息和Base64编码的文本。如果我们自己来手动构造这样的编码文本，显然比较复杂。</p><h3 id="发送HTML邮件"><a href="#发送HTML邮件" class="headerlink" title="发送HTML邮件"></a>发送HTML邮件</h3><p>如果我们要发送HTML邮件，而不是普通的纯文本文件怎么办？方法很简单，在构造MIMEText对象时，把HTML字符串传进去，再把第二个参数由plain变为html就可以了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg = MIMEText(&apos;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&apos; +</span><br><span class="line">    &apos;&lt;p&gt;send by &lt;a href=&quot;http://www.python.org&quot;&gt;Python&lt;/a&gt;...&lt;/p&gt;&apos; +</span><br><span class="line">    &apos;&lt;/body&gt;&lt;/html&gt;&apos;, &apos;html&apos;, &apos;utf-8&apos;)</span><br></pre></td></tr></table></figure></p><p>再发送一遍邮件，你将看到以HTML显示的邮件：</p><h3 id="发送附件"><a href="#发送附件" class="headerlink" title="发送附件"></a>发送附件</h3><p>如果Email中要加上附件怎么办？带附件的邮件可以看做包含若干部分的邮件：文本和各个附件本身，所以，可以构造一个MIMEMultipart对象代表邮件本身，然后往里面加上一个MIMEText作为邮件正文，再继续往里面加上表示附件的MIMEBase对象即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 邮件对象:</span><br><span class="line">msg = MIMEMultipart()</span><br><span class="line">msg[&apos;From&apos;] = _format_addr(&apos;Python爱好者 &lt;%s&gt;&apos; % from_addr)</span><br><span class="line">msg[&apos;To&apos;] = _format_addr(&apos;管理员 &lt;%s&gt;&apos; % to_addr)</span><br><span class="line">msg[&apos;Subject&apos;] = Header(&apos;来自SMTP的问候……&apos;, &apos;utf-8&apos;).encode()</span><br><span class="line"></span><br><span class="line"># 邮件正文是MIMEText:</span><br><span class="line">msg.attach(MIMEText(&apos;send with file...&apos;, &apos;plain&apos;, &apos;utf-8&apos;))</span><br><span class="line"></span><br><span class="line"># 添加附件就是加上一个MIMEBase，从本地读取一个图片:</span><br><span class="line">with open(&apos;/Users/michael/Downloads/test.png&apos;, &apos;rb&apos;) as f:</span><br><span class="line">    # 设置附件的MIME和文件名，这里是png类型:</span><br><span class="line">    mime = MIMEBase(&apos;image&apos;, &apos;png&apos;, filename=&apos;test.png&apos;)</span><br><span class="line">    # 加上必要的头信息:</span><br><span class="line">    mime.add_header(&apos;Content-Disposition&apos;, &apos;attachment&apos;, filename=&apos;test.png&apos;)</span><br><span class="line">    mime.add_header(&apos;Content-ID&apos;, &apos;&lt;0&gt;&apos;)</span><br><span class="line">    mime.add_header(&apos;X-Attachment-Id&apos;, &apos;0&apos;)</span><br><span class="line">    # 把附件的内容读进来:</span><br><span class="line">    mime.set_payload(f.read())</span><br><span class="line">    # 用Base64编码:</span><br><span class="line">    encoders.encode_base64(mime)</span><br><span class="line">    # 添加到MIMEMultipart:</span><br><span class="line">    msg.attach(mime)</span><br></pre></td></tr></table></figure></p><p>然后，按正常发送流程把msg（注意类型已变为MIMEMultipart）发送出去，就可以收到如下带附件的邮件</p><h3 id="发送图片"><a href="#发送图片" class="headerlink" title="发送图片"></a>发送图片</h3><p>如果要把一个图片嵌入到邮件正文中怎么做？直接在HTML邮件中链接图片地址行不行？答案是，大部分邮件服务商都会自动屏蔽带有外链的图片，因为不知道这些链接是否指向恶意网站。</p><p>要把图片嵌入到邮件正文中，我们只需按照发送附件的方式，先把邮件作为附件添加进去，然后，在HTML中通过引用src=”cid:0”就可以把附件作为图片嵌入了。如果有多个图片，给它们依次编号，然后引用不同的cid:x即可。</p><p>把上面代码加入MIMEMultipart的MIMEText从plain改为html，然后在适当的位置引用图片：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg.attach(MIMEText(&apos;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&apos; +</span><br><span class="line">    &apos;&lt;p&gt;&lt;img src=&quot;cid:0&quot;&gt;&lt;/p&gt;&apos; +</span><br><span class="line">    &apos;&lt;/body&gt;&lt;/html&gt;&apos;, &apos;html&apos;, &apos;utf-8&apos;))</span><br></pre></td></tr></table></figure></p><p>再次发送，就可以看到图片直接嵌入到邮件正文的效果：</p><h3 id="同时支持HTML和Plain格式"><a href="#同时支持HTML和Plain格式" class="headerlink" title="同时支持HTML和Plain格式"></a>同时支持HTML和Plain格式</h3><p>如果我们发送HTML邮件，收件人通过浏览器或者Outlook之类的软件是可以正常浏览邮件内容的，但是，如果收件人使用的设备太古老，查看不了HTML邮件怎么办？</p><p>办法是在发送HTML的同时再附加一个纯文本，如果收件人无法查看HTML格式的邮件，就可以自动降级查看纯文本邮件。</p><p>利用MIMEMultipart就可以组合一个HTML和Plain，要注意指定subtype是alternative：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msg = MIMEMultipart(&apos;alternative&apos;)</span><br><span class="line">msg[&apos;From&apos;] = ...</span><br><span class="line">msg[&apos;To&apos;] = ...</span><br><span class="line">msg[&apos;Subject&apos;] = ...</span><br><span class="line"></span><br><span class="line">msg.attach(MIMEText(&apos;hello&apos;, &apos;plain&apos;, &apos;utf-8&apos;))</span><br><span class="line">msg.attach(MIMEText(&apos;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&apos;, &apos;html&apos;, &apos;utf-8&apos;))</span><br><span class="line"># 正常发送msg对象...</span><br></pre></td></tr></table></figure></p><h3 id="加密SMTP"><a href="#加密SMTP" class="headerlink" title="加密SMTP"></a>加密SMTP</h3><p>使用标准的25端口连接SMTP服务器时，使用的是明文传输，发送邮件的整个过程可能会被窃听。要更安全地发送邮件，可以加密SMTP会话，实际上就是先创建SSL安全连接，然后再使用SMTP协议发送邮件。</p><p>某些邮件服务商，例如Gmail，提供的SMTP服务必须要加密传输。我们来看看如何通过Gmail提供的安全SMTP发送邮件。</p><p>必须知道，Gmail的SMTP端口是587，因此，修改代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">smtp_server = &apos;smtp.gmail.com&apos;</span><br><span class="line">smtp_port = 587</span><br><span class="line">server = smtplib.SMTP(smtp_server, smtp_port)</span><br><span class="line">server.starttls()</span><br><span class="line"># 剩下的代码和前面的一模一样:</span><br><span class="line">server.set_debuglevel(1)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>只需要在创建SMTP对象后，立刻调用starttls()方法，就创建了安全连接。后面的代码和前面的发送邮件代码完全一样。</p><p>如果因为网络问题无法连接Gmail的SMTP服务器，请相信我们的代码是没有问题的，你需要对你的网络设置做必要的调整。</p><p><strong>小结</strong><br>使用Python的smtplib发送邮件十分简单，只要掌握了各种邮件类型的构造方法，正确设置好邮件头，就可以顺利发出。</p><p>构造一个邮件对象就是一个Messag对象，如果构造一个MIMEText对象，就表示一个文本邮件对象，如果构造一个MIMEImage对象，就表示一个作为附件的图片，要把多个对象组合起来，就用MIMEMultipart对象，而MIMEBase可以表示任何对象。它们的继承关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Message</span><br><span class="line">+- MIMEBase</span><br><span class="line">   +- MIMEMultipart</span><br><span class="line">   +- MIMENonMultipart</span><br><span class="line">      +- MIMEMessage</span><br><span class="line">      +- MIMEText</span><br><span class="line">      +- MIMEImage</span><br></pre></td></tr></table></figure></p><p>这种嵌套关系就可以构造出任意复杂的邮件。你可以通过email.mime文档查看它们所在的包以及详细的用法。</p><hr><h2 id="POP3收取邮件"><a href="#POP3收取邮件" class="headerlink" title="POP3收取邮件"></a>POP3收取邮件</h2><p>SMTP用于发送邮件，如果要收取邮件呢？</p><p>收取邮件就是编写一个MUA作为客户端，从MDA把邮件获取到用户的电脑或者手机上。收取邮件最常用的协议是POP协议，目前版本号是3，俗称POP3。</p><p>Python内置一个poplib模块，实现了POP3协议，可以直接用来收邮件。</p><p>注意到POP3协议收取的不是一个已经可以阅读的邮件本身，而是邮件的原始文本，这和SMTP协议很像，SMTP发送的也是经过编码后的一大段文本。</p><p>要把POP3收取的文本变成可以阅读的邮件，还需要用email模块提供的各种类来解析原始文本，变成可阅读的邮件对象。</p><p>所以，收取邮件分两步：</p><p>第一步：用poplib把邮件的原始文本下载到本地；</p><p>第二部：用email解析原始文本，还原为邮件对象。</p><h3 id="通过POP3下载邮件"><a href="#通过POP3下载邮件" class="headerlink" title="通过POP3下载邮件"></a>通过POP3下载邮件</h3><p>POP3协议本身很简单，以下面的代码为例，我们来获取最新的一封邮件内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import poplib</span><br><span class="line"></span><br><span class="line"># 输入邮件地址, 口令和POP3服务器地址:</span><br><span class="line">email = input(&apos;Email: &apos;)</span><br><span class="line">password = input(&apos;Password: &apos;)</span><br><span class="line">pop3_server = input(&apos;POP3 server: &apos;)</span><br><span class="line"></span><br><span class="line"># 连接到POP3服务器:</span><br><span class="line">server = poplib.POP3(pop3_server)</span><br><span class="line"># 可以打开或关闭调试信息:</span><br><span class="line">server.set_debuglevel(1)</span><br><span class="line"># 可选:打印POP3服务器的欢迎文字:</span><br><span class="line">print(server.getwelcome().decode(&apos;utf-8&apos;))</span><br><span class="line"></span><br><span class="line"># 身份认证:</span><br><span class="line">server.user(email)</span><br><span class="line">server.pass_(password)</span><br><span class="line"></span><br><span class="line"># stat()返回邮件数量和占用空间:</span><br><span class="line">print(&apos;Messages: %s. Size: %s&apos; % server.stat())</span><br><span class="line"># list()返回所有邮件的编号:</span><br><span class="line">resp, mails, octets = server.list()</span><br><span class="line"># 可以查看返回的列表类似[b&apos;1 82923&apos;, b&apos;2 2184&apos;, ...]</span><br><span class="line">print(mails)</span><br><span class="line"></span><br><span class="line"># 获取最新一封邮件, 注意索引号从1开始:</span><br><span class="line">index = len(mails)</span><br><span class="line">resp, lines, octets = server.retr(index)</span><br><span class="line"></span><br><span class="line"># lines存储了邮件的原始文本的每一行,</span><br><span class="line"># 可以获得整个邮件的原始文本:</span><br><span class="line">msg_content = b&apos;\r\n&apos;.join(lines).decode(&apos;utf-8&apos;)</span><br><span class="line"># 稍后解析出邮件:</span><br><span class="line">msg = Parser().parsestr(msg_content)</span><br><span class="line"></span><br><span class="line"># 可以根据邮件索引号直接从服务器删除邮件:</span><br><span class="line"># server.dele(index)</span><br><span class="line"># 关闭连接:</span><br><span class="line">server.quit()</span><br></pre></td></tr></table></figure></p><p>用POP3获取邮件其实很简单，要获取所有邮件，只需要循环使用retr()把每一封邮件内容拿到即可。真正麻烦的是把邮件的原始内容解析为可以阅读的邮件对象。</p><h3 id="解析邮件"><a href="#解析邮件" class="headerlink" title="解析邮件"></a>解析邮件</h3><p>解析邮件的过程和上一节构造邮件正好相反，因此，先导入必要的模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from email.parser import Parser</span><br><span class="line">from email.header import decode_header</span><br><span class="line">from email.utils import parseaddr</span><br><span class="line"></span><br><span class="line">import poplib</span><br></pre></td></tr></table></figure></p><p>只需要一行代码就可以把邮件内容解析为Message对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg = Parser().parsestr(msg_content)</span><br></pre></td></tr></table></figure></p><p>但是这个Message对象本身可能是一个MIMEMultipart对象，即包含嵌套的其他MIMEBase对象，嵌套可能还不止一层。</p><p>所以我们要递归地打印出Message对象的层次结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># indent用于缩进显示:</span><br><span class="line">def print_info(msg, indent=0):</span><br><span class="line">    if indent == 0:</span><br><span class="line">        for header in [&apos;From&apos;, &apos;To&apos;, &apos;Subject&apos;]:</span><br><span class="line">            value = msg.get(header, &apos;&apos;)</span><br><span class="line">            if value:</span><br><span class="line">                if header==&apos;Subject&apos;:</span><br><span class="line">                    value = decode_str(value)</span><br><span class="line">                else:</span><br><span class="line">                    hdr, addr = parseaddr(value)</span><br><span class="line">                    name = decode_str(hdr)</span><br><span class="line">                    value = u&apos;%s &lt;%s&gt;&apos; % (name, addr)</span><br><span class="line">            print(&apos;%s%s: %s&apos; % (&apos;  &apos; * indent, header, value))</span><br><span class="line">    if (msg.is_multipart()):</span><br><span class="line">        parts = msg.get_payload()</span><br><span class="line">        for n, part in enumerate(parts):</span><br><span class="line">            print(&apos;%spart %s&apos; % (&apos;  &apos; * indent, n))</span><br><span class="line">            print(&apos;%s--------------------&apos; % (&apos;  &apos; * indent))</span><br><span class="line">            print_info(part, indent + 1)</span><br><span class="line">    else:</span><br><span class="line">        content_type = msg.get_content_type()</span><br><span class="line">        if content_type==&apos;text/plain&apos; or content_type==&apos;text/html&apos;:</span><br><span class="line">            content = msg.get_payload(decode=True)</span><br><span class="line">            charset = guess_charset(msg)</span><br><span class="line">            if charset:</span><br><span class="line">                content = content.decode(charset)</span><br><span class="line">            print(&apos;%sText: %s&apos; % (&apos;  &apos; * indent, content + &apos;...&apos;))</span><br><span class="line">        else:</span><br><span class="line">            print(&apos;%sAttachment: %s&apos; % (&apos;  &apos; * indent, content_type))</span><br></pre></td></tr></table></figure></p><p>邮件的Subject或者Email中包含的名字都是经过编码后的str，要正常显示，就必须decode：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def decode_str(s):</span><br><span class="line">    value, charset = decode_header(s)[0]</span><br><span class="line">    if charset:</span><br><span class="line">        value = value.decode(charset)</span><br><span class="line">    return value</span><br></pre></td></tr></table></figure></p><p>decode_header()返回一个list，因为像Cc、Bcc这样的字段可能包含多个邮件地址，所以解析出来的会有多个元素。上面的代码我们偷了个懒，只取了第一个元素。</p><p>文本邮件的内容也是str，还需要检测编码，否则，非UTF-8编码的邮件都无法正常显示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def guess_charset(msg):</span><br><span class="line">    charset = msg.get_charset()</span><br><span class="line">    if charset is None:</span><br><span class="line">        content_type = msg.get(&apos;Content-Type&apos;, &apos;&apos;).lower()</span><br><span class="line">        pos = content_type.find(&apos;charset=&apos;)</span><br><span class="line">        if pos &gt;= 0:</span><br><span class="line">            charset = content_type[pos + 8:].strip()</span><br><span class="line">    return charset</span><br></pre></td></tr></table></figure></p><p>把上面的代码整理好，我们就可以来试试收取一封邮件。先往自己的邮箱发一封邮件，然后用浏览器登录邮箱，看看邮件收到没，如果收到了，我们就来用Python程序把它收到本地</p><p>运行程序，结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+OK Welcome to coremail Mail Pop3 Server (163coms[...])</span><br><span class="line">Messages: 126. Size: 27228317</span><br><span class="line"></span><br><span class="line">From: Test &lt;xxxxxx@qq.com&gt;</span><br><span class="line">To: Python爱好者 &lt;xxxxxx@163.com&gt;</span><br><span class="line">Subject: 用POP3收取邮件</span><br><span class="line">part 0</span><br><span class="line">--------------------</span><br><span class="line">  part 0</span><br><span class="line">  --------------------</span><br><span class="line">    Text: Python可以使用POP3收取邮件……...</span><br><span class="line">  part 1</span><br><span class="line">  --------------------</span><br><span class="line">    Text: Python可以&lt;a href=&quot;...&quot;&gt;使用POP3&lt;/a&gt;收取邮件……...</span><br><span class="line">part 1</span><br><span class="line">--------------------</span><br><span class="line">  Attachment: application/octet-stream</span><br></pre></td></tr></table></figure></p><p>我们从打印的结构可以看出，这封邮件是一个MIMEMultipart，它包含两部分：第一部分又是一个MIMEMultipart，第二部分是一个附件。而内嵌的MIMEMultipart是一个alternative类型，它包含一个纯文本格式的MIMEText和一个HTML格式的MIMEText。</p><p><strong>小结</strong><br>用Python的poplib模块收取邮件分两步：第一步是用POP3协议把邮件获取到本地，第二步是用email模块把原始邮件解析为Message对象，然后，用适当的形式把邮件内容展示给用户即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Email的历史比Web还要久远，直到现在，Email也是互联网上应用非常广泛的服务。&lt;/p&gt;
&lt;p&gt;几乎所有的编程语言都支持发送和接收电子邮件，但是，先等等，在我们开始编写代码之前，有必要搞清楚电子邮件是如何在互联网上运作的。&lt;/p&gt;
&lt;p&gt;我们来看看传统邮件是如何运作的。假设你现在在北京，要给一个香港的朋友发一封信，怎么做呢？&lt;/p&gt;
&lt;p&gt;首先你得写好信，装进信封，写上地址，贴上邮票，然后就近找个邮局，把信仍进去。&lt;/p&gt;
&lt;p&gt;信件会从就近的小邮局转运到大邮局，再从大邮局往别的城市发，比如先发到天津，再走海运到达香港，也可能走京九线到香港，但是你不用关心具体路线，你只需要知道一件事，就是信件走得很慢，至少要几天时间。&lt;/p&gt;
&lt;p&gt;信件到达香港的某个邮局，也不会直接送到朋友的家里，因为邮局的叔叔是很聪明的，他怕你的朋友不在家，一趟一趟地白跑，所以，信件会投递到你的朋友的邮箱里，邮箱可能在公寓的一层，或者家门口，直到你的朋友回家的时候检查邮箱，发现信件后，就可以取到邮件了。&lt;/p&gt;
&lt;p&gt;电子邮件的流程基本上也是按上面的方式运作的，只不过速度不是按天算，而是按秒算。&lt;/p&gt;
&lt;p&gt;现在我们回到电子邮件，假设我们自己的电子邮件地址是&lt;a href=&quot;mailto:me@163.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;me@163.com&lt;/a&gt;，对方的电子邮件地址是&lt;a href=&quot;mailto:friend@sina.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;friend@sina.com&lt;/a&gt;（注意地址都是虚构的哈），现在我们用Outlook或者Foxmail之类的软件写好邮件，填上对方的Email地址，点“发送”，电子邮件就发出去了。这些电子邮件软件被称为MUA：Mail User Agent——邮件用户代理。&lt;/p&gt;
&lt;p&gt;Email从MUA发出去，不是直接到达对方电脑，而是发到MTA：Mail Transfer Agent——邮件传输代理，就是那些Email服务提供商，比如网易、新浪等等。由于我们自己的电子邮件是163.com，所以，Email首先被投递到网易提供的MTA，再由网易的MTA发到对方服务商，也就是新浪的MTA。这个过程中间可能还会经过别的MTA，但是我们不关心具体路线，我们只关心速度。&lt;/p&gt;
&lt;p&gt;Email到达新浪的MTA后，由于对方使用的是@sina.com的邮箱，因此，新浪的MTA会把Email投递到邮件的最终目的地MDA：Mail Delivery Agent——邮件投递代理。Email到达MDA后，就静静地躺在新浪的某个服务器上，存放在某个文件或特殊的数据库里，我们将这个长期保存邮件的地方称之为电子邮箱。&lt;/p&gt;
&lt;p&gt;同普通邮件类似，Email不会直接到达对方的电脑，因为对方电脑不一定开机，开机也不一定联网。对方要取到邮件，必须通过MUA从MDA上把邮件取到自己的电脑上。&lt;/p&gt;
&lt;p&gt;所以，一封电子邮件的旅程就是：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;发件人 -&amp;gt; MUA -&amp;gt; MTA -&amp;gt; MTA -&amp;gt; 若干个MTA -&amp;gt; MDA &amp;lt;- MUA &amp;lt;- 收件人&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;有了上述基本概念，要编写程序来发送和接收邮件，本质上就是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;编写MUA把邮件发到MTA；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;编写MUA从MDA上收邮件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;发邮件时，MUA和MTA使用的协议就是&lt;strong&gt;SMTP&lt;/strong&gt;：Simple Mail Transfer Protocol，后面的MTA到另一个MTA也是用SMTP协议。&lt;/p&gt;
&lt;p&gt;收邮件时，MUA和MDA使用的协议有两种：&lt;strong&gt;POP&lt;/strong&gt;：Post Office Protocol，目前版本是3，俗称POP3；&lt;strong&gt;IMAP&lt;/strong&gt;：Internet Message Access Protocol，目前版本是4，优点是不但能取邮件，还可以直接操作MDA上存储的邮件，比如从收件箱移到垃圾箱，等等。&lt;/p&gt;
&lt;p&gt;邮件客户端软件在发邮件时，会让你先配置SMTP服务器，也就是你要发到哪个MTA上。假设你正在使用163的邮箱，你就不能直接发到新浪的MTA上，因为它只服务新浪的用户，所以，你得填163提供的SMTP服务器地址：smtp.163.com，为了证明你是163的用户，SMTP服务器还要求你填写邮箱地址和邮箱口令，这样，MUA才能正常地把Email通过SMTP协议发送到MTA。&lt;/p&gt;
&lt;p&gt;类似的，从MDA收邮件时，MDA服务器也要求验证你的邮箱口令，确保不会有人冒充你收取你的邮件，所以，Outlook之类的邮件客户端会要求你填写POP3或IMAP服务器地址、邮箱地址和口令，这样，MUA才能顺利地通过POP或IMAP协议从MDA取到邮件。&lt;/p&gt;
&lt;p&gt;在使用Python收发邮件前，请先准备好至少两个电子邮件，如&lt;a href=&quot;mailto:xxx@163.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;xxx@163.com&lt;/a&gt;，&lt;a href=&quot;mailto:xxx@sina.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;xxx@sina.com&lt;/a&gt;，&lt;a href=&quot;mailto:xxx@qq.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;xxx@qq.com&lt;/a&gt;等，注意两个邮箱不要用同一家邮件服务商。&lt;/p&gt;
&lt;p&gt;最后特别注意，目前大多数邮件服务商都需要手动打开SMTP发信和POP收信的功能，否则只允许在网页登录&lt;/p&gt;
    
    </summary>
    
      <category term="编程相关" scheme="https://paradoxallen.github.io/categories/%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="python" scheme="https://paradoxallen.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python网络编程</title>
    <link href="https://paradoxallen.github.io/7429/"/>
    <id>https://paradoxallen.github.io/7429/</id>
    <published>2017-11-23T16:00:00.000Z</published>
    <updated>2018-07-25T12:56:20.050Z</updated>
    
    <content type="html"><![CDATA[<p>自从互联网诞生以来，现在基本上所有的程序都是网络程序，很少有单机版的程序了。</p><p>计算机网络就是把各个计算机连接到一起，让网络中的计算机可以互相通信。网络编程就是如何在程序中实现两台计算机的通信。</p><p>举个例子，当你使用浏览器访问新浪网时，你的计算机就和新浪的某台服务器通过互联网连接起来了，然后，新浪的服务器把网页内容作为数据通过互联网传输到你的电脑上。</p><p>由于你的电脑上可能不止浏览器，还有QQ、Skype、Dropbox、邮件客户端等，不同的程序连接的别的计算机也会不同，所以，更确切地说，网络通信是两台计算机上的两个进程之间的通信。比如，浏览器进程和新浪服务器上的某个Web服务进程在通信，而QQ进程是和腾讯的某个服务器上的某个进程在通信。</p><p>网络通信就是两个进程在通信。</p><p>网络编程对所有开发语言都是一样的，Python也不例外。用Python进行网络编程，就是在Python程序本身这个进程内，连接别的服务器进程的通信端口进行通信。</p><p>这里将详细介绍Python网络编程的概念和最主要的两种网络类型的编程。</p><a id="more"></a><hr><h2 id="TCP-IP简介"><a href="#TCP-IP简介" class="headerlink" title="TCP/IP简介"></a>TCP/IP简介</h2><p>虽然大家现在对互联网很熟悉，但是计算机网络的出现比互联网要早很多。</p><p>计算机为了联网，就必须规定通信协议，早期的计算机网络，都是由各厂商自己规定一套协议，IBM、Apple和Microsoft都有各自的网络协议，互不兼容，这就好比一群人有的说英语，有的说中文，有的说德语，说同一种语言的人可以交流，不同的语言之间就不行了。</p><p>为了把全世界的所有不同类型的计算机都连接起来，就必须规定一套全球通用的协议，为了实现互联网这个目标，互联网协议簇（Internet Protocol Suite）就是通用协议标准。Internet是由inter和net两个单词组合起来的，原意就是连接“网络”的网络，有了Internet，任何私有网络，只要支持这个协议，就可以联入互联网。</p><p>因为互联网协议包含了上百种协议标准，但是最重要的两个协议是TCP和IP协议，所以，大家把互联网的协议简称TCP/IP协议。</p><p>通信的时候，双方必须知道对方的标识，好比发邮件必须知道对方的邮件地址。互联网上每个计算机的唯一标识就是IP地址，类似123.123.123.123。如果一台计算机同时接入到两个或更多的网络，比如路由器，它就会有两个或多个IP地址，所以，IP地址对应的实际上是计算机的网络接口，通常是网卡。</p><p>IP协议负责把数据从一台计算机通过网络发送到另一台计算机。数据被分割成一小块一小块，然后通过IP包发送出去。由于互联网链路复杂，两台计算机之间经常有多条线路，因此，路由器就负责决定如何把一个IP包转发出去。IP包的特点是按块发送，途径多个路由，但不保证能到达，也不保证顺序到达。</p><p>IP地址实际上是一个32位整数（称为IPv4），以字符串表示的IP地址如192.168.0.1实际上是把32位整数按8位分组后的数字表示，目的是便于阅读。</p><p>IPv6地址实际上是一个128位整数，它是目前使用的IPv4的升级版，以字符串表示类似于2001:0db8:85a3:0042:1000:8a2e:0370:7334。</p><p>TCP协议则是建立在IP协议之上的。TCP协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。TCP协议会通过握手建立连接，然后，对每个IP包编号，确保对方按顺序收到，如果包丢掉了，就自动重发。</p><p>许多常用的更高级的协议都是建立在TCP协议基础上的，比如用于浏览器的HTTP协议、发送邮件的SMTP协议等。</p><p>一个TCP报文除了包含要传输的数据外，还包含源IP地址和目标IP地址，源端口和目标端口。</p><p>端口有什么作用？在两台计算机通信时，只发IP地址是不够的，因为同一台计算机上跑着多个网络程序。一个TCP报文来了之后，到底是交给浏览器还是QQ，就需要端口号来区分。每个网络程序都向操作系统申请唯一的端口号，这样，两个进程在两台计算机之间建立网络连接就需要各自的IP地址和各自的端口号。</p><p>一个进程也可能同时与多个计算机建立链接，因此它会申请很多端口。</p><p>了解了TCP/IP协议的基本概念，IP地址和端口的概念，我们就可以开始进行网络编程了。</p><hr><h2 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h2><p>Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>大多数连接都是可靠的TCP连接。创建TCP连接时，主动发起连接的叫客户端，被动响应连接的叫服务器。</p><p>举个例子，当我们在浏览器中访问新浪时，我们自己的计算机就是客户端，浏览器会主动向新浪的服务器发起连接。如果一切顺利，新浪的服务器接受了我们的连接，一个TCP连接就建立起来的，后面的通信就是发送网页内容了。</p><p>所以，我们要创建一个基于TCP连接的Socket，可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 导入socket库:</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line"># 创建一个socket:</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"># 建立连接:</span><br><span class="line">s.connect((&apos;www.sina.com.cn&apos;, 80))</span><br></pre></td></tr></table></figure></p><p>创建Socket时，AF_INET指定使用IPv4协议，如果要用更先进的IPv6，就指定为AF_INET6。SOCK_STREAM指定使用面向流的TCP协议，这样，一个Socket对象就创建成功，但是还没有建立连接。</p><p>客户端要主动发起TCP连接，必须知道服务器的IP地址和端口号。新浪网站的IP地址可以用域名<a href="http://www.sina.com.cn自动转换到IP地址，但是怎么知道新浪服务器的端口号呢？" target="_blank" rel="noopener">www.sina.com.cn自动转换到IP地址，但是怎么知道新浪服务器的端口号呢？</a></p><p>答案是作为服务器，提供什么样的服务，端口号就必须固定下来。由于我们想要访问网页，因此新浪提供网页服务的服务器必须把端口号固定在80端口，因为80端口是Web服务的标准端口。其他服务都有对应的标准端口号，例如SMTP服务是25端口，FTP服务是21端口，等等。端口号小于1024的是Internet标准服务的端口，端口号大于1024的，可以任意使用。</p><p>因此，我们连接新浪服务器的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.connect((&apos;www.sina.com.cn&apos;, 80))</span><br></pre></td></tr></table></figure></p><p>注意参数是一个tuple，包含地址和端口号。</p><p>建立TCP连接后，我们就可以向新浪服务器发送请求，要求返回首页的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 发送数据:</span><br><span class="line">s.send(b&apos;GET / HTTP/1.1\r\nHost: www.sina.com.cn\r\nConnection: close\r\n\r\n&apos;)</span><br></pre></td></tr></table></figure></p><p>TCP连接创建的是双向通道，双方都可以同时给对方发数据。但是谁先发谁后发，怎么协调，要根据具体的协议来决定。例如，HTTP协议规定客户端必须先发请求给服务器，服务器收到后才发数据给客户端。</p><p>发送的文本格式必须符合HTTP标准，如果格式没问题，接下来就可以接收新浪服务器返回的数据了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 接收数据:</span><br><span class="line">buffer = []</span><br><span class="line">while True:</span><br><span class="line">    # 每次最多接收1k字节:</span><br><span class="line">    d = s.recv(1024)</span><br><span class="line">    if d:</span><br><span class="line">        buffer.append(d)</span><br><span class="line">    else:</span><br><span class="line">        break</span><br><span class="line">data = b&apos;&apos;.join(buffer)</span><br></pre></td></tr></table></figure></p><p>接收数据时，调用recv(max)方法，一次最多接收指定的字节数，因此，在一个while循环中反复接收，直到recv()返回空数据，表示接收完毕，退出循环。</p><p>当我们接收完数据后，调用close()方法关闭Socket，这样，一次完整的网络通信就结束了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 关闭连接:</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure></p><p>接收到的数据包括HTTP头和网页本身，我们只需要把HTTP头和网页分离一下，把HTTP头打印出来，网页内容保存到文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">header, html = data.split(b&apos;\r\n\r\n&apos;, 1)</span><br><span class="line">print(header.decode(&apos;utf-8&apos;))</span><br><span class="line"># 把接收的数据写入文件:</span><br><span class="line">with open(&apos;sina.html&apos;, &apos;wb&apos;) as f:</span><br><span class="line">    f.write(html)</span><br></pre></td></tr></table></figure></p><p>现在，只需要在浏览器中打开这个sina.html文件，就可以看到新浪的首页了。</p><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>和客户端编程相比，服务器编程就要复杂一些。</p><p>服务器进程首先要绑定一个端口并监听来自其他客户端的连接。如果某个客户端连接过来了，服务器就与该客户端建立Socket连接，随后的通信就靠这个Socket连接了。</p><p>所以，服务器会打开固定端口（比如80）监听，每来一个客户端连接，就创建该Socket连接。由于服务器会有大量来自客户端的连接，所以，服务器要能够区分一个Socket连接是和哪个客户端绑定的。一个Socket依赖4项：服务器地址、服务器端口、客户端地址、客户端端口来唯一确定一个Socket。</p><p>但是服务器还需要同时响应多个客户端的请求，所以，每个连接都需要一个新的进程或者新的线程来处理，否则，服务器一次就只能服务一个客户端了。</p><p>我们来编写一个简单的服务器程序，它接收客户端连接，把客户端发过来的字符串加上Hello再发回去。</p><p>首先，创建一个基于IPv4和TCP协议的Socket：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br></pre></td></tr></table></figure></p><p>然后，我们要绑定监听的地址和端口。服务器可能有多块网卡，可以绑定到某一块网卡的IP地址上，也可以用0.0.0.0绑定到所有的网络地址，还可以用127.0.0.1绑定到本机地址。127.0.0.1是一个特殊的IP地址，表示本机地址，如果绑定到这个地址，客户端必须同时在本机运行才能连接，也就是说，外部的计算机无法连接进来。</p><p>端口号需要预先指定。因为我们写的这个服务不是标准服务，所以用9999这个端口号。请注意，小于1024的端口号必须要有管理员权限才能绑定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 监听端口:</span><br><span class="line">s.bind((&apos;127.0.0.1&apos;, 9999))</span><br></pre></td></tr></table></figure></p><p>紧接着，调用listen()方法开始监听端口，传入的参数指定等待连接的最大数量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.listen(5)</span><br><span class="line">print(&apos;Waiting for connection...&apos;)</span><br></pre></td></tr></table></figure></p><p>接下来，服务器程序通过一个永久循环来接受来自客户端的连接，accept()会等待并返回一个客户端的连接:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">while True:</span><br><span class="line">    # 接受一个新连接:</span><br><span class="line">    sock, addr = s.accept()</span><br><span class="line">    # 创建新线程来处理TCP连接:</span><br><span class="line">    t = threading.Thread(target=tcplink, args=(sock, addr))</span><br><span class="line">    t.start()</span><br><span class="line">每个连接都必须创建新线程（或进程）来处理，否则，单线程在处理连接的过程中，无法接受其他客户端的连接：</span><br><span class="line"></span><br><span class="line">def tcplink(sock, addr):</span><br><span class="line">    print(&apos;Accept new connection from %s:%s...&apos; % addr)</span><br><span class="line">    sock.send(b&apos;Welcome!&apos;)</span><br><span class="line">    while True:</span><br><span class="line">        data = sock.recv(1024)</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        if not data or data.decode(&apos;utf-8&apos;) == &apos;exit&apos;:</span><br><span class="line">            break</span><br><span class="line">        sock.send((&apos;Hello, %s!&apos; % data.decode(&apos;utf-8&apos;)).encode(&apos;utf-8&apos;))</span><br><span class="line">    sock.close()</span><br><span class="line">    print(&apos;Connection from %s:%s closed.&apos; % addr)</span><br></pre></td></tr></table></figure></p><p>连接建立后，服务器首先发一条欢迎消息，然后等待客户端数据，并加上Hello再发送给客户端。如果客户端发送了exit字符串，就直接关闭连接。</p><p>要测试这个服务器程序，我们还需要编写一个客户端程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"># 建立连接:</span><br><span class="line">s.connect((&apos;127.0.0.1&apos;, 9999))</span><br><span class="line"># 接收欢迎消息:</span><br><span class="line">print(s.recv(1024).decode(&apos;utf-8&apos;))</span><br><span class="line">for data in [b&apos;Michael&apos;, b&apos;Tracy&apos;, b&apos;Sarah&apos;]:</span><br><span class="line">    # 发送数据:</span><br><span class="line">    s.send(data)</span><br><span class="line">    print(s.recv(1024).decode(&apos;utf-8&apos;))</span><br><span class="line">s.send(b&apos;exit&apos;)</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure></p><p>我们需要打开两个命令行窗口，一个运行服务器程序，另一个运行客户端程序，就可以看到效果了</p><p>需要注意的是，客户端程序运行完毕就退出了，而服务器程序会永远运行下去，必须按Ctrl+C退出程序。</p><p><strong>小结</strong><br>用TCP协议进行Socket编程在Python中十分简单，对于客户端，要主动连接服务器的IP和指定端口，对于服务器，要首先监听指定端口，然后，对每一个新的连接，创建一个线程或进程来处理。通常，服务器程序会无限运行下去。</p><p>同一个端口，被一个Socket绑定了以后，就不能被别的Socket绑定了。</p><hr><h2 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h2><p>TCP是建立可靠连接，并且通信双方都可以以流的形式发送数据。相对TCP，UDP则是面向无连接的协议。</p><p>使用UDP协议时，不需要建立连接，只需要知道对方的IP地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。</p><p>虽然用UDP传输数据不可靠，但它的优点是和TCP比，速度快，对于不要求可靠到达的数据，就可以使用UDP协议。</p><p>我们来看看如何通过UDP协议传输数据。和TCP类似，使用UDP的通信双方也分为客户端和服务器。服务器首先需要绑定端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"># 绑定端口:</span><br><span class="line">s.bind((&apos;127.0.0.1&apos;, 9999))</span><br></pre></td></tr></table></figure></p><p>创建Socket时，SOCK_DGRAM指定了这个Socket的类型是UDP。绑定端口和TCP一样，但是不需要调用listen()方法，而是直接接收来自任何客户端的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;Bind UDP on 9999...&apos;)</span><br><span class="line">while True:</span><br><span class="line">    # 接收数据:</span><br><span class="line">    data, addr = s.recvfrom(1024)</span><br><span class="line">    print(&apos;Received from %s:%s.&apos; % addr)</span><br><span class="line">    s.sendto(b&apos;Hello, %s!&apos; % data, addr)</span><br></pre></td></tr></table></figure></p><p>recvfrom()方法返回数据和客户端的地址与端口，这样，服务器收到数据后，直接调用sendto()就可以把数据用UDP发给客户端。</p><p>注意这里省掉了多线程，因为这个例子很简单。</p><p>客户端使用UDP时，首先仍然创建基于UDP的Socket，然后，不需要调用connect()，直接通过sendto()给服务器发数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line">for data in [b&apos;Michael&apos;, b&apos;Tracy&apos;, b&apos;Sarah&apos;]:</span><br><span class="line">    # 发送数据:</span><br><span class="line">    s.sendto(data, (&apos;127.0.0.1&apos;, 9999))</span><br><span class="line">    # 接收数据:</span><br><span class="line">    print(s.recv(1024).decode(&apos;utf-8&apos;))</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure></p><p>从服务器接收数据仍然调用recv()方法。</p><p>仍然用两个命令行分别启动服务器和客户端测试</p><p><strong>小结</strong><br>UDP的使用与TCP类似，但是不需要建立连接。此外，服务器绑定UDP端口和TCP端口互不冲突，也就是说，UDP的9999端口与TCP的9999端口可以各自绑定。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从互联网诞生以来，现在基本上所有的程序都是网络程序，很少有单机版的程序了。&lt;/p&gt;
&lt;p&gt;计算机网络就是把各个计算机连接到一起，让网络中的计算机可以互相通信。网络编程就是如何在程序中实现两台计算机的通信。&lt;/p&gt;
&lt;p&gt;举个例子，当你使用浏览器访问新浪网时，你的计算机就和新浪的某台服务器通过互联网连接起来了，然后，新浪的服务器把网页内容作为数据通过互联网传输到你的电脑上。&lt;/p&gt;
&lt;p&gt;由于你的电脑上可能不止浏览器，还有QQ、Skype、Dropbox、邮件客户端等，不同的程序连接的别的计算机也会不同，所以，更确切地说，网络通信是两台计算机上的两个进程之间的通信。比如，浏览器进程和新浪服务器上的某个Web服务进程在通信，而QQ进程是和腾讯的某个服务器上的某个进程在通信。&lt;/p&gt;
&lt;p&gt;网络通信就是两个进程在通信。&lt;/p&gt;
&lt;p&gt;网络编程对所有开发语言都是一样的，Python也不例外。用Python进行网络编程，就是在Python程序本身这个进程内，连接别的服务器进程的通信端口进行通信。&lt;/p&gt;
&lt;p&gt;这里将详细介绍Python网络编程的概念和最主要的两种网络类型的编程。&lt;/p&gt;
    
    </summary>
    
      <category term="编程相关" scheme="https://paradoxallen.github.io/categories/%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="python" scheme="https://paradoxallen.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python图形界面</title>
    <link href="https://paradoxallen.github.io/53971/"/>
    <id>https://paradoxallen.github.io/53971/</id>
    <published>2017-11-19T16:00:00.000Z</published>
    <updated>2018-07-21T07:16:18.180Z</updated>
    
    <content type="html"><![CDATA[<p>Python支持多种图形界面的第三方库，包括：</p><ul><li><p>Tk</p></li><li><p>wxWidgets</p></li><li><p>Qt</p></li><li><p>GTK</p></li></ul><p>等等。</p><p>但是Python自带的库是支持Tk的Tkinter，使用Tkinter，无需安装任何包，就可以直接使用。本章简单介绍如何使用Tkinter进行GUI编程。</p><a id="more"></a><hr><h3 id="Tkinter"><a href="#Tkinter" class="headerlink" title="Tkinter"></a>Tkinter</h3><p>我们来梳理一下概念：</p><p>我们编写的Python代码会调用内置的Tkinter，Tkinter封装了访问Tk的接口；</p><p>Tk是一个图形库，支持多个操作系统，使用Tcl语言开发；</p><p>Tk会调用操作系统提供的本地GUI接口，完成最终的GUI。</p><p>所以，我们的代码只需要调用Tkinter提供的接口就可以了。</p><h3 id="第一个GUI程序"><a href="#第一个GUI程序" class="headerlink" title="第一个GUI程序"></a>第一个GUI程序</h3><p>使用Tkinter十分简单，我们来编写一个GUI版本的“Hello, world!”。</p><p>第一步是导入Tkinter包的所有内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from tkinter import *</span><br></pre></td></tr></table></figure></p><p>第二步是从Frame派生一个Application类，这是所有Widget的父容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Application(Frame):</span><br><span class="line">    def __init__(self, master=None):</span><br><span class="line">        Frame.__init__(self, master)</span><br><span class="line">        self.pack()</span><br><span class="line">        self.createWidgets()</span><br><span class="line"></span><br><span class="line">    def createWidgets(self):</span><br><span class="line">        self.helloLabel = Label(self, text=&apos;Hello, world!&apos;)</span><br><span class="line">        self.helloLabel.pack()</span><br><span class="line">        self.quitButton = Button(self, text=&apos;Quit&apos;, command=self.quit)</span><br><span class="line">        self.quitButton.pack()</span><br></pre></td></tr></table></figure></p><p>在GUI中，每个Button、Label、输入框等，都是一个Widget。Frame则是可以容纳其他Widget的Widget，所有的Widget组合起来就是一棵树。</p><p>pack()方法把Widget加入到父容器中，并实现布局。pack()是最简单的布局，grid()可以实现更复杂的布局。</p><p>在createWidgets()方法中，我们创建一个Label和一个Button，当Button被点击时，触发self.quit()使程序退出。</p><p>第三步，实例化Application，并启动消息循环：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app = Application()</span><br><span class="line"># 设置窗口标题:</span><br><span class="line">app.master.title(&apos;Hello World&apos;)</span><br><span class="line"># 主消息循环:</span><br><span class="line">app.mainloop()</span><br></pre></td></tr></table></figure></p><p>GUI程序的主线程负责监听来自操作系统的消息，并依次处理每一条消息。因此，如果消息处理非常耗时，就需要在新线程中处理。</p><p>运行这个GUI程序，可以看到窗口</p><p>点击“Quit”按钮或者窗口的“x”结束程序。</p><h3 id="输入文本"><a href="#输入文本" class="headerlink" title="输入文本"></a>输入文本</h3><p>我们再对这个GUI程序改进一下，加入一个文本框，让用户可以输入文本，然后点按钮后，弹出消息对话框。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from tkinter import *</span><br><span class="line">import tkinter.messagebox as messagebox</span><br><span class="line"></span><br><span class="line">class Application(Frame):</span><br><span class="line">    def __init__(self, master=None):</span><br><span class="line">        Frame.__init__(self, master)</span><br><span class="line">        self.pack()</span><br><span class="line">        self.createWidgets()</span><br><span class="line"></span><br><span class="line">    def createWidgets(self):</span><br><span class="line">        self.nameInput = Entry(self)</span><br><span class="line">        self.nameInput.pack()</span><br><span class="line">        self.alertButton = Button(self, text=&apos;Hello&apos;, command=self.hello)</span><br><span class="line">        self.alertButton.pack()</span><br><span class="line"></span><br><span class="line">    def hello(self):</span><br><span class="line">        name = self.nameInput.get() or &apos;world&apos;</span><br><span class="line">        messagebox.showinfo(&apos;Message&apos;, &apos;Hello, %s&apos; % name)</span><br><span class="line"></span><br><span class="line">app = Application()</span><br><span class="line"># 设置窗口标题:</span><br><span class="line">app.master.title(&apos;Hello World&apos;)</span><br><span class="line"># 主消息循环:</span><br><span class="line">app.mainloop()</span><br></pre></td></tr></table></figure></p><p>当用户点击按钮时，触发hello()，通过self.nameInput.get()获得用户输入的文本后，使用tkMessageBox.showinfo()可以弹出消息对话框。</p><p><strong>小结</strong><br>Python内置的Tkinter可以满足基本的GUI程序的要求，如果是非常复杂的GUI程序，建议用操作系统原生支持的语言和库来编写。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python支持多种图形界面的第三方库，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Tk&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;wxWidgets&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Qt&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;GTK&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等等。&lt;/p&gt;
&lt;p&gt;但是Python自带的库是支持Tk的Tkinter，使用Tkinter，无需安装任何包，就可以直接使用。本章简单介绍如何使用Tkinter进行GUI编程。&lt;/p&gt;
    
    </summary>
    
      <category term="编程相关" scheme="https://paradoxallen.github.io/categories/%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="python" scheme="https://paradoxallen.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python vertualenv</title>
    <link href="https://paradoxallen.github.io/60484/"/>
    <id>https://paradoxallen.github.io/60484/</id>
    <published>2017-11-18T16:00:00.000Z</published>
    <updated>2018-07-21T07:16:18.179Z</updated>
    
    <content type="html"><![CDATA[<p>在开发Python应用程序的时候，系统安装的Python3只有一个版本：3.4。所有第三方的包都会被pip安装到Python3的site-packages目录下。</p><p>如果我们要同时开发多个应用程序，那这些应用程序都会共用一个Python，就是安装在系统的Python 3。如果应用A需要jinja 2.7，而应用B需要jinja 2.6怎么办？</p><a id="more"></a><hr><p>这种情况下，每个应用可能需要各自拥有一套“独立”的Python运行环境。virtualenv就是用来为一个应用创建一套“隔离”的Python运行环境。</p><p>首先，我们用pip安装virtualenv：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip3 install virtualenv</span><br></pre></td></tr></table></figure></p><p>然后，假定我们要开发一个新的项目，需要一套独立的Python运行环境，可以这么做：</p><p>第一步，创建目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mac:~ michael$ mkdir myproject</span><br><span class="line">Mac:~ michael$ cd myproject/</span><br><span class="line">Mac:myproject michael$</span><br></pre></td></tr></table></figure></p><p>第二步，创建一个独立的Python运行环境，命名为venv：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Mac:myproject michael$ virtualenv --no-site-packages venv</span><br><span class="line">Using base prefix &apos;/usr/local/.../Python.framework/Versions/3.4&apos;</span><br><span class="line">New python executable in venv/bin/python3.4</span><br><span class="line">Also creating executable in venv/bin/python</span><br><span class="line">Installing setuptools, pip, wheel...done.</span><br></pre></td></tr></table></figure></p><p>命令virtualenv就可以创建一个独立的Python运行环境，我们还加上了参数–no-site-packages，这样，已经安装到系统Python环境中的所有第三方包都不会复制过来，这样，我们就得到了一个不带任何第三方包的“干净”的Python运行环境。</p><p>新建的Python环境被放到当前目录下的venv目录。有了venv这个Python环境，可以用source进入该环境：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mac:myproject michael$ source venv/bin/activate</span><br><span class="line">(venv)Mac:myproject michael$</span><br></pre></td></tr></table></figure></p><p>注意到命令提示符变了，有个(venv)前缀，表示当前环境是一个名为venv的Python环境。</p><p>下面正常安装各种第三方包，并运行python命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(venv)Mac:myproject michael$ pip install jinja2</span><br><span class="line">...</span><br><span class="line">Successfully installed jinja2-2.7.3 markupsafe-0.23</span><br><span class="line">(venv)Mac:myproject michael$ python myapp.py</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>在venv环境下，用pip安装的包都被安装到venv这个环境下，系统Python环境不受任何影响。也就是说，venv环境是专门针对myproject这个应用创建的。</p><p>退出当前的venv环境，使用deactivate命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(venv)Mac:myproject michael$ deactivate </span><br><span class="line">Mac:myproject michael$</span><br></pre></td></tr></table></figure></p><p>此时就回到了正常的环境，现在pip或python均是在系统Python环境下执行。</p><p>完全可以针对每个应用创建独立的Python运行环境，这样就可以对每个应用的Python环境进行隔离。</p><p>virtualenv是如何创建“独立”的Python运行环境的呢？原理很简单，就是把系统Python复制一份到virtualenv的环境，用命令source venv/bin/activate进入一个virtualenv环境时，virtualenv会修改相关环境变量，让命令python和pip均指向当前的virtualenv环境。</p><p><strong>小结</strong><br>virtualenv为应用提供了隔离的Python运行环境，解决了不同应用间多版本的冲突问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发Python应用程序的时候，系统安装的Python3只有一个版本：3.4。所有第三方的包都会被pip安装到Python3的site-packages目录下。&lt;/p&gt;
&lt;p&gt;如果我们要同时开发多个应用程序，那这些应用程序都会共用一个Python，就是安装在系统的Python 3。如果应用A需要jinja 2.7，而应用B需要jinja 2.6怎么办？&lt;/p&gt;
    
    </summary>
    
      <category term="编程相关" scheme="https://paradoxallen.github.io/categories/%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="python" scheme="https://paradoxallen.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫代码———新浪新闻</title>
    <link href="https://paradoxallen.github.io/6897/"/>
    <id>https://paradoxallen.github.io/6897/</id>
    <published>2017-11-17T16:00:00.000Z</published>
    <updated>2018-08-21T07:24:32.694Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">res = requests.get(&apos;http://news.sina.com.cn/china/&apos;)</span><br><span class="line">res.encoding = &apos;utf-8&apos;</span><br><span class="line">print(type(res))</span><br><span class="line">#print(res.text)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#使用示例</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">html_sample = &apos; \</span><br><span class="line">&lt;html&gt; \</span><br><span class="line"> &lt;body&gt; \</span><br><span class="line"> &lt;h1 id=&quot;title&quot;&gt;Hello World&lt;/h1&gt; \</span><br><span class="line"> &lt;a href=&quot;#&quot; class=&quot;link&quot;&gt;This is link1&lt;/a&gt; \</span><br><span class="line"> &lt;a href=&quot;# link2&quot; class=&quot;link&quot;&gt;This is link2&lt;/a&gt; \</span><br><span class="line"> &lt;/body&gt; \</span><br><span class="line"> &lt;/html&gt;&apos;</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(html_sample, &apos;html.parser&apos;)</span><br><span class="line">print(type(soup))</span><br><span class="line">print(soup.text)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#使用select 找出所有含h1的元素</span><br><span class="line">soup = BeautifulSoup(html_sample, &apos;html.parser&apos;)</span><br><span class="line">alink = soup.select(&apos;h1&apos;)</span><br><span class="line">print(alink)</span><br><span class="line">print(alink[0])</span><br><span class="line">print(alink[0].text)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#使用select 找出所有含a的元素</span><br><span class="line">soup = BeautifulSoup(html_sample, &apos;html.parser&apos;)</span><br><span class="line">alink = soup.select(&apos;a&apos;)</span><br><span class="line">print(alink)</span><br><span class="line">for link in alink:</span><br><span class="line">    print(link)</span><br><span class="line">    print(link.text)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#使用select 找出所有id为title的元素</span><br><span class="line">alink = soup.select(&apos;#title&apos;)</span><br><span class="line">print(alink)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#使用select 找出所有class为link的元素</span><br><span class="line">alink = soup.select(&apos;.link&apos;)</span><br><span class="line">for link in alink:</span><br><span class="line">    print(link)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#使用select 找出所有a tag 的href的连结</span><br><span class="line">alink = soup.select(&apos;a&apos;)</span><br><span class="line">for link in alink:</span><br><span class="line">    print(link[&apos;href&apos;])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">res = requests.get(&apos;http://news.sina.com.cn/china/&apos;)</span><br><span class="line">res.encoding = &apos;utf-8&apos;</span><br><span class="line">#print(type(res))</span><br><span class="line">soup = BeautifulSoup(res.text, &apos;html.parser&apos;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for news in soup.select(&apos;.news-item&apos;):</span><br><span class="line">    #print(news)</span><br><span class="line">    if len(news.select(&apos;h2&apos;)) &gt; 0:</span><br><span class="line">        h2 = news.select(&apos;h2&apos;)[0].text</span><br><span class="line">        time = news.select(&apos;.time&apos;)[0].text</span><br><span class="line">        a = news.select(&apos;a&apos;)[0][&apos;href&apos;]</span><br><span class="line">        #print(time, h2, a)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">res = requests.get(&apos;http://news.sina.com.cn/c/2018-07-31/doc-ihhacrcc9897484.shtml&apos;)</span><br><span class="line">res.encoding = &apos;utf-8&apos;</span><br><span class="line">print(type(res))</span><br><span class="line">#print(res.text)</span><br><span class="line">soup = BeautifulSoup(res.text, &apos;html.parser&apos;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#标题</span><br><span class="line">title = soup.select(&apos;.main-title&apos;)[0].text</span><br><span class="line">print(title)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#时间与来源</span><br><span class="line">datesource = soup.select(&apos;.date-source&apos;)[0]</span><br><span class="line">print(datesource)</span><br><span class="line">date = datesource.span.text</span><br><span class="line">print(date)</span><br><span class="line">source = datesource.a.text</span><br><span class="line">print(source)</span><br><span class="line">#或者</span><br><span class="line">#date = soup.select(&apos;.date-source&apos;)[0].contents[0].strip()</span><br><span class="line">#date</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#时间</span><br><span class="line">from datetime import datetime</span><br><span class="line">dt = datetime.strptime(date, &apos;%Y年%m月%d日 %H:%M&apos;) #str转time</span><br><span class="line">print(dt)</span><br><span class="line">dt.strftime(&apos;%Y-%M-%d&apos;)#time转str</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#文章内容</span><br><span class="line">article = []</span><br><span class="line">for p in soup.select(&apos;#article p&apos;)[:-1]:</span><br><span class="line">    article.append(p.text.strip())</span><br><span class="line">#print(article)</span><br><span class="line">&apos; &apos;.join(article)</span><br><span class="line">#或者&apos; &apos;.join[p.text.strip() for p in soup.select(&apos;#article p&apos;)[:-1]]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#编辑</span><br><span class="line">editor = soup.select(&apos;.show_author&apos;)[0].text.lstrip(&apos;责任编辑：&apos;)</span><br><span class="line">print(editor)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#评论</span><br><span class="line">import requests</span><br><span class="line">comments = requests.get(&apos;http://comment5.news.sina.com.cn/page/info?version=1&amp;format=json&amp;\</span><br><span class="line">channel=gn&amp;newsid=comos-hhacrcc9897484&amp;group=undefined&amp;compress=0&amp;ie=utf-8&amp;oe=utf-8&amp;page=1&amp;\</span><br><span class="line">page_size=3&apos;)</span><br><span class="line">#comments.text</span><br><span class="line">import json</span><br><span class="line">jd = json.loads(comments.text)</span><br><span class="line">#print(jd)</span><br><span class="line">commentnum = jd[&apos;result&apos;][&apos;count&apos;][&apos;total&apos;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">newsurl = &apos;http://news.sina.com.cn/c/2018-07-31/doc-ihhacrcc9897484.shtml&apos;</span><br><span class="line">newsurl.split(&apos;/&apos;)[-1].rstrip(&apos;.shtml&apos;).lstrip(&apos;doc-i&apos;)</span><br><span class="line">#或正则式</span><br><span class="line">re.search(&apos;doc-i(.*).shtml&apos;, newsurl).group(1)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#整理评论</span><br><span class="line">commentURL = &apos;http://comment5.news.sina.com.cn/page/info?version=1&amp;format=json&amp;\</span><br><span class="line">channel=gn&amp;newsid=comos-&#123;&#125;&amp;group=undefined&amp;compress=0&amp;ie=utf-8&amp;oe=utf-8&amp;page=1&amp;\</span><br><span class="line">page_size=3&apos;</span><br><span class="line">import re</span><br><span class="line">import json</span><br><span class="line">def getCommentCount(newsurl):</span><br><span class="line">    newsid = re.search(&apos;doc-i(.*).shtml&apos;, newsurl).group(1)</span><br><span class="line">    comments = requests.get(commentURL.format(newsid))</span><br><span class="line">    jd = json.loads(comments.text)</span><br><span class="line">    return jd[&apos;result&apos;][&apos;count&apos;][&apos;total&apos;]</span><br><span class="line"></span><br><span class="line">#测试</span><br><span class="line">news = &apos;http://news.sina.com.cn/c/2018-07-31/doc-ihhacrcc9897484.shtml&apos;</span><br><span class="line">getCommentCount(news)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#单个新闻信息</span><br><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line">def getNewsDetail(newsurl):</span><br><span class="line">    result = &#123;&#125;</span><br><span class="line">    res = requests.get(newsurl)</span><br><span class="line">    res.encoding = &apos;utf-8&apos;</span><br><span class="line">    soup = BeautifulSoup(res.text, &apos;html.parser&apos;)</span><br><span class="line">    result[&apos;title&apos;] = soup.select(&apos;.main-title&apos;)[0].text</span><br><span class="line">    result[&apos;newssource&apos;] = soup.select(&apos;.date-source&apos;)[0].a.text</span><br><span class="line">    date = soup.select(&apos;.date-source&apos;)[0].span.text</span><br><span class="line">    result[&apos;dt&apos;] = datetime.strptime(date, &apos;%Y年%m月%d日 %H:%M&apos;) #str转time</span><br><span class="line">    result[&apos;article&apos;] = &apos; &apos;.join([p.text.strip() for p in soup.select(&apos;#article p&apos;)[:-1]])</span><br><span class="line">    result[&apos;editor&apos;] = soup.select(&apos;.show_author&apos;)[0].text.lstrip(&apos;责任编辑：&apos;)</span><br><span class="line">    result[&apos;comments&apos;] = getCommentCount(newsurl)</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">#test</span><br><span class="line">news = &apos;http://news.sina.com.cn/c/nd/2018-07-24/doc-ihftenhz7547208.shtml&apos;</span><br><span class="line">getNewsDetail(news)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#剖析分页信息</span><br><span class="line">import requests</span><br><span class="line">import json</span><br><span class="line">res = requests.get(&apos;http://api.roll.news.sina.com.cn/zt_list?channel=news&amp;cat_1=gnxw&amp;\</span><br><span class="line">cat_2==gdxw1||=gatxw||=zs-pl||=mtjj&amp;level==1||=2&amp;show_ext=1&amp;show_all=1&amp;show_num=22&amp;tag=1&amp;\</span><br><span class="line">format=json&amp;page=6&amp;callback=newsloadercallback&amp;_=1533026268219&apos;)</span><br><span class="line">jd = json.loads(res.text.lstrip(&apos;  newsloadercallback(&apos;).rstrip(&apos;);&apos;))</span><br><span class="line">#jd</span><br><span class="line">for ent in jd[&apos;result&apos;][&apos;data&apos;]:</span><br><span class="line">    print(ent[&apos;url&apos;])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#建立剖析清单链接函式</span><br><span class="line">def parseListLinks(url):</span><br><span class="line">    newsdetails = []</span><br><span class="line">    res = requests.get(url)</span><br><span class="line">    jd = json.loads(res.text.lstrip(&apos;  newsloadercallback(&apos;).rstrip(&apos;);&apos;))</span><br><span class="line">    for ent in jd[&apos;result&apos;][&apos;data&apos;]:</span><br><span class="line">        </span><br><span class="line">        try:</span><br><span class="line">            print(ent[&apos;url&apos;])</span><br><span class="line">            newsdetails.append(getNewsDetail(ent[&apos;url&apos;]))</span><br><span class="line">        except AttributeError:</span><br><span class="line">            pass</span><br><span class="line"></span><br><span class="line">    return newsdetails</span><br><span class="line"></span><br><span class="line">#test </span><br><span class="line">url = &apos;http://api.roll.news.sina.com.cn/zt_list?channel=news&amp;cat_1=gnxw&amp;\</span><br><span class="line">cat_2==gdxw1||=gatxw||=zs-pl||=mtjj&amp;level==1||=2&amp;show_ext=1&amp;show_all=1&amp;show_num=22&amp;tag=1&amp;\</span><br><span class="line">format=json&amp;page=6&amp;callback=newsloadercallback&amp;_=1533026268219&apos;</span><br><span class="line">parseListLinks(url)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#使用for循环产生多页连结&amp;批次抓取每页新闻内文</span><br><span class="line">def createUrl(num):</span><br><span class="line">    url = &apos;http://api.roll.news.sina.com.cn/zt_list?channel=news&amp;cat_1=gnxw&amp;\</span><br><span class="line">cat_2==gdxw1||=gatxw||=zs-pl||=mtjj&amp;level==1||=2&amp;show_ext=1&amp;show_all=1&amp;show_num=22&amp;tag=1&amp;\</span><br><span class="line">format=json&amp;page=&#123;&#125;&apos;#使用&#123;&#125;代替</span><br><span class="line">    news_total = []</span><br><span class="line">    for i in range(1, num):</span><br><span class="line">        newsurl = url.format(i)</span><br><span class="line">        print(newsurl)</span><br><span class="line">        newsary = parseListLinks(newsurl)</span><br><span class="line">        news_total.extend(newsary)</span><br><span class="line">    return news_total</span><br><span class="line">#test</span><br><span class="line">news_total = createUrl(3)</span><br><span class="line">#print(news_total)</span><br><span class="line">len(news_total)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#pandas 整理资料</span><br><span class="line">import pandas</span><br><span class="line">df = pandas.DataFrame(news_total)</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#保存数据</span><br><span class="line">df.to_csv(&apos;news.csv&apos;)#到csv</span><br><span class="line">import sqlite3 #到sql</span><br><span class="line">with sqlite3.connect(&apos;news.sqlite&apos;) as db:</span><br><span class="line">    df.to_sql(&apos;news&apos;, con = db)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#操作sql</span><br><span class="line">import sqlite3</span><br><span class="line">with sqlite3.connect(&apos;news.sqlite&apos;) as db:</span><br><span class="line">    df2 = pandas.read_sql_query(&apos;SELECT * FROM news&apos;, con = db)</span><br><span class="line">df2.head()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="数据挖掘" scheme="https://paradoxallen.github.io/categories/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="python" scheme="https://paradoxallen.github.io/tags/python/"/>
    
      <category term="爬虫" scheme="https://paradoxallen.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python常用第三方模块</title>
    <link href="https://paradoxallen.github.io/57576/"/>
    <id>https://paradoxallen.github.io/57576/</id>
    <published>2017-11-17T16:00:00.000Z</published>
    <updated>2018-07-21T05:56:19.152Z</updated>
    
    <content type="html"><![CDATA[<p>除了内建的模块外，Python还有大量的第三方模块。</p><p>基本上，所有的第三方模块都会在PyPI - the Python Package Index上注册，只要找到对应的模块名字，即可用pip安装。</p><p>此外，在安装第三方模块一节中，我们强烈推荐安装Anaconda，安装后，数十个常用的第三方模块就已经就绪，不用pip手动安装。</p><p>这里将介绍常用的第三方模块。</p><a id="more"></a><hr><h2 id="Pillow"><a href="#Pillow" class="headerlink" title="Pillow"></a>Pillow</h2><p>PIL：Python Imaging Library，已经是Python平台事实上的图像处理标准库了。PIL功能非常强大，但API却非常简单易用。</p><p>由于PIL仅支持到Python 2.7，加上年久失修，于是一群志愿者在PIL的基础上创建了兼容的版本，名字叫Pillow，支持最新Python 3.x，又加入了许多新特性，因此，我们可以直接安装使用Pillow。</p><h3 id="安装Pillow"><a href="#安装Pillow" class="headerlink" title="安装Pillow"></a>安装Pillow</h3><p>如果安装了Anaconda，Pillow就已经可用了。否则，需要在命令行下通过pip安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install pillow</span><br></pre></td></tr></table></figure></p><p>如果遇到Permission denied安装失败，请加上sudo重试。</p><h3 id="操作图像"><a href="#操作图像" class="headerlink" title="操作图像"></a>操作图像</h3><p>来看看最常见的图像缩放操作，只需三四行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line"># 打开一个jpg图像文件，注意是当前路径:</span><br><span class="line">im = Image.open(&apos;test.jpg&apos;)</span><br><span class="line"># 获得图像尺寸:</span><br><span class="line">w, h = im.size</span><br><span class="line">print(&apos;Original image size: %sx%s&apos; % (w, h))</span><br><span class="line"># 缩放到50%:</span><br><span class="line">im.thumbnail((w//2, h//2))</span><br><span class="line">print(&apos;Resize image to: %sx%s&apos; % (w//2, h//2))</span><br><span class="line"># 把缩放后的图像用jpeg格式保存:</span><br><span class="line">im.save(&apos;thumbnail.jpg&apos;, &apos;jpeg&apos;)</span><br></pre></td></tr></table></figure></p><p>其他功能如切片、旋转、滤镜、输出文字、调色板等一应俱全。</p><p>比如，模糊效果也只需几行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image, ImageFilter</span><br><span class="line"></span><br><span class="line"># 打开一个jpg图像文件，注意是当前路径:</span><br><span class="line">im = Image.open(&apos;test.jpg&apos;)</span><br><span class="line"># 应用模糊滤镜:</span><br><span class="line">im2 = im.filter(ImageFilter.BLUR)</span><br><span class="line">im2.save(&apos;blur.jpg&apos;, &apos;jpeg&apos;)</span><br></pre></td></tr></table></figure></p><p>PIL的ImageDraw提供了一系列绘图方法，让我们可以直接绘图。比如要生成字母验证码图片：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image, ImageDraw, ImageFont, ImageFilter</span><br><span class="line"></span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line"># 随机字母:</span><br><span class="line">def rndChar():</span><br><span class="line">    return chr(random.randint(65, 90))</span><br><span class="line"></span><br><span class="line"># 随机颜色1:</span><br><span class="line">def rndColor():</span><br><span class="line">    return (random.randint(64, 255), random.randint(64, 255), random.randint(64, 255))</span><br><span class="line"></span><br><span class="line"># 随机颜色2:</span><br><span class="line">def rndColor2():</span><br><span class="line">    return (random.randint(32, 127), random.randint(32, 127), random.randint(32, 127))</span><br><span class="line"></span><br><span class="line"># 240 x 60:</span><br><span class="line">width = 60 * 4</span><br><span class="line">height = 60</span><br><span class="line">image = Image.new(&apos;RGB&apos;, (width, height), (255, 255, 255))</span><br><span class="line"># 创建Font对象:</span><br><span class="line">font = ImageFont.truetype(&apos;Arial.ttf&apos;, 36)</span><br><span class="line"># 创建Draw对象:</span><br><span class="line">draw = ImageDraw.Draw(image)</span><br><span class="line"># 填充每个像素:</span><br><span class="line">for x in range(width):</span><br><span class="line">    for y in range(height):</span><br><span class="line">        draw.point((x, y), fill=rndColor())</span><br><span class="line"># 输出文字:</span><br><span class="line">for t in range(4):</span><br><span class="line">    draw.text((60 * t + 10, 10), rndChar(), font=font, fill=rndColor2())</span><br><span class="line"># 模糊:</span><br><span class="line">image = image.filter(ImageFilter.BLUR)</span><br><span class="line">image.save(&apos;code.jpg&apos;, &apos;jpeg&apos;)</span><br></pre></td></tr></table></figure></p><p>我们用随机颜色填充背景，再画上文字，最后对图像进行模糊，得到验证码图片如下：</p><p>如果运行的时候报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IOError: cannot open resource</span><br></pre></td></tr></table></figure></p><p>这是因为PIL无法定位到字体文件的位置，可以根据操作系统提供绝对路径，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;/Library/Fonts/Arial.ttf&apos;</span><br></pre></td></tr></table></figure></p><p>要详细了解PIL的强大功能，请请参考Pillow官方文档：</p><p><a href="https://pillow.readthedocs.org/" target="_blank" rel="noopener">https://pillow.readthedocs.org/</a></p><p><strong>小结</strong><br>PIL提供了操作图像的强大功能，可以通过简单的代码完成复杂的图像处理。</p><hr><h2 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h2><p>我们已经讲解了Python内置的urllib模块，用于访问网络资源。但是，它用起来比较麻烦，而且，缺少很多实用的高级功能。</p><p>更好的方案是使用requests。它是一个Python第三方库，处理URL资源特别方便。</p><h3 id="安装requests"><a href="#安装requests" class="headerlink" title="安装requests"></a>安装requests</h3><p>如果安装了Anaconda，requests就已经可用了。否则，需要在命令行下通过pip安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install requests</span><br></pre></td></tr></table></figure></p><p>如果遇到Permission denied安装失败，请加上sudo重试。</p><h3 id="使用requests"><a href="#使用requests" class="headerlink" title="使用requests"></a>使用requests</h3><p>要通过GET访问一个页面，只需要几行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import requests</span><br><span class="line">&gt;&gt;&gt; r = requests.get(&apos;https://www.douban.com/&apos;) # 豆瓣首页</span><br><span class="line">&gt;&gt;&gt; r.status_code</span><br><span class="line">200</span><br><span class="line">&gt;&gt;&gt; r.text</span><br><span class="line">r.text</span><br><span class="line">&apos;&lt;!DOCTYPE HTML&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta name=&quot;description&quot; content=&quot;提供图书、电影、音乐唱片的推荐、评论和...&apos;</span><br></pre></td></tr></table></figure></p><p>对于带参数的URL，传入一个dict作为params参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = requests.get(&apos;https://www.douban.com/search&apos;, params=&#123;&apos;q&apos;: &apos;python&apos;, &apos;cat&apos;: &apos;1001&apos;&#125;)</span><br><span class="line">&gt;&gt;&gt; r.url # 实际请求的URL</span><br><span class="line">&apos;https://www.douban.com/search?q=python&amp;cat=1001&apos;</span><br></pre></td></tr></table></figure></p><p>requests自动检测编码，可以使用encoding属性查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r.encoding</span><br><span class="line">&apos;utf-8&apos;</span><br></pre></td></tr></table></figure></p><p>无论响应是文本还是二进制内容，我们都可以用content属性获得bytes对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r.content</span><br><span class="line">b&apos;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;\n...&apos;</span><br></pre></td></tr></table></figure></p><p>requests的方便之处还在于，对于特定类型的响应，例如JSON，可以直接获取：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = requests.get(&apos;https://query.yahooapis.com/v1/public/yql?q=select%20*%20from%20weather.forecast%20where%20woeid%20%3D%202151330&amp;format=json&apos;)</span><br><span class="line">&gt;&gt;&gt; r.json()</span><br><span class="line">&#123;&apos;query&apos;: &#123;&apos;count&apos;: 1, &apos;created&apos;: &apos;2017-11-17T07:14:12Z&apos;, ...</span><br></pre></td></tr></table></figure></p><p>需要传入HTTP Header时，我们传入一个dict作为headers参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = requests.get(&apos;https://www.douban.com/&apos;, headers=&#123;&apos;User-Agent&apos;: &apos;Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit&apos;&#125;)</span><br><span class="line">&gt;&gt;&gt; r.text</span><br><span class="line">&apos;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&quot;UTF-8&quot;&gt;\n &lt;title&gt;豆瓣(手机版)&lt;/title&gt;...&apos;</span><br></pre></td></tr></table></figure></p><p>要发送POST请求，只需要把get()方法变成post()，然后传入data参数作为POST请求的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = requests.post(&apos;https://accounts.douban.com/login&apos;, data=&#123;&apos;form_email&apos;: &apos;abc@example.com&apos;, &apos;form_password&apos;: &apos;123456&apos;&#125;)</span><br></pre></td></tr></table></figure></p><p>requests默认使用application/x-www-form-urlencoded对POST数据编码。如果要传递JSON数据，可以直接传入json参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">params = &#123;&apos;key&apos;: &apos;value&apos;&#125;</span><br><span class="line">r = requests.post(url, json=params) # 内部自动序列化为JSON</span><br></pre></td></tr></table></figure></p><p>类似的，上传文件需要更复杂的编码格式，但是requests把它简化成files参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; upload_files = &#123;&apos;file&apos;: open(&apos;report.xls&apos;, &apos;rb&apos;)&#125;</span><br><span class="line">&gt;&gt;&gt; r = requests.post(url, files=upload_files)</span><br></pre></td></tr></table></figure></p><p>在读取文件时，注意务必使用’rb’即二进制模式读取，这样获取的bytes长度才是文件的长度。</p><p>把post()方法替换为put()，delete()等，就可以以PUT或DELETE方式请求资源。</p><p>除了能轻松获取响应内容外，requests对获取HTTP响应的其他信息也非常简单。例如，获取响应头：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r.headers</span><br><span class="line">&#123;Content-Type&apos;: &apos;text/html; charset=utf-8&apos;, &apos;Transfer-Encoding&apos;: &apos;chunked&apos;, &apos;Content-Encoding&apos;: &apos;gzip&apos;, ...&#125;</span><br><span class="line">&gt;&gt;&gt; r.headers[&apos;Content-Type&apos;]</span><br><span class="line">&apos;text/html; charset=utf-8&apos;</span><br></pre></td></tr></table></figure></p><p>requests对Cookie做了特殊处理，使得我们不必解析Cookie就可以轻松获取指定的Cookie：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r.cookies[&apos;ts&apos;]</span><br><span class="line">&apos;example_cookie_12345&apos;</span><br></pre></td></tr></table></figure></p><p>要在请求中传入Cookie，只需准备一个dict传入cookies参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; cs = &#123;&apos;token&apos;: &apos;12345&apos;, &apos;status&apos;: &apos;working&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; r = requests.get(url, cookies=cs)</span><br></pre></td></tr></table></figure></p><p>最后，要指定超时，传入以秒为单位的timeout参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r = requests.get(url, timeout=2.5) # 2.5秒后超时</span><br></pre></td></tr></table></figure></p><p><strong>小结</strong><br>用requests获取URL资源，就是这么简单！</p><hr><h2 id="chardet"><a href="#chardet" class="headerlink" title="chardet"></a>chardet</h2><p>字符串编码一直是令人非常头疼的问题，尤其是我们在处理一些不规范的第三方网页的时候。虽然Python提供了Unicode表示的str和bytes两种数据类型，并且可以通过encode()和decode()方法转换，但是，在不知道编码的情况下，对bytes做decode()不好做。</p><p>对于未知编码的bytes，要把它转换成str，需要先“猜测”编码。猜测的方式是先收集各种编码的特征字符，根据特征字符判断，就能有很大概率“猜对”。</p><p>当然，我们肯定不能从头自己写这个检测编码的功能，这样做费时费力。chardet这个第三方库正好就派上了用场。用它来检测编码，简单易用。</p><h3 id="安装chardet"><a href="#安装chardet" class="headerlink" title="安装chardet"></a>安装chardet</h3><p>如果安装了Anaconda，chardet就已经可用了。否则，需要在命令行下通过pip安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install chardet</span><br></pre></td></tr></table></figure></p><p>如果遇到Permission denied安装失败，请加上sudo重试。</p><h3 id="使用chardet"><a href="#使用chardet" class="headerlink" title="使用chardet"></a>使用chardet</h3><p>当我们拿到一个bytes时，就可以对其检测编码。用chardet检测编码，只需要一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; chardet.detect(b&apos;Hello, world!&apos;)</span><br><span class="line">&#123;&apos;encoding&apos;: &apos;ascii&apos;, &apos;confidence&apos;: 1.0, &apos;language&apos;: &apos;&apos;&#125;</span><br></pre></td></tr></table></figure></p><p>检测出的编码是ascii，注意到还有个confidence字段，表示检测的概率是1.0（即100%）。</p><p>我们来试试检测GBK编码的中文：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; data = &apos;离离原上草，一岁一枯荣&apos;.encode(&apos;gbk&apos;)</span><br><span class="line">&gt;&gt;&gt; chardet.detect(data)</span><br><span class="line">&#123;&apos;encoding&apos;: &apos;GB2312&apos;, &apos;confidence&apos;: 0.7407407407407407, &apos;language&apos;: &apos;Chinese&apos;&#125;</span><br></pre></td></tr></table></figure></p><p>检测的编码是GB2312，注意到GBK是GB2312的超集，两者是同一种编码，检测正确的概率是74%，language字段指出的语言是’Chinese’。</p><p>对UTF-8编码进行检测：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; data = &apos;离离原上草，一岁一枯荣&apos;.encode(&apos;utf-8&apos;)</span><br><span class="line">&gt;&gt;&gt; chardet.detect(data)</span><br><span class="line">&#123;&apos;encoding&apos;: &apos;utf-8&apos;, &apos;confidence&apos;: 0.99, &apos;language&apos;: &apos;&apos;&#125;</span><br></pre></td></tr></table></figure></p><p>我们再试试对日文进行检测：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; data = &apos;最新の主要ニュース&apos;.encode(&apos;euc-jp&apos;)</span><br><span class="line">&gt;&gt;&gt; chardet.detect(data)</span><br><span class="line">&#123;&apos;encoding&apos;: &apos;EUC-JP&apos;, &apos;confidence&apos;: 0.99, &apos;language&apos;: &apos;Japanese&apos;&#125;</span><br></pre></td></tr></table></figure></p><p>可见，用chardet检测编码，使用简单。获取到编码后，再转换为str，就可以方便后续处理。</p><p>chardet支持检测的编码列表请参考官方文档Supported encodings。</p><p><strong>小结</strong><br>使用chardet检测编码非常容易，chardet支持检测中文、日文、韩文等多种语言。</p><hr><h2 id="psutil"><a href="#psutil" class="headerlink" title="psutil"></a>psutil</h2><p>用Python来编写脚本简化日常的运维工作是Python的一个重要用途。在Linux下，有许多系统命令可以让我们时刻监控系统运行的状态，如ps，top，free等等。要获取这些系统信息，Python可以通过subprocess模块调用并获取结果。但这样做显得很麻烦，尤其是要写很多解析代码。</p><p>在Python中获取系统信息的另一个好办法是使用psutil这个第三方模块。顾名思义，psutil = process and system utilities，它不仅可以通过一两行代码实现系统监控，还可以跨平台使用，支持Linux／UNIX／OSX／Windows等，是系统管理员和运维小伙伴不可或缺的必备模块。</p><h3 id="安装psutil"><a href="#安装psutil" class="headerlink" title="安装psutil"></a>安装psutil</h3><p>如果安装了Anaconda，psutil就已经可用了。否则，需要在命令行下通过pip安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install psutil</span><br></pre></td></tr></table></figure></p><p>如果遇到Permission denied安装失败，请加上sudo重试。</p><h3 id="获取CPU信息"><a href="#获取CPU信息" class="headerlink" title="获取CPU信息"></a>获取CPU信息</h3><p>我们先来获取CPU的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import psutil</span><br><span class="line">&gt;&gt;&gt; psutil.cpu_count() # CPU逻辑数量</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; psutil.cpu_count(logical=False) # CPU物理核心</span><br><span class="line">2</span><br><span class="line"># 2说明是双核超线程, 4则是4核非超线程</span><br></pre></td></tr></table></figure></p><p>统计CPU的用户／系统／空闲时间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; psutil.cpu_times()</span><br><span class="line">scputimes(user=10963.31, nice=0.0, system=5138.67, idle=356102.45)</span><br></pre></td></tr></table></figure></p><p>再实现类似top命令的CPU使用率，每秒刷新一次，累计10次：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for x in range(10):</span><br><span class="line">...     psutil.cpu_percent(interval=1, percpu=True)</span><br><span class="line">... </span><br><span class="line">[14.0, 4.0, 4.0, 4.0]</span><br><span class="line">[12.0, 3.0, 4.0, 3.0]</span><br><span class="line">[8.0, 4.0, 3.0, 4.0]</span><br><span class="line">[12.0, 3.0, 3.0, 3.0]</span><br><span class="line">[18.8, 5.1, 5.9, 5.0]</span><br><span class="line">[10.9, 5.0, 4.0, 3.0]</span><br><span class="line">[12.0, 5.0, 4.0, 5.0]</span><br><span class="line">[15.0, 5.0, 4.0, 4.0]</span><br><span class="line">[19.0, 5.0, 5.0, 4.0]</span><br><span class="line">[9.0, 3.0, 2.0, 3.0]</span><br></pre></td></tr></table></figure></p><h3 id="获取内存信息"><a href="#获取内存信息" class="headerlink" title="获取内存信息"></a>获取内存信息</h3><p>使用psutil获取物理内存和交换内存信息，分别使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; psutil.virtual_memory()</span><br><span class="line">svmem(total=8589934592, available=2866520064, percent=66.6, used=7201386496, free=216178688, active=3342192640, inactive=2650341376, wired=1208852480)</span><br><span class="line">&gt;&gt;&gt; psutil.swap_memory()</span><br><span class="line">sswap(total=1073741824, used=150732800, free=923009024, percent=14.0, sin=10705981440, sout=40353792)</span><br></pre></td></tr></table></figure></p><p>返回的是字节为单位的整数，可以看到，总内存大小是8589934592 = 8 GB，已用7201386496 = 6.7 GB，使用了66.6%。</p><p>而交换区大小是1073741824 = 1 GB。</p><h3 id="获取磁盘信息"><a href="#获取磁盘信息" class="headerlink" title="获取磁盘信息"></a>获取磁盘信息</h3><p>可以通过psutil获取磁盘分区、磁盘使用率和磁盘IO信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; psutil.disk_partitions() # 磁盘分区信息</span><br><span class="line">[sdiskpart(device=&apos;/dev/disk1&apos;, mountpoint=&apos;/&apos;, fstype=&apos;hfs&apos;, opts=&apos;rw,local,rootfs,dovolfs,journaled,multilabel&apos;)]</span><br><span class="line">&gt;&gt;&gt; psutil.disk_usage(&apos;/&apos;) # 磁盘使用情况</span><br><span class="line">sdiskusage(total=998982549504, used=390880133120, free=607840272384, percent=39.1)</span><br><span class="line">&gt;&gt;&gt; psutil.disk_io_counters() # 磁盘IO</span><br><span class="line">sdiskio(read_count=988513, write_count=274457, read_bytes=14856830464, write_bytes=17509420032, read_time=2228966, write_time=1618405)</span><br></pre></td></tr></table></figure></p><p>可以看到，磁盘’/‘的总容量是998982549504 = 930 GB，使用了39.1%。文件格式是HFS，opts中包含rw表示可读写，journaled表示支持日志。</p><h3 id="获取网络信息"><a href="#获取网络信息" class="headerlink" title="获取网络信息"></a>获取网络信息</h3><p>psutil可以获取网络接口和网络连接信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; psutil.net_io_counters() # 获取网络读写字节／包的个数</span><br><span class="line">snetio(bytes_sent=3885744870, bytes_recv=10357676702, packets_sent=10613069, packets_recv=10423357, errin=0, errout=0, dropin=0, dropout=0)</span><br><span class="line">&gt;&gt;&gt; psutil.net_if_addrs() # 获取网络接口信息</span><br><span class="line">&#123;</span><br><span class="line">  &apos;lo0&apos;: [snic(family=&lt;AddressFamily.AF_INET: 2&gt;, address=&apos;127.0.0.1&apos;, netmask=&apos;255.0.0.0&apos;), ...],</span><br><span class="line">  &apos;en1&apos;: [snic(family=&lt;AddressFamily.AF_INET: 2&gt;, address=&apos;10.0.1.80&apos;, netmask=&apos;255.255.255.0&apos;), ...],</span><br><span class="line">  &apos;en0&apos;: [...],</span><br><span class="line">  &apos;en2&apos;: [...],</span><br><span class="line">  &apos;bridge0&apos;: [...]</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt; psutil.net_if_stats() # 获取网络接口状态</span><br><span class="line">&#123;</span><br><span class="line">  &apos;lo0&apos;: snicstats(isup=True, duplex=&lt;NicDuplex.NIC_DUPLEX_UNKNOWN: 0&gt;, speed=0, mtu=16384),</span><br><span class="line">  &apos;en0&apos;: snicstats(isup=True, duplex=&lt;NicDuplex.NIC_DUPLEX_UNKNOWN: 0&gt;, speed=0, mtu=1500),</span><br><span class="line">  &apos;en1&apos;: snicstats(...),</span><br><span class="line">  &apos;en2&apos;: snicstats(...),</span><br><span class="line">  &apos;bridge0&apos;: snicstats(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要获取当前网络连接信息，使用net_connections()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; psutil.net_connections()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">PermissionError: [Errno 1] Operation not permitted</span><br><span class="line"></span><br><span class="line">During handling of the above exception, another exception occurred:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">psutil.AccessDenied: psutil.AccessDenied (pid=3847)</span><br></pre></td></tr></table></figure></p><p>你可能会得到一个AccessDenied错误，原因是psutil获取信息也是要走系统接口，而获取网络连接信息需要root权限，这种情况下，可以退出Python交互环境，用sudo重新启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ sudo python3</span><br><span class="line">Password: ******</span><br><span class="line">Python 3.6.3 ... on darwin</span><br><span class="line">Type &quot;help&quot;, ... for more information.</span><br><span class="line">&gt;&gt;&gt; import psutil</span><br><span class="line">&gt;&gt;&gt; psutil.net_connections()</span><br><span class="line">[</span><br><span class="line">    sconn(fd=83, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, laddr=addr(ip=&apos;::127.0.0.1&apos;, port=62911), raddr=addr(ip=&apos;::127.0.0.1&apos;, port=3306), status=&apos;ESTABLISHED&apos;, pid=3725),</span><br><span class="line">    sconn(fd=84, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, laddr=addr(ip=&apos;::127.0.0.1&apos;, port=62905), raddr=addr(ip=&apos;::127.0.0.1&apos;, port=3306), status=&apos;ESTABLISHED&apos;, pid=3725),</span><br><span class="line">    sconn(fd=93, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, laddr=addr(ip=&apos;::&apos;, port=8080), raddr=(), status=&apos;LISTEN&apos;, pid=3725),</span><br><span class="line">    sconn(fd=103, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, laddr=addr(ip=&apos;::127.0.0.1&apos;, port=62918), raddr=addr(ip=&apos;::127.0.0.1&apos;, port=3306), status=&apos;ESTABLISHED&apos;, pid=3725),</span><br><span class="line">    sconn(fd=105, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, ..., pid=3725),</span><br><span class="line">    sconn(fd=106, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, ..., pid=3725),</span><br><span class="line">    sconn(fd=107, family=&lt;AddressFamily.AF_INET6: 30&gt;, type=1, ..., pid=3725),</span><br><span class="line">    ...</span><br><span class="line">    sconn(fd=27, family=&lt;AddressFamily.AF_INET: 2&gt;, type=2, ..., pid=1)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h3 id="获取进程信息"><a href="#获取进程信息" class="headerlink" title="获取进程信息"></a>获取进程信息</h3><p>通过psutil可以获取到所有进程的详细信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; psutil.pids() # 所有进程ID</span><br><span class="line">[3865, 3864, 3863, 3856, 3855, 3853, 3776, ..., 45, 44, 1, 0]</span><br><span class="line">&gt;&gt;&gt; p = psutil.Process(3776) # 获取指定进程ID=3776，其实就是当前Python交互环境</span><br><span class="line">&gt;&gt;&gt; p.name() # 进程名称</span><br><span class="line">&apos;python3.6&apos;</span><br><span class="line">&gt;&gt;&gt; p.exe() # 进程exe路径</span><br><span class="line">&apos;/Users/michael/anaconda3/bin/python3.6&apos;</span><br><span class="line">&gt;&gt;&gt; p.cwd() # 进程工作目录</span><br><span class="line">&apos;/Users/michael&apos;</span><br><span class="line">&gt;&gt;&gt; p.cmdline() # 进程启动的命令行</span><br><span class="line">[&apos;python3&apos;]</span><br><span class="line">&gt;&gt;&gt; p.ppid() # 父进程ID</span><br><span class="line">3765</span><br><span class="line">&gt;&gt;&gt; p.parent() # 父进程</span><br><span class="line">&lt;psutil.Process(pid=3765, name=&apos;bash&apos;) at 4503144040&gt;</span><br><span class="line">&gt;&gt;&gt; p.children() # 子进程列表</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt; p.status() # 进程状态</span><br><span class="line">&apos;running&apos;</span><br><span class="line">&gt;&gt;&gt; p.username() # 进程用户名</span><br><span class="line">&apos;michael&apos;</span><br><span class="line">&gt;&gt;&gt; p.create_time() # 进程创建时间</span><br><span class="line">1511052731.120333</span><br><span class="line">&gt;&gt;&gt; p.terminal() # 进程终端</span><br><span class="line">&apos;/dev/ttys002&apos;</span><br><span class="line">&gt;&gt;&gt; p.cpu_times() # 进程使用的CPU时间</span><br><span class="line">pcputimes(user=0.081150144, system=0.053269812, children_user=0.0, children_system=0.0)</span><br><span class="line">&gt;&gt;&gt; p.memory_info() # 进程使用的内存</span><br><span class="line">pmem(rss=8310784, vms=2481725440, pfaults=3207, pageins=18)</span><br><span class="line">&gt;&gt;&gt; p.open_files() # 进程打开的文件</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt; p.connections() # 进程相关网络连接</span><br><span class="line">[]</span><br><span class="line">&gt;&gt;&gt; p.num_threads() # 进程的线程数量</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; p.threads() # 所有线程信息</span><br><span class="line">[pthread(id=1, user_time=0.090318, system_time=0.062736)]</span><br><span class="line">&gt;&gt;&gt; p.environ() # 进程环境变量</span><br><span class="line">&#123;&apos;SHELL&apos;: &apos;/bin/bash&apos;, &apos;PATH&apos;: &apos;/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:...&apos;, &apos;PWD&apos;: &apos;/Users/michael&apos;, &apos;LANG&apos;: &apos;zh_CN.UTF-8&apos;, ...&#125;</span><br><span class="line">&gt;&gt;&gt; p.terminate() # 结束进程</span><br><span class="line">Terminated: 15 &lt;-- 自己把自己结束了</span><br></pre></td></tr></table></figure></p><p>和获取网络连接类似，获取一个root用户的进程需要root权限，启动Python交互环境或者.py文件时，需要sudo权限。</p><p>psutil还提供了一个test()函数，可以模拟出ps命令的效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ sudo python3</span><br><span class="line">Password: ******</span><br><span class="line">Python 3.6.3 ... on darwin</span><br><span class="line">Type &quot;help&quot;, ... for more information.</span><br><span class="line">&gt;&gt;&gt; import psutil</span><br><span class="line">&gt;&gt;&gt; psutil.test()</span><br><span class="line">USER         PID %MEM     VSZ     RSS TTY           START    TIME  COMMAND</span><br><span class="line">root           0 24.0 74270628 2016380 ?             Nov18   40:51  kernel_task</span><br><span class="line">root           1  0.1 2494140    9484 ?             Nov18   01:39  launchd</span><br><span class="line">root          44  0.4 2519872   36404 ?             Nov18   02:02  UserEventAgent</span><br><span class="line">root          45    ? 2474032    1516 ?             Nov18   00:14  syslogd</span><br><span class="line">root          47  0.1 2504768    8912 ?             Nov18   00:03  kextd</span><br><span class="line">root          48  0.1 2505544    4720 ?             Nov18   00:19  fseventsd</span><br><span class="line">_appleeven    52  0.1 2499748    5024 ?             Nov18   00:00  appleeventsd</span><br><span class="line">root          53  0.1 2500592    6132 ?             Nov18   00:02  configd</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p><strong>小结</strong><br>psutil使得Python程序获取系统信息变得易如反掌。</p><p>psutil还可以获取用户信息、Windows服务等很多有用的系统信息，具体请参考psutil的官网：<a href="https://github.com/giampaolo/psutil" target="_blank" rel="noopener">https://github.com/giampaolo/psutil</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;除了内建的模块外，Python还有大量的第三方模块。&lt;/p&gt;
&lt;p&gt;基本上，所有的第三方模块都会在PyPI - the Python Package Index上注册，只要找到对应的模块名字，即可用pip安装。&lt;/p&gt;
&lt;p&gt;此外，在安装第三方模块一节中，我们强烈推荐安装Anaconda，安装后，数十个常用的第三方模块就已经就绪，不用pip手动安装。&lt;/p&gt;
&lt;p&gt;这里将介绍常用的第三方模块。&lt;/p&gt;
    
    </summary>
    
      <category term="编程相关" scheme="https://paradoxallen.github.io/categories/%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="python" scheme="https://paradoxallen.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python常用内建模块</title>
    <link href="https://paradoxallen.github.io/32546/"/>
    <id>https://paradoxallen.github.io/32546/</id>
    <published>2017-11-15T16:00:00.000Z</published>
    <updated>2018-07-21T03:56:25.617Z</updated>
    
    <content type="html"><![CDATA[<p>Python之所以自称“batteries included”，就是因为内置了许多非常有用的模块，无需额外安装和配置，即可直接使用。</p><a id="more"></a><hr><h2 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h2><p>datetime是Python处理日期和时间的标准库。</p><h3 id="获取当前日期和时间"><a href="#获取当前日期和时间" class="headerlink" title="获取当前日期和时间"></a>获取当前日期和时间</h3><p>我们先看如何获取当前日期和时间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from datetime import datetime</span><br><span class="line">&gt;&gt;&gt; now = datetime.now() # 获取当前datetime</span><br><span class="line">&gt;&gt;&gt; print(now)</span><br><span class="line">2015-05-18 16:28:07.198690</span><br><span class="line">&gt;&gt;&gt; print(type(now))</span><br><span class="line">&lt;class &apos;datetime.datetime&apos;&gt;</span><br></pre></td></tr></table></figure></p><p>注意到<code>datetime</code>是模块，<code>datetime</code>模块还包含一个<code>datetime</code>类，通过<code>from datetime import datetime</code>导入的才是<code>datetime</code>这个类。</p><p>如果仅导入<code>import datetime</code>，则必须引用全名<code>datetime.datetime</code>。</p><p><code>datetime.now()</code>返回当前日期和时间，其类型是<code>datetime</code>。</p><h3 id="获取指定日期和时间"><a href="#获取指定日期和时间" class="headerlink" title="获取指定日期和时间"></a>获取指定日期和时间</h3><p>要指定某个日期和时间，我们直接用参数构造一个<code>datetime</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from datetime import datetime</span><br><span class="line">&gt;&gt;&gt; dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime</span><br><span class="line">&gt;&gt;&gt; print(dt)</span><br><span class="line">2015-04-19 12:20:00</span><br></pre></td></tr></table></figure></p><h3 id="datetime转换为timestamp"><a href="#datetime转换为timestamp" class="headerlink" title="datetime转换为timestamp"></a>datetime转换为timestamp</h3><p>在计算机中，时间实际上是用数字表示的。我们把1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time，记为<code>0</code>（1970年以前的时间timestamp为负数），当前时间就是相对于epoch time的秒数，称为timestamp。</p><p>你可以认为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timestamp = 0 = 1970-1-1 00:00:00 UTC+0:00</span><br></pre></td></tr></table></figure></p><p>对应的北京时间是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timestamp = 0 = 1970-1-1 08:00:00 UTC+8:00</span><br></pre></td></tr></table></figure></p><p>可见timestamp的值与时区毫无关系，因为timestamp一旦确定，其UTC时间就确定了，转换到任意时区的时间也是完全确定的，这就是为什么计算机存储的当前时间是以timestamp表示的，因为全球各地的计算机在任意时刻的timestamp都是完全相同的（假定时间已校准）。</p><p>把一个<code>datetime</code>类型转换为<code>timestamp</code>只需要简单调用<code>timestamp()</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from datetime import datetime</span><br><span class="line">&gt;&gt;&gt; dt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetime</span><br><span class="line">&gt;&gt;&gt; dt.timestamp() # 把datetime转换为timestamp</span><br><span class="line">1429417200.0</span><br></pre></td></tr></table></figure></p><p>注意Python的timestamp是一个浮点数。如果有小数位，小数位表示毫秒数。</p><p>某些编程语言（如Java和JavaScript）的timestamp使用整数表示毫秒数，这种情况下只需要把timestamp除以1000就得到Python的浮点表示方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timestamp转换为datetime</span><br></pre></td></tr></table></figure></p><p>要把<code>timestamp</code>转换为<code>datetime</code>，使用<code>datetime</code>提供的<code>fromtimestamp()</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from datetime import datetime</span><br><span class="line">&gt;&gt;&gt; t = 1429417200.0</span><br><span class="line">&gt;&gt;&gt; print(datetime.fromtimestamp(t))</span><br><span class="line">2015-04-19 12:20:00</span><br></pre></td></tr></table></figure></p><p>注意到timestamp是一个浮点数，它没有时区的概念，而datetime是有时区的。上述转换是在timestamp和本地时间做转换。</p><p>本地时间是指当前操作系统设定的时区。例如北京时区是东8区，则本地时间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2015-04-19 12:20:00</span><br></pre></td></tr></table></figure></p><p>实际上就是UTC+8:00时区的时间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2015-04-19 12:20:00 UTC+8:00</span><br></pre></td></tr></table></figure></p><p>而此刻的格林威治标准时间与北京时间差了8小时，也就是UTC+0:00时区的时间应该是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2015-04-19 04:20:00 UTC+0:00</span><br></pre></td></tr></table></figure></p><p>timestamp也可以直接被转换到UTC标准时区的时间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from datetime import datetime</span><br><span class="line">&gt;&gt;&gt; t = 1429417200.0</span><br><span class="line">&gt;&gt;&gt; print(datetime.fromtimestamp(t)) # 本地时间</span><br><span class="line">2015-04-19 12:20:00</span><br><span class="line">&gt;&gt;&gt; print(datetime.utcfromtimestamp(t)) # UTC时间</span><br><span class="line">2015-04-19 04:20:00</span><br></pre></td></tr></table></figure></p><h3 id="str转换为datetime"><a href="#str转换为datetime" class="headerlink" title="str转换为datetime"></a>str转换为datetime</h3><p>很多时候，用户输入的日期和时间是字符串，要处理日期和时间，首先必须把str转换为datetime。转换方法是通过<code>datetime.strptime()</code>实现，需要一个日期和时间的格式化字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from datetime import datetime</span><br><span class="line">&gt;&gt;&gt; cday = datetime.strptime(&apos;2015-6-1 18:19:59&apos;, &apos;%Y-%m-%d %H:%M:%S&apos;)</span><br><span class="line">&gt;&gt;&gt; print(cday)</span><br><span class="line">2015-06-01 18:19:59</span><br></pre></td></tr></table></figure></p><p>字符串<code>&#39;%Y-%m-%d %H:%M:%S&#39;</code>规定了日期和时间部分的格式。详细的说明请参考Python文档。</p><p>注意转换后的datetime是没有时区信息的。</p><h3 id="datetime转换为str"><a href="#datetime转换为str" class="headerlink" title="datetime转换为str"></a>datetime转换为str</h3><p>如果已经有了datetime对象，要把它格式化为字符串显示给用户，就需要转换为str，转换方法是通过<code>strftime()</code>实现的，同样需要一个日期和时间的格式化字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from datetime import datetime</span><br><span class="line">&gt;&gt;&gt; now = datetime.now()</span><br><span class="line">&gt;&gt;&gt; print(now.strftime(&apos;%a, %b %d %H:%M&apos;))</span><br><span class="line">Mon, May 05 16:28</span><br></pre></td></tr></table></figure></p><h3 id="datetime加减"><a href="#datetime加减" class="headerlink" title="datetime加减"></a>datetime加减</h3><p>对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用+和-运算符，不过需要导入<code>timedelta</code>这个类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from datetime import datetime, timedelta</span><br><span class="line">&gt;&gt;&gt; now = datetime.now()</span><br><span class="line">&gt;&gt;&gt; now</span><br><span class="line">datetime.datetime(2015, 5, 18, 16, 57, 3, 540997)</span><br><span class="line">&gt;&gt;&gt; now + timedelta(hours=10)</span><br><span class="line">datetime.datetime(2015, 5, 19, 2, 57, 3, 540997)</span><br><span class="line">&gt;&gt;&gt; now - timedelta(days=1)</span><br><span class="line">datetime.datetime(2015, 5, 17, 16, 57, 3, 540997)</span><br><span class="line">&gt;&gt;&gt; now + timedelta(days=2, hours=12)</span><br><span class="line">datetime.datetime(2015, 5, 21, 4, 57, 3, 540997)</span><br></pre></td></tr></table></figure></p><p>可见，使用<code>timedelta</code>你可以很容易地算出前几天和后几天的时刻。</p><h3 id="本地时间转换为UTC时间"><a href="#本地时间转换为UTC时间" class="headerlink" title="本地时间转换为UTC时间"></a>本地时间转换为UTC时间</h3><p>本地时间是指系统设定时区的时间，例如北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间。</p><p>一个<code>datetime</code>类型有一个时区属性<code>tzinfo</code>，但是默认为<code>None</code>，所以无法区分这个<code>datetime</code>到底是哪个时区，除非强行给<code>datetime</code>设置一个时区：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from datetime import datetime, timedelta, timezone</span><br><span class="line">&gt;&gt;&gt; tz_utc_8 = timezone(timedelta(hours=8)) # 创建时区UTC+8:00</span><br><span class="line">&gt;&gt;&gt; now = datetime.now()</span><br><span class="line">&gt;&gt;&gt; now</span><br><span class="line">datetime.datetime(2015, 5, 18, 17, 2, 10, 871012)</span><br><span class="line">&gt;&gt;&gt; dt = now.replace(tzinfo=tz_utc_8) # 强制设置为UTC+8:00</span><br><span class="line">&gt;&gt;&gt; dt</span><br><span class="line">datetime.datetime(2015, 5, 18, 17, 2, 10, 871012, tzinfo=datetime.timezone(datetime.timedelta(0, 28800)))</span><br></pre></td></tr></table></figure></p><p>如果系统时区恰好是UTC+8:00，那么上述代码就是正确的，否则，不能强制设置为UTC+8:00时区。</p><h3 id="时区转换"><a href="#时区转换" class="headerlink" title="时区转换"></a>时区转换</h3><p>我们可以先通过<code>utcnow()</code>拿到当前的UTC时间，再转换为任意时区的时间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 拿到UTC时间，并强制设置时区为UTC+0:00:</span><br><span class="line">&gt;&gt;&gt; utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)</span><br><span class="line">&gt;&gt;&gt; print(utc_dt)</span><br><span class="line">2015-05-18 09:05:12.377316+00:00</span><br><span class="line"># astimezone()将转换时区为北京时间:</span><br><span class="line">&gt;&gt;&gt; bj_dt = utc_dt.astimezone(timezone(timedelta(hours=8)))</span><br><span class="line">&gt;&gt;&gt; print(bj_dt)</span><br><span class="line">2015-05-18 17:05:12.377316+08:00</span><br><span class="line"># astimezone()将转换时区为东京时间:</span><br><span class="line">&gt;&gt;&gt; tokyo_dt = utc_dt.astimezone(timezone(timedelta(hours=9)))</span><br><span class="line">&gt;&gt;&gt; print(tokyo_dt)</span><br><span class="line">2015-05-18 18:05:12.377316+09:00</span><br><span class="line"># astimezone()将bj_dt转换时区为东京时间:</span><br><span class="line">&gt;&gt;&gt; tokyo_dt2 = bj_dt.astimezone(timezone(timedelta(hours=9)))</span><br><span class="line">&gt;&gt;&gt; print(tokyo_dt2)</span><br><span class="line">2015-05-18 18:05:12.377316+09:00</span><br></pre></td></tr></table></figure></p><p>时区转换的关键在于，拿到一个<code>datetime</code>时，要获知其正确的时区，然后强制设置时区，作为基准时间。</p><p>利用带时区的<code>datetime</code>，通过<code>astimezone()</code>方法，可以转换到任意时区。</p><p>注：不是必须从UTC+0:00时区转换到其他时区，任何带时区的datetime都可以正确转换，例如上述bj_dt到tokyo_dt的转换。</p><p><strong>小结</strong><br><code>datetime</code>表示的时间需要时区信息才能确定一个特定的时间，否则只能视为本地时间。</p><p>如果要存储<code>datetime</code>，最佳方法是将其转换为<code>timestamp</code>再存储，因为<code>timestamp</code>的值与时区完全无关。</p><hr><h2 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h2><p>collections是Python内建的一个集合模块，提供了许多有用的集合类。</p><h3 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h3><p>我们知道tuple可以表示不变集合，例如，一个点的二维坐标就可以表示成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p = (1, 2)</span><br></pre></td></tr></table></figure></p><p>但是，看到(1, 2)，很难看出这个tuple是用来表示一个坐标的。</p><p>定义一个class又小题大做了，这时，namedtuple就派上了用场：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import namedtuple</span><br><span class="line">&gt;&gt;&gt; Point = namedtuple(&apos;Point&apos;, [&apos;x&apos;, &apos;y&apos;])</span><br><span class="line">&gt;&gt;&gt; p = Point(1, 2)</span><br><span class="line">&gt;&gt;&gt; p.x</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; p.y</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p><p>namedtuple是一个函数，它用来创建一个自定义的tuple对象，并且规定了tuple元素的个数，并可以用属性而不是索引来引用tuple的某个元素。</p><p>这样一来，我们用namedtuple可以很方便地定义一种数据类型，它具备tuple的不变性，又可以根据属性来引用，使用十分方便。</p><p>可以验证创建的Point对象是tuple的一种子类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance(p, Point)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(p, tuple)</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p><p>类似的，如果要用坐标和半径表示一个圆，也可以用namedtuple定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># namedtuple(&apos;名称&apos;, [属性list]):</span><br><span class="line">Circle = namedtuple(&apos;Circle&apos;, [&apos;x&apos;, &apos;y&apos;, &apos;r&apos;])</span><br></pre></td></tr></table></figure></p><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>使用list存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为list是线性存储，数据量大的时候，插入和删除效率很低。</p><p>deque是为了高效实现插入和删除操作的双向列表，适合用于队列和栈：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import deque</span><br><span class="line">&gt;&gt;&gt; q = deque([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;])</span><br><span class="line">&gt;&gt;&gt; q.append(&apos;x&apos;)</span><br><span class="line">&gt;&gt;&gt; q.appendleft(&apos;y&apos;)</span><br><span class="line">&gt;&gt;&gt; q</span><br><span class="line">deque([&apos;y&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;x&apos;])</span><br></pre></td></tr></table></figure></p><p>deque除了实现list的append()和pop()外，还支持appendleft()和popleft()，这样就可以非常高效地往头部添加或删除元素。</p><h3 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h3><p>使用dict时，如果引用的Key不存在，就会抛出KeyError。如果希望key不存在时，返回一个默认值，就可以用defaultdict：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import defaultdict</span><br><span class="line">&gt;&gt;&gt; dd = defaultdict(lambda: &apos;N/A&apos;)</span><br><span class="line">&gt;&gt;&gt; dd[&apos;key1&apos;] = &apos;abc&apos;</span><br><span class="line">&gt;&gt;&gt; dd[&apos;key1&apos;] # key1存在</span><br><span class="line">&apos;abc&apos;</span><br><span class="line">&gt;&gt;&gt; dd[&apos;key2&apos;] # key2不存在，返回默认值</span><br><span class="line">&apos;N/A&apos;</span><br></pre></td></tr></table></figure></p><p>注意默认值是调用函数返回的，而函数在创建defaultdict对象时传入。</p><p>除了在Key不存在时返回默认值，defaultdict的其他行为跟dict是完全一样的。</p><h3 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h3><p>使用dict时，Key是无序的。在对dict做迭代时，我们无法确定Key的顺序。</p><p>如果要保持Key的顺序，可以用OrderedDict：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import OrderedDict</span><br><span class="line">&gt;&gt;&gt; d = dict([(&apos;a&apos;, 1), (&apos;b&apos;, 2), (&apos;c&apos;, 3)])</span><br><span class="line">&gt;&gt;&gt; d # dict的Key是无序的</span><br><span class="line">&#123;&apos;a&apos;: 1, &apos;c&apos;: 3, &apos;b&apos;: 2&#125;</span><br><span class="line">&gt;&gt;&gt; od = OrderedDict([(&apos;a&apos;, 1), (&apos;b&apos;, 2), (&apos;c&apos;, 3)])</span><br><span class="line">&gt;&gt;&gt; od # OrderedDict的Key是有序的</span><br><span class="line">OrderedDict([(&apos;a&apos;, 1), (&apos;b&apos;, 2), (&apos;c&apos;, 3)])</span><br></pre></td></tr></table></figure></p><p>注意，OrderedDict的Key会按照插入的顺序排列，不是Key本身排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; od = OrderedDict()</span><br><span class="line">&gt;&gt;&gt; od[&apos;z&apos;] = 1</span><br><span class="line">&gt;&gt;&gt; od[&apos;y&apos;] = 2</span><br><span class="line">&gt;&gt;&gt; od[&apos;x&apos;] = 3</span><br><span class="line">&gt;&gt;&gt; list(od.keys()) # 按照插入的Key的顺序返回</span><br><span class="line">[&apos;z&apos;, &apos;y&apos;, &apos;x&apos;]</span><br></pre></td></tr></table></figure></p><p>OrderedDict可以实现一个FIFO（先进先出）的dict，当容量超出限制时，先删除最早添加的Key：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from collections import OrderedDict</span><br><span class="line"></span><br><span class="line">class LastUpdatedOrderedDict(OrderedDict):</span><br><span class="line"></span><br><span class="line">    def __init__(self, capacity):</span><br><span class="line">        super(LastUpdatedOrderedDict, self).__init__()</span><br><span class="line">        self._capacity = capacity</span><br><span class="line"></span><br><span class="line">    def __setitem__(self, key, value):</span><br><span class="line">        containsKey = 1 if key in self else 0</span><br><span class="line">        if len(self) - containsKey &gt;= self._capacity:</span><br><span class="line">            last = self.popitem(last=False)</span><br><span class="line">            print(&apos;remove:&apos;, last)</span><br><span class="line">        if containsKey:</span><br><span class="line">            del self[key]</span><br><span class="line">            print(&apos;set:&apos;, (key, value))</span><br><span class="line">        else:</span><br><span class="line">            print(&apos;add:&apos;, (key, value))</span><br><span class="line">        OrderedDict.__setitem__(self, key, value)</span><br></pre></td></tr></table></figure></p><h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><p>Counter是一个简单的计数器，例如，统计字符出现的个数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Counter</span><br><span class="line">&gt;&gt;&gt; c = Counter()</span><br><span class="line">&gt;&gt;&gt; for ch in &apos;programming&apos;:</span><br><span class="line">...     c[ch] = c[ch] + 1</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">Counter(&#123;&apos;g&apos;: 2, &apos;m&apos;: 2, &apos;r&apos;: 2, &apos;a&apos;: 1, &apos;i&apos;: 1, &apos;o&apos;: 1, &apos;n&apos;: 1, &apos;p&apos;: 1&#125;)</span><br></pre></td></tr></table></figure></p><p>Counter实际上也是dict的一个子类，上面的结果可以看出，字符’g’、’m’、’r’各出现了两次，其他字符各出现了一次。</p><p><strong>小结</strong><br>collections模块提供了一些有用的集合类，可以根据需要选用。</p><hr><h2 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h2><p>Base64是一种用64个字符来表示任意二进制数据的方法。</p><p>用记事本打开exe、jpg、pdf这些文件时，我们都会看到一大堆乱码，因为二进制文件包含很多无法显示和打印的字符，所以，如果要让记事本这样的文本处理软件能处理二进制数据，就需要一个二进制到字符串的转换方法。Base64是一种最常见的二进制编码方法。</p><p>Base64的原理很简单，首先，准备一个包含64个字符的数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, ... &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, ... &apos;0&apos;, &apos;1&apos;, ... &apos;+&apos;, &apos;/&apos;]</span><br></pre></td></tr></table></figure></p><p>然后，对二进制数据进行处理，每3个字节一组，一共是3x8=24bit，划为4组，每组正好6个bit：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base64-encode</span><br></pre></td></tr></table></figure></p><p>这样我们得到4个数字作为索引，然后查表，获得相应的4个字符，就是编码后的字符串。</p><p>所以，Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。</p><p>如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？Base64用\x00字节在末尾补足后，再在编码的末尾加上1个或2个=号，表示补了多少字节，解码的时候，会自动去掉。</p><p>Python内置的base64可以直接进行base64的编解码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import base64</span><br><span class="line">&gt;&gt;&gt; base64.b64encode(b&apos;binary\x00string&apos;)</span><br><span class="line">b&apos;YmluYXJ5AHN0cmluZw==&apos;</span><br><span class="line">&gt;&gt;&gt; base64.b64decode(b&apos;YmluYXJ5AHN0cmluZw==&apos;)</span><br><span class="line">b&apos;binary\x00string&apos;</span><br></pre></td></tr></table></figure></p><p>由于标准的Base64编码后可能出现字符+和/，在URL中就不能直接作为参数，所以又有一种”url safe”的base64编码，其实就是把字符+和/分别变成-和_：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; base64.b64encode(b&apos;i\xb7\x1d\xfb\xef\xff&apos;)</span><br><span class="line">b&apos;abcd++//&apos;</span><br><span class="line">&gt;&gt;&gt; base64.urlsafe_b64encode(b&apos;i\xb7\x1d\xfb\xef\xff&apos;)</span><br><span class="line">b&apos;abcd--__&apos;</span><br><span class="line">&gt;&gt;&gt; base64.urlsafe_b64decode(&apos;abcd--__&apos;)</span><br><span class="line">b&apos;i\xb7\x1d\xfb\xef\xff&apos;</span><br></pre></td></tr></table></figure></p><p>还可以自己定义64个字符的排列顺序，这样就可以自定义Base64编码，不过，通常情况下完全没有必要。</p><p>Base64是一种通过查表的编码方法，不能用于加密，即使使用自定义的编码表也不行。</p><p>Base64适用于小段内容的编码，比如数字证书签名、Cookie的内容等。</p><p>由于=字符也可能出现在Base64编码中，但=用在URL、Cookie里面会造成歧义，所以，很多Base64编码后会把=去掉：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 标准Base64:</span><br><span class="line">&apos;abcd&apos; -&gt; &apos;YWJjZA==&apos;</span><br><span class="line"># 自动去掉=:</span><br><span class="line">&apos;abcd&apos; -&gt; &apos;YWJjZA&apos;</span><br></pre></td></tr></table></figure></p><p>去掉=后怎么解码呢？因为Base64是把3个字节变为4个字节，所以，Base64编码的长度永远是4的倍数，因此，需要加上=把Base64字符串的长度变为4的倍数，就可以正常解码了。</p><p><strong>小结</strong><br>Base64是一种任意二进制到文本字符串的编码方法，常用于在URL、Cookie、网页中传输少量二进制数据。</p><hr><h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><p>准确地讲，Python没有专门处理字节的数据类型。但由于b’str’可以表示字节，所以，字节数组＝二进制str。而在C语言中，我们可以很方便地用struct、union来处理字节，以及字节和int，float的转换。</p><p>在Python中，比方说要把一个32位无符号整数变成字节，也就是4个长度的bytes，你得配合位运算符这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; n = 10240099</span><br><span class="line">&gt;&gt;&gt; b1 = (n &amp; 0xff000000) &gt;&gt; 24</span><br><span class="line">&gt;&gt;&gt; b2 = (n &amp; 0xff0000) &gt;&gt; 16</span><br><span class="line">&gt;&gt;&gt; b3 = (n &amp; 0xff00) &gt;&gt; 8</span><br><span class="line">&gt;&gt;&gt; b4 = n &amp; 0xff</span><br><span class="line">&gt;&gt;&gt; bs = bytes([b1, b2, b3, b4])</span><br><span class="line">&gt;&gt;&gt; bs</span><br><span class="line">b&apos;\x00\x9c@c&apos;</span><br></pre></td></tr></table></figure></p><p>非常麻烦。如果换成浮点数就无能为力了。</p><p>好在Python提供了一个struct模块来解决bytes和其他二进制数据类型的转换。</p><p>struct的pack函数把任意数据类型变成bytes：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import struct</span><br><span class="line">&gt;&gt;&gt; struct.pack(&apos;&gt;I&apos;, 10240099)</span><br><span class="line">b&apos;\x00\x9c@c&apos;</span><br></pre></td></tr></table></figure></p><p>pack的第一个参数是处理指令，’&gt;I’的意思是：</p><blockquote><p>表示字节顺序是big-endian，也就是网络序，I表示4字节无符号整数。</p></blockquote><p>后面的参数个数要和处理指令一致。</p><p>unpack把bytes变成相应的数据类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; struct.unpack(&apos;&gt;IH&apos;, b&apos;\xf0\xf0\xf0\xf0\x80\x80&apos;)</span><br><span class="line">(4042322160, 32896)</span><br></pre></td></tr></table></figure></p><p>根据&gt;IH的说明，后面的bytes依次变为I：4字节无符号整数和H：2字节无符号整数。</p><p>所以，尽管Python不适合编写底层操作字节流的代码，但在对性能要求不高的地方，利用struct就方便多了。</p><p>struct模块定义的数据类型可以参考Python官方文档：</p><p><a href="https://docs.python.org/3/library/struct.html#format-characters" target="_blank" rel="noopener">https://docs.python.org/3/library/struct.html#format-characters</a></p><p>Windows的位图文件（.bmp）是一种非常简单的文件格式，我们来用struct分析一下。</p><p>首先找一个bmp文件，没有的话用“画图”画一个。</p><p>读入前30个字节来分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = b&apos;\x42\x4d\x38\x8c\x0a\x00\x00\x00\x00\x00\x36\x00\x00\x00\x28\x00\x00\x00\x80\x02\x00\x00\x68\x01\x00\x00\x01\x00\x18\x00&apos;</span><br></pre></td></tr></table></figure></p><p>BMP格式采用小端方式存储数据，文件头的结构按顺序如下：</p><p>两个字节：’BM’表示Windows位图，’BA’表示OS/2位图；<br>一个4字节整数：表示位图大小；<br>一个4字节整数：保留位，始终为0；<br>一个4字节整数：实际图像的偏移量；<br>一个4字节整数：Header的字节数；<br>一个4字节整数：图像宽度；<br>一个4字节整数：图像高度；<br>一个2字节整数：始终为1；<br>一个2字节整数：颜色数。</p><p>所以，组合起来用unpack读取：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; struct.unpack(&apos;&lt;ccIIIIIIHH&apos;, s)</span><br><span class="line">(b&apos;B&apos;, b&apos;M&apos;, 691256, 0, 54, 40, 640, 360, 1, 24)</span><br></pre></td></tr></table></figure></p><p>结果显示，b’B’、b’M’说明是Windows位图，位图大小为640x360，颜色数为24。</p><hr><h2 id="hashlib"><a href="#hashlib" class="headerlink" title="hashlib"></a>hashlib</h2><p>摘要算法简介<br>Python的hashlib提供了常见的摘要算法，如MD5，SHA1等等。</p><p>什么是摘要算法呢？摘要算法又称哈希算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。</p><p>举个例子，你写了一篇文章，内容是一个字符串’how to use python hashlib - by Michael’，并附上这篇文章的摘要是’2d73d4f15c0db7f5ecb321b6a65e5d6d’。如果有人篡改了你的文章，并发表为’how to use python hashlib - by Bob’，你可以一下子指出Bob篡改了你的文章，因为根据’how to use python hashlib - by Bob’计算出的摘要不同于原始文章的摘要。</p><p>可见，摘要算法就是通过摘要函数f()对任意长度的数据data计算出固定长度的摘要digest，目的是为了发现原始数据是否被人篡改过。</p><p>摘要算法之所以能指出数据是否被篡改过，就是因为摘要函数是一个单向函数，计算f(data)很容易，但通过digest反推data却非常困难。而且，对原始数据做一个bit的修改，都会导致计算出的摘要完全不同。</p><p>我们以常见的摘要算法MD5为例，计算出一个字符串的MD5值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line">md5 = hashlib.md5()</span><br><span class="line">md5.update(&apos;how to use md5 in python hashlib?&apos;.encode(&apos;utf-8&apos;))</span><br><span class="line">print(md5.hexdigest())</span><br></pre></td></tr></table></figure></p><p>计算结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d26a53750bc40b38b65a520292f69306</span><br></pre></td></tr></table></figure></p><p>如果数据量很大，可以分块多次调用update()，最后计算的结果是一样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line">md5 = hashlib.md5()</span><br><span class="line">md5.update(&apos;how to use md5 in &apos;.encode(&apos;utf-8&apos;))</span><br><span class="line">md5.update(&apos;python hashlib?&apos;.encode(&apos;utf-8&apos;))</span><br><span class="line">print(md5.hexdigest())</span><br></pre></td></tr></table></figure></p><p>试试改动一个字母，看看计算的结果是否完全不同。</p><p>MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。</p><p>另一种常见的摘要算法是SHA1，调用SHA1和调用MD5完全类似：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line">sha1 = hashlib.sha1()</span><br><span class="line">sha1.update(&apos;how to use sha1 in &apos;.encode(&apos;utf-8&apos;))</span><br><span class="line">sha1.update(&apos;python hashlib?&apos;.encode(&apos;utf-8&apos;))</span><br><span class="line">print(sha1.hexdigest())</span><br></pre></td></tr></table></figure></p><p>SHA1的结果是160 bit字节，通常用一个40位的16进制字符串表示。</p><p>比SHA1更安全的算法是SHA256和SHA512，不过越安全的算法不仅越慢，而且摘要长度更长。</p><p>有没有可能两个不同的数据通过某个摘要算法得到了相同的摘要？完全有可能，因为任何摘要算法都是把无限多的数据集合映射到一个有限的集合中。这种情况称为碰撞，比如Bob试图根据你的摘要反推出一篇文章’how to learn hashlib in python - by Bob’，并且这篇文章的摘要恰好和你的文章完全一致，这种情况也并非不可能出现，但是非常非常困难。</p><h3 id="摘要算法应用"><a href="#摘要算法应用" class="headerlink" title="摘要算法应用"></a>摘要算法应用</h3><p>摘要算法能应用到什么地方？举个常用例子：</p><p>任何允许用户登录的网站都会存储用户登录的用户名和口令。如何存储用户名和口令呢？方法是存到数据库表中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">namepassword</span><br><span class="line">michael123456</span><br><span class="line">bobabc999</span><br><span class="line">alicealice2008</span><br></pre></td></tr></table></figure></p><p>如果以明文保存用户口令，如果数据库泄露，所有用户的口令就落入黑客的手里。此外，网站运维人员是可以访问数据库的，也就是能获取到所有用户的口令。</p><p>正确的保存口令的方式是不存储用户的明文口令，而是存储用户口令的摘要，比如MD5：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">usernamepassword</span><br><span class="line">michaele10adc3949ba59abbe56e057f20f883e</span><br><span class="line">bob878ef96e86145580c38c87f0410ad153</span><br><span class="line">alice99b1c2188db85afee403b1536010c2c9</span><br></pre></td></tr></table></figure></p><p>当用户登录时，首先计算用户输入的明文口令的MD5，然后和数据库存储的MD5对比，如果一致，说明口令输入正确，如果不一致，口令肯定错误。</p><p>存储MD5的好处是即使运维人员能访问数据库，也无法获知用户的明文口令。</p><p>采用MD5存储口令是否就一定安全呢？也不一定。假设你是一个黑客，已经拿到了存储MD5口令的数据库，如何通过MD5反推用户的明文口令呢？暴力破解费事费力，真正的黑客不会这么干。</p><p>考虑这么个情况，很多用户喜欢用123456，888888，password这些简单的口令，于是，黑客可以事先计算出这些常用口令的MD5值，得到一个反推表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;e10adc3949ba59abbe56e057f20f883e&apos;: &apos;123456&apos;</span><br><span class="line">&apos;21218cca77804d2ba1922c33e0151105&apos;: &apos;888888&apos;</span><br><span class="line">&apos;5f4dcc3b5aa765d61d8327deb882cf99&apos;: &apos;password&apos;</span><br></pre></td></tr></table></figure></p><p>这样，无需破解，只需要对比数据库的MD5，黑客就获得了使用常用口令的用户账号。</p><p>对于用户来讲，当然不要使用过于简单的口令。但是，我们能否在程序设计上对简单口令加强保护呢？</p><p>由于常用口令的MD5值很容易被计算出来，所以，要确保存储的用户口令不是那些已经被计算出来的常用口令的MD5，这一方法通过对原始口令加一个复杂字符串来实现，俗称“加盐”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def calc_md5(password):</span><br><span class="line">    return get_md5(password + &apos;the-Salt&apos;)</span><br></pre></td></tr></table></figure></p><p>经过Salt处理的MD5口令，只要Salt不被黑客知道，即使用户输入简单口令，也很难通过MD5反推明文口令。</p><p>但是如果有两个用户都使用了相同的简单口令比如123456，在数据库中，将存储两条相同的MD5值，这说明这两个用户的口令是一样的。有没有办法让使用相同口令的用户存储不同的MD5呢？</p><p>如果假定用户无法修改登录名，就可以通过把登录名作为Salt的一部分来计算MD5，从而实现相同口令的用户也存储不同的MD5。</p><p><strong>小结</strong><br>摘要算法在很多地方都有广泛的应用。要注意摘要算法不是加密算法，不能用于加密（因为无法通过摘要反推明文），只能用于防篡改，但是它的单向计算特性决定了可以在不存储明文口令的情况下验证用户口令。</p><hr><h2 id="hmac"><a href="#hmac" class="headerlink" title="hmac"></a>hmac</h2><p>通过哈希算法，我们可以验证一段数据是否有效，方法就是对比该数据的哈希值，例如，判断用户口令是否正确，我们用保存在数据库中的password_md5对比计算md5(password)的结果，如果一致，用户输入的口令就是正确的。</p><p>为了防止黑客通过彩虹表根据哈希值反推原始口令，在计算哈希的时候，不能仅针对原始输入计算，需要增加一个salt来使得相同的输入也能得到不同的哈希，这样，大大增加了黑客破解的难度。</p><p>如果salt是我们自己随机生成的，通常我们计算MD5时采用md5(message + salt)。但实际上，把salt看做一个“口令”，加salt的哈希就是：计算一段message的哈希时，根据不通口令计算出不同的哈希。要验证哈希值，必须同时提供正确的口令。</p><p>这实际上就是Hmac算法：Keyed-Hashing for Message Authentication。它通过一个标准算法，在计算哈希的过程中，把key混入计算过程中。</p><p>和我们自定义的加salt算法不同，Hmac算法针对所有哈希算法都通用，无论是MD5还是SHA-1。采用Hmac替代我们自己的salt算法，可以使程序算法更标准化，也更安全。</p><p>Python自带的hmac模块实现了标准的Hmac算法。我们来看看如何使用hmac实现带key的哈希。</p><p>我们首先需要准备待计算的原始消息message，随机key，哈希算法，这里采用MD5，使用hmac的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import hmac</span><br><span class="line">&gt;&gt;&gt; message = b&apos;Hello, world!&apos;</span><br><span class="line">&gt;&gt;&gt; key = b&apos;secret&apos;</span><br><span class="line">&gt;&gt;&gt; h = hmac.new(key, message, digestmod=&apos;MD5&apos;)</span><br><span class="line">&gt;&gt;&gt; # 如果消息很长，可以多次调用h.update(msg)</span><br><span class="line">&gt;&gt;&gt; h.hexdigest()</span><br><span class="line">&apos;fa4ee7d173f2d97ee79022d1a7355bcf&apos;</span><br></pre></td></tr></table></figure></p><p>可见使用hmac和普通hash算法非常类似。hmac输出的长度和原始哈希算法的长度一致。需要注意传入的key和message都是bytes类型，str类型需要首先编码为bytes。</p><p><strong>小结</strong><br>Python内置的hmac模块实现了标准的Hmac算法，它利用一个key对message计算“杂凑”后的hash，使用hmac算法比标准hash算法更安全，因为针对相同的message，不同的key会产生不同的hash。</p><hr><h2 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a>itertools</h2><p>Python的内建模块itertools提供了非常有用的用于操作迭代对象的函数。</p><p>首先，我们看看itertools提供的几个“无限”迭代器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import itertools</span><br><span class="line">&gt;&gt;&gt; natuals = itertools.count(1)</span><br><span class="line">&gt;&gt;&gt; for n in natuals:</span><br><span class="line">...     print(n)</span><br><span class="line">...</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>因为count()会创建一个无限的迭代器，所以上述代码会打印出自然数序列，根本停不下来，只能按Ctrl+C退出。</p><p>cycle()会把传入的一个序列无限重复下去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import itertools</span><br><span class="line">&gt;&gt;&gt; cs = itertools.cycle(&apos;ABC&apos;) # 注意字符串也是序列的一种</span><br><span class="line">&gt;&gt;&gt; for c in cs:</span><br><span class="line">...     print(c)</span><br><span class="line">...</span><br><span class="line">&apos;A&apos;</span><br><span class="line">&apos;B&apos;</span><br><span class="line">&apos;C&apos;</span><br><span class="line">&apos;A&apos;</span><br><span class="line">&apos;B&apos;</span><br><span class="line">&apos;C&apos;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>同样停不下来。</p><p>repeat()负责把一个元素无限重复下去，不过如果提供第二个参数就可以限定重复次数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ns = itertools.repeat(&apos;A&apos;, 3)</span><br><span class="line">&gt;&gt;&gt; for n in ns:</span><br><span class="line">...     print(n)</span><br><span class="line">...</span><br><span class="line">A</span><br><span class="line">A</span><br><span class="line">A</span><br></pre></td></tr></table></figure></p><p>无限序列只有在for迭代时才会无限地迭代下去，如果只是创建了一个迭代对象，它不会事先把无限个元素生成出来，事实上也不可能在内存中创建无限多个元素。</p><p>无限序列虽然可以无限迭代下去，但是通常我们会通过takewhile()等函数根据条件判断来截取出一个有限的序列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; natuals = itertools.count(1)</span><br><span class="line">&gt;&gt;&gt; ns = itertools.takewhile(lambda x: x &lt;= 10, natuals)</span><br><span class="line">&gt;&gt;&gt; list(ns)</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure></p><p>itertools提供的几个迭代器操作函数更加有用：</p><h3 id="chain"><a href="#chain" class="headerlink" title="chain()"></a>chain()</h3><p>chain()可以把一组迭代对象串联起来，形成一个更大的迭代器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for c in itertools.chain(&apos;ABC&apos;, &apos;XYZ&apos;):</span><br><span class="line">...     print(c)</span><br><span class="line"># 迭代效果：&apos;A&apos; &apos;B&apos; &apos;C&apos; &apos;X&apos; &apos;Y&apos; &apos;Z&apos;</span><br></pre></td></tr></table></figure></p><h3 id="groupby"><a href="#groupby" class="headerlink" title="groupby()"></a>groupby()</h3><p>groupby()把迭代器中相邻的重复元素挑出来放在一起：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for key, group in itertools.groupby(&apos;AAABBBCCAAA&apos;):</span><br><span class="line">...     print(key, list(group))</span><br><span class="line">...</span><br><span class="line">A [&apos;A&apos;, &apos;A&apos;, &apos;A&apos;]</span><br><span class="line">B [&apos;B&apos;, &apos;B&apos;, &apos;B&apos;]</span><br><span class="line">C [&apos;C&apos;, &apos;C&apos;]</span><br><span class="line">A [&apos;A&apos;, &apos;A&apos;, &apos;A&apos;]</span><br></pre></td></tr></table></figure></p><p>实际上挑选规则是通过函数完成的，只要作用于函数的两个元素返回的值相等，这两个元素就被认为是在一组的，而函数返回值作为组的key。如果我们要忽略大小写分组，就可以让元素’A’和’a’都返回相同的key：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for key, group in itertools.groupby(&apos;AaaBBbcCAAa&apos;, lambda c: c.upper()):</span><br><span class="line">...     print(key, list(group))</span><br><span class="line">...</span><br><span class="line">A [&apos;A&apos;, &apos;a&apos;, &apos;a&apos;]</span><br><span class="line">B [&apos;B&apos;, &apos;B&apos;, &apos;b&apos;]</span><br><span class="line">C [&apos;c&apos;, &apos;C&apos;]</span><br><span class="line">A [&apos;A&apos;, &apos;A&apos;, &apos;a&apos;]</span><br></pre></td></tr></table></figure></p><p><strong>小结</strong><br>itertools模块提供的全部是处理迭代功能的函数，它们的返回值不是list，而是Iterator，只有用for循环迭代的时候才真正计算。</p><hr><h2 id="contextlib"><a href="#contextlib" class="headerlink" title="contextlib"></a>contextlib</h2><p>在Python中，读写文件这样的资源要特别注意，必须在使用完毕后正确关闭它们。正确关闭文件资源的一个方法是使用try…finally：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    f = open(&apos;/path/to/file&apos;, &apos;r&apos;)</span><br><span class="line">    f.read()</span><br><span class="line">finally:</span><br><span class="line">    if f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure></p><p>写try…finally非常繁琐。Python的with语句允许我们非常方便地使用资源，而不必担心资源没有关闭，所以上面的代码可以简化为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;/path/to/file&apos;, &apos;r&apos;) as f:</span><br><span class="line">    f.read()</span><br></pre></td></tr></table></figure></p><p>并不是只有open()函数返回的fp对象才能使用with语句。实际上，任何对象，只要正确实现了上下文管理，就可以用于with语句。</p><p>实现上下文管理是通过<strong>enter</strong>和<strong>exit</strong>这两个方法实现的。例如，下面的class实现了这两个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Query(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def __enter__(self):</span><br><span class="line">        print(&apos;Begin&apos;)</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def __exit__(self, exc_type, exc_value, traceback):</span><br><span class="line">        if exc_type:</span><br><span class="line">            print(&apos;Error&apos;)</span><br><span class="line">        else:</span><br><span class="line">            print(&apos;End&apos;)</span><br><span class="line"></span><br><span class="line">    def query(self):</span><br><span class="line">        print(&apos;Query info about %s...&apos; % self.name)</span><br></pre></td></tr></table></figure></p><p>这样我们就可以把自己写的资源对象用于with语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with Query(&apos;Bob&apos;) as q:</span><br><span class="line">    q.query()</span><br></pre></td></tr></table></figure></p><h3 id="contextmanager"><a href="#contextmanager" class="headerlink" title="@contextmanager"></a>@contextmanager</h3><p>编写<strong>enter</strong>和<strong>exit</strong>仍然很繁琐，因此Python的标准库contextlib提供了更简单的写法，上面的代码可以改写如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from contextlib import contextmanager</span><br><span class="line"></span><br><span class="line">class Query(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def query(self):</span><br><span class="line">        print(&apos;Query info about %s...&apos; % self.name)</span><br><span class="line"></span><br><span class="line">@contextmanager</span><br><span class="line">def create_query(name):</span><br><span class="line">    print(&apos;Begin&apos;)</span><br><span class="line">    q = Query(name)</span><br><span class="line">    yield q</span><br><span class="line">    print(&apos;End&apos;)</span><br></pre></td></tr></table></figure></p><p>@contextmanager这个decorator接受一个generator，用yield语句把with … as var把变量输出出去，然后，with语句就可以正常地工作了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with create_query(&apos;Bob&apos;) as q:</span><br><span class="line">    q.query()</span><br></pre></td></tr></table></figure></p><p>很多时候，我们希望在某段代码执行前后自动执行特定代码，也可以用@contextmanager实现。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@contextmanager</span><br><span class="line">def tag(name):</span><br><span class="line">    print(&quot;&lt;%s&gt;&quot; % name)</span><br><span class="line">    yield</span><br><span class="line">    print(&quot;&lt;/%s&gt;&quot; % name)</span><br><span class="line"></span><br><span class="line">with tag(&quot;h1&quot;):</span><br><span class="line">    print(&quot;hello&quot;)</span><br><span class="line">    print(&quot;world&quot;)</span><br></pre></td></tr></table></figure></p><p>上述代码执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p><p>代码的执行顺序是：</p><p>with语句首先执行yield之前的语句，因此打印出</p><h1>；<br>yield调用会执行with语句内部的所有语句，因此打印出hello和world；<br>最后执行yield之后的语句，打印出</h1>。<br>因此，@contextmanager让我们通过编写generator来简化上下文管理。<p></p><h3 id="closing"><a href="#closing" class="headerlink" title="@closing"></a>@closing</h3><p>如果一个对象没有实现上下文，我们就不能把它用于with语句。这个时候，可以用closing()来把该对象变为上下文对象。例如，用with语句使用urlopen()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from contextlib import closing</span><br><span class="line">from urllib.request import urlopen</span><br><span class="line"></span><br><span class="line">with closing(urlopen(&apos;https://www.python.org&apos;)) as page:</span><br><span class="line">    for line in page:</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure></p><p>closing也是一个经过@contextmanager装饰的generator，这个generator编写起来其实非常简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@contextmanager</span><br><span class="line">def closing(thing):</span><br><span class="line">    try:</span><br><span class="line">        yield thing</span><br><span class="line">    finally:</span><br><span class="line">        thing.close()</span><br></pre></td></tr></table></figure></p><p>它的作用就是把任意对象变为上下文对象，并支持with语句。</p><p>@contextlib还有一些其他decorator，便于我们编写更简洁的代码。</p><hr><h2 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h2><p>urllib提供了一系列用于操作URL的功能。</p><h3 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h3><p>urllib的request模块可以非常方便地抓取URL内容，也就是发送一个GET请求到指定的页面，然后返回HTTP的响应：</p><p>例如，对豆瓣的一个URL<a href="https://api.douban.com/v2/book/2129650进行抓取，并返回响应：" target="_blank" rel="noopener">https://api.douban.com/v2/book/2129650进行抓取，并返回响应：</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line"></span><br><span class="line">with request.urlopen(&apos;https://api.douban.com/v2/book/2129650&apos;) as f:</span><br><span class="line">    data = f.read()</span><br><span class="line">    print(&apos;Status:&apos;, f.status, f.reason)</span><br><span class="line">    for k, v in f.getheaders():</span><br><span class="line">        print(&apos;%s: %s&apos; % (k, v))</span><br><span class="line">    print(&apos;Data:&apos;, data.decode(&apos;utf-8&apos;))</span><br></pre></td></tr></table></figure></p><p>可以看到HTTP响应的头和JSON数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Status: 200 OK</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Tue, 26 May 2015 10:02:27 GMT</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Content-Length: 2049</span><br><span class="line">Connection: close</span><br><span class="line">Expires: Sun, 1 Jan 2006 01:00:00 GMT</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: must-revalidate, no-cache, private</span><br><span class="line">X-DAE-Node: pidl1</span><br><span class="line">Data: &#123;&quot;rating&quot;:&#123;&quot;max&quot;:10,&quot;numRaters&quot;:16,&quot;average&quot;:&quot;7.4&quot;,&quot;min&quot;:0&#125;,&quot;subtitle&quot;:&quot;&quot;,&quot;author&quot;:[&quot;廖雪峰编著&quot;],&quot;pubdate&quot;:&quot;2007-6&quot;,...&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们要想模拟浏览器发送GET请求，就需要使用Request对象，通过往Request对象添加HTTP头，我们就可以把请求伪装成浏览器。例如，模拟iPhone 6去请求豆瓣首页：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request</span><br><span class="line"></span><br><span class="line">req = request.Request(&apos;http://www.douban.com/&apos;)</span><br><span class="line">req.add_header(&apos;User-Agent&apos;, &apos;Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25&apos;)</span><br><span class="line">with request.urlopen(req) as f:</span><br><span class="line">    print(&apos;Status:&apos;, f.status, f.reason)</span><br><span class="line">    for k, v in f.getheaders():</span><br><span class="line">        print(&apos;%s: %s&apos; % (k, v))</span><br><span class="line">    print(&apos;Data:&apos;, f.read().decode(&apos;utf-8&apos;))</span><br></pre></td></tr></table></figure></p><p>这样豆瓣会返回适合iPhone的移动版网页：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;</span><br><span class="line">    &lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;57x57&quot; href=&quot;http://img4.douban.com/pics/cardkit/launcher/57.png&quot; /&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h3 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h3><p>如果要以POST发送一个请求，只需要把参数data以bytes形式传入。</p><p>我们模拟一个微博登录，先读取登录的邮箱和口令，然后按照weibo.cn的登录页的格式以username=xxx&amp;password=xxx的编码传入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from urllib import request, parse</span><br><span class="line"></span><br><span class="line">print(&apos;Login to weibo.cn...&apos;)</span><br><span class="line">email = input(&apos;Email: &apos;)</span><br><span class="line">passwd = input(&apos;Password: &apos;)</span><br><span class="line">login_data = parse.urlencode([</span><br><span class="line">    (&apos;username&apos;, email),</span><br><span class="line">    (&apos;password&apos;, passwd),</span><br><span class="line">    (&apos;entry&apos;, &apos;mweibo&apos;),</span><br><span class="line">    (&apos;client_id&apos;, &apos;&apos;),</span><br><span class="line">    (&apos;savestate&apos;, &apos;1&apos;),</span><br><span class="line">    (&apos;ec&apos;, &apos;&apos;),</span><br><span class="line">    (&apos;pagerefer&apos;, &apos;https://passport.weibo.cn/signin/welcome?entry=mweibo&amp;r=http%3A%2F%2Fm.weibo.cn%2F&apos;)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">req = request.Request(&apos;https://passport.weibo.cn/sso/login&apos;)</span><br><span class="line">req.add_header(&apos;Origin&apos;, &apos;https://passport.weibo.cn&apos;)</span><br><span class="line">req.add_header(&apos;User-Agent&apos;, &apos;Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25&apos;)</span><br><span class="line">req.add_header(&apos;Referer&apos;, &apos;https://passport.weibo.cn/signin/login?entry=mweibo&amp;res=wel&amp;wm=3349&amp;r=http%3A%2F%2Fm.weibo.cn%2F&apos;)</span><br><span class="line"></span><br><span class="line">with request.urlopen(req, data=login_data.encode(&apos;utf-8&apos;)) as f:</span><br><span class="line">    print(&apos;Status:&apos;, f.status, f.reason)</span><br><span class="line">    for k, v in f.getheaders():</span><br><span class="line">        print(&apos;%s: %s&apos; % (k, v))</span><br><span class="line">    print(&apos;Data:&apos;, f.read().decode(&apos;utf-8&apos;))</span><br></pre></td></tr></table></figure></p><p>如果登录成功，我们获得的响应如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Status: 200 OK</span><br><span class="line">Server: nginx/1.2.0</span><br><span class="line">...</span><br><span class="line">Set-Cookie: SSOLoginState=1432620126; path=/; domain=weibo.cn</span><br><span class="line">...</span><br><span class="line">Data: &#123;&quot;retcode&quot;:20000000,&quot;msg&quot;:&quot;&quot;,&quot;data&quot;:&#123;...,&quot;uid&quot;:&quot;1658384301&quot;&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>如果登录失败，我们获得的响应如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Data: &#123;&quot;retcode&quot;:50011015,&quot;msg&quot;:&quot;\u7528\u6237\u540d\u6216\u5bc6\u7801\u9519\u8bef&quot;,&quot;data&quot;:&#123;&quot;username&quot;:&quot;example@python.org&quot;,&quot;errline&quot;:536&#125;&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p>如果还需要更复杂的控制，比如通过一个Proxy去访问网站，我们需要利用ProxyHandler来处理，示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">proxy_handler = urllib.request.ProxyHandler(&#123;&apos;http&apos;: &apos;http://www.example.com:3128/&apos;&#125;)</span><br><span class="line">proxy_auth_handler = urllib.request.ProxyBasicAuthHandler()</span><br><span class="line">proxy_auth_handler.add_password(&apos;realm&apos;, &apos;host&apos;, &apos;username&apos;, &apos;password&apos;)</span><br><span class="line">opener = urllib.request.build_opener(proxy_handler, proxy_auth_handler)</span><br><span class="line">with opener.open(&apos;http://www.example.com/login.html&apos;) as f:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p><p><strong>小结</strong><br>urllib提供的功能就是利用程序去执行各种HTTP请求。如果要模拟浏览器完成特定功能，需要把请求伪装成浏览器。伪装的方法是先监控浏览器发出的请求，再根据浏览器的请求头来伪装，User-Agent头就是用来标识浏览器的。</p><hr><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p>XML虽然比JSON复杂，在Web中应用也不如以前多了，不过仍有很多地方在用，所以，有必要了解如何操作XML。</p><h3 id="DOM-vs-SAX"><a href="#DOM-vs-SAX" class="headerlink" title="DOM vs SAX"></a>DOM vs SAX</h3><p>操作XML有两种方法：DOM和SAX。DOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，优点是可以任意遍历树的节点。SAX是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。</p><p>正常情况下，优先考虑SAX，因为DOM实在太占内存。</p><p>在Python中使用SAX解析XML非常简洁，通常我们关心的事件是start_element，end_element和char_data，准备好这3个函数，然后就可以解析xml了。</p><p>举个例子，当SAX解析器读到一个节点时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;/&quot;&gt;python&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><p>会产生3个事件：</p><ol><li><p>start_element事件，在读取<a href="/">时；</a></p></li><li><p>char_data事件，在读取python时；</p></li><li><p>end_element事件，在读取时。</p></li></ol><p>用代码实验一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from xml.parsers.expat import ParserCreate</span><br><span class="line"></span><br><span class="line">class DefaultSaxHandler(object):</span><br><span class="line">    def start_element(self, name, attrs):</span><br><span class="line">        print(&apos;sax:start_element: %s, attrs: %s&apos; % (name, str(attrs)))</span><br><span class="line"></span><br><span class="line">    def end_element(self, name):</span><br><span class="line">        print(&apos;sax:end_element: %s&apos; % name)</span><br><span class="line"></span><br><span class="line">    def char_data(self, text):</span><br><span class="line">        print(&apos;sax:char_data: %s&apos; % text)</span><br><span class="line"></span><br><span class="line">xml = r&apos;&apos;&apos;&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;ol&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;/python&quot;&gt;Python&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;/ruby&quot;&gt;Ruby&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">handler = DefaultSaxHandler()</span><br><span class="line">parser = ParserCreate()</span><br><span class="line">parser.StartElementHandler = handler.start_element</span><br><span class="line">parser.EndElementHandler = handler.end_element</span><br><span class="line">parser.CharacterDataHandler = handler.char_data</span><br><span class="line">parser.Parse(xml)</span><br></pre></td></tr></table></figure></p><p>需要注意的是读取一大段字符串时，CharacterDataHandler可能被多次调用，所以需要自己保存起来，在EndElementHandler里面再合并。</p><p>除了解析XML外，如何生成XML呢？99%的情况下需要生成的XML结构都是非常简单的，因此，最简单也是最有效的生成XML的方法是拼接字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">L = []</span><br><span class="line">L.append(r&apos;&lt;?xml version=&quot;1.0&quot;?&gt;&apos;)</span><br><span class="line">L.append(r&apos;&lt;root&gt;&apos;)</span><br><span class="line">L.append(encode(&apos;some &amp; data&apos;))</span><br><span class="line">L.append(r&apos;&lt;/root&gt;&apos;)</span><br><span class="line">return &apos;&apos;.join(L)</span><br></pre></td></tr></table></figure></p><p>如果要生成复杂的XML呢？建议你不要用XML，改成JSON。</p><p><strong>小结</strong><br>解析XML时，注意找出自己感兴趣的节点，响应事件时，把节点数据保存起来。解析完毕后，就可以处理数据。</p><hr><h2 id="HTMLParser"><a href="#HTMLParser" class="headerlink" title="HTMLParser"></a>HTMLParser</h2><p>如果我们要编写一个搜索引擎，第一步是用爬虫把目标网站的页面抓下来，第二步就是解析该HTML页面，看看里面的内容到底是新闻、图片还是视频。</p><p>假设第一步已经完成了，第二步应该如何解析HTML呢？</p><p>HTML本质上是XML的子集，但是HTML的语法没有XML那么严格，所以不能用标准的DOM或SAX来解析HTML。</p><p>好在Python提供了HTMLParser来非常方便地解析HTML，只需简单几行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">from html.parser import HTMLParser</span><br><span class="line">from html.entities import name2codepoint</span><br><span class="line"></span><br><span class="line">class MyHTMLParser(HTMLParser):</span><br><span class="line"></span><br><span class="line">    def handle_starttag(self, tag, attrs):</span><br><span class="line">        print(&apos;&lt;%s&gt;&apos; % tag)</span><br><span class="line"></span><br><span class="line">    def handle_endtag(self, tag):</span><br><span class="line">        print(&apos;&lt;/%s&gt;&apos; % tag)</span><br><span class="line"></span><br><span class="line">    def handle_startendtag(self, tag, attrs):</span><br><span class="line">        print(&apos;&lt;%s/&gt;&apos; % tag)</span><br><span class="line"></span><br><span class="line">    def handle_data(self, data):</span><br><span class="line">        print(data)</span><br><span class="line"></span><br><span class="line">    def handle_comment(self, data):</span><br><span class="line">        print(&apos;&lt;!--&apos;, data, &apos;--&gt;&apos;)</span><br><span class="line"></span><br><span class="line">    def handle_entityref(self, name):</span><br><span class="line">        print(&apos;&amp;%s;&apos; % name)</span><br><span class="line"></span><br><span class="line">    def handle_charref(self, name):</span><br><span class="line">        print(&apos;&amp;#%s;&apos; % name)</span><br><span class="line"></span><br><span class="line">parser = MyHTMLParser()</span><br><span class="line">parser.feed(&apos;&apos;&apos;&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!-- test html parser --&gt;</span><br><span class="line">    &lt;p&gt;Some &lt;a href=\&quot;#\&quot;&gt;html&lt;/a&gt; HTML&amp;nbsp;tutorial...&lt;br&gt;END&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;&lt;/html&gt;&apos;&apos;&apos;)</span><br></pre></td></tr></table></figure></p><p>feed()方法可以多次调用，也就是不一定一次把整个HTML字符串都塞进去，可以一部分一部分塞进去。</p><p>特殊字符有两种，一种是英文表示的&nbsp;，一种是数字表示的&#1234;，这两种字符都可以通过Parser解析出来。</p><p><strong>小结</strong><br>利用HTMLParser，可以把网页中的文本、图像等解析出来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python之所以自称“batteries included”，就是因为内置了许多非常有用的模块，无需额外安装和配置，即可直接使用。&lt;/p&gt;
    
    </summary>
    
      <category term="编程相关" scheme="https://paradoxallen.github.io/categories/%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="python" scheme="https://paradoxallen.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python正则表达式</title>
    <link href="https://paradoxallen.github.io/26030/"/>
    <id>https://paradoxallen.github.io/26030/</id>
    <published>2017-11-11T16:00:00.000Z</published>
    <updated>2018-07-20T08:09:05.512Z</updated>
    
    <content type="html"><![CDATA[<p>字符串是编程时涉及到的最多的一种数据结构，对字符串进行操作的需求几乎无处不在。比如判断一个字符串是否是合法的Email地址，虽然可以编程提取@前后的子串，再分别判断是否是单词和域名，但这样做不但麻烦，而且代码难以复用。</p><p>正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。</p><a id="more"></a><hr><p>所以我们判断一个字符串是否是合法的Email的方法是：</p><p>创建一个匹配Email的正则表达式；</p><p>用该正则表达式去匹配用户的输入来判断是否合法。</p><p>因为正则表达式也是用字符串表示的，所以，我们要首先了解如何用字符来描述字符。</p><p>在正则表达式中，如果直接给出字符，就是精确匹配。用<code>\d</code>可以匹配一个数字，<code>\w</code>可以匹配一个字母或数字，所以：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&apos;00\d&apos;可以匹配&apos;007&apos;，但无法匹配&apos;00A&apos;；</span><br><span class="line"></span><br><span class="line">&apos;\d\d\d&apos;可以匹配&apos;010&apos;；</span><br><span class="line"></span><br><span class="line">&apos;\w\w\d&apos;可以匹配&apos;py3&apos;；</span><br><span class="line"></span><br><span class="line">.可以匹配任意字符，所以：</span><br><span class="line"></span><br><span class="line">&apos;py.&apos;可以匹配&apos;pyc&apos;、&apos;pyo&apos;、&apos;py!&apos;等等。</span><br></pre></td></tr></table></figure></p><p>要匹配变长的字符，在正则表达式中，用<code>*</code>表示任意个字符（包括0个），用<code>+</code>表示至少一个字符，用<code>?</code>表示0个或1个字符，用<code>{n}</code>表示n个字符，用<code>{n,m}</code>表示n-m个字符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">来看一个复杂的例子：\d&#123;3&#125;\s+\d&#123;3,8&#125;。</span><br><span class="line"></span><br><span class="line">我们来从左到右解读一下：</span><br><span class="line"></span><br><span class="line">\d&#123;3&#125;表示匹配3个数字，例如&apos;010&apos;；</span><br><span class="line"></span><br><span class="line">\s可以匹配一个空格（也包括Tab等空白符），所以\s+表示至少有一个空格，例如匹配&apos; &apos;，&apos; &apos;等；</span><br><span class="line"></span><br><span class="line">\d&#123;3,8&#125;表示3-8个数字，例如&apos;1234567&apos;。</span><br></pre></td></tr></table></figure></p><p>综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。</p><p>如果要匹配<code>&#39;010-12345&#39;</code>这样的号码呢？由于<code>&#39;-&#39;</code>是特殊字符，在正则表达式中，要用<code>&#39;\&#39;</code>转义，所以，上面的正则是<code>\d{3}\-\d{3,8}</code>。</p><p>但是，仍然无法匹配<code>&#39;010 - 12345&#39;</code>，因为带有空格。所以我们需要更复杂的匹配方式。</p><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>要做更精确地匹配，可以用<code>[]</code>表示范围，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[0-9a-zA-Z\_]可以匹配一个数字、字母或者下划线；</span><br><span class="line"></span><br><span class="line">[0-9a-zA-Z\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，比如&apos;a100&apos;，&apos;0_Z&apos;，&apos;Py3000&apos;等等；</span><br><span class="line"></span><br><span class="line">[a-zA-Z\_][0-9a-zA-Z\_]*可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；</span><br><span class="line"></span><br><span class="line">[a-zA-Z\_][0-9a-zA-Z\_]&#123;0, 19&#125;更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</span><br></pre></td></tr></table></figure></p><p><code>A|B</code>可以匹配A或B，所以<code>(P|p)ython</code>可以匹配<code>&#39;Python&#39;或者&#39;python&#39;</code>。</p><p><code>^</code>表示行的开头，<code>^\d</code>表示必须以数字开头。</p><p><code>$</code>表示行的结束，<code>\d$</code>表示必须以数字结束。</p><p>你可能注意到了，<code>py</code>也可以匹配<code>&#39;python&#39;</code>，但是加上<code>^py$</code>就变成了整行匹配，就只能匹配<code>&#39;py&#39;</code>了。</p><h3 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h3><p>有了准备知识，我们就可以在Python中使用正则表达式了。Python提供re模块，包含所有正则表达式的功能。由于Python的字符串本身也用\转义，所以要特别注意：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &apos;ABC\\-001&apos; # Python的字符串</span><br><span class="line"># 对应的正则表达式字符串变成：</span><br><span class="line"># &apos;ABC\-001&apos;</span><br></pre></td></tr></table></figure></p><p>因此我们强烈建议使用Python的<code>r</code>前缀，就不用考虑转义的问题了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = r&apos;ABC\-001&apos; # Python的字符串</span><br><span class="line"># 对应的正则表达式字符串不变：</span><br><span class="line"># &apos;ABC\-001&apos;</span><br></pre></td></tr></table></figure></p><p>先看看如何判断正则表达式是否匹配：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import re</span><br><span class="line">&gt;&gt;&gt; re.match(r&apos;^\d&#123;3&#125;\-\d&#123;3,8&#125;$&apos;, &apos;010-12345&apos;)</span><br><span class="line">&lt;_sre.SRE_Match object; span=(0, 9), match=&apos;010-12345&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; re.match(r&apos;^\d&#123;3&#125;\-\d&#123;3,8&#125;$&apos;, &apos;010 12345&apos;)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><p><code>match()</code>方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。常见的判断方法就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test = &apos;用户输入的字符串&apos;</span><br><span class="line">if re.match(r&apos;正则表达式&apos;, test):</span><br><span class="line">    print(&apos;ok&apos;)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;failed&apos;)</span><br></pre></td></tr></table></figure></p><h3 id="切分字符串"><a href="#切分字符串" class="headerlink" title="切分字符串"></a>切分字符串</h3><p>用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &apos;a b   c&apos;.split(&apos; &apos;)</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;&apos;, &apos;&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure></p><p>嗯，无法识别连续的空格，用正则表达式试试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; re.split(r&apos;\s+&apos;, &apos;a b   c&apos;)</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure></p><p>无论多少个空格都可以正常分割。加入,试试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; re.split(r&apos;[\s\,]+&apos;, &apos;a,b, c  d&apos;)</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]</span><br></pre></td></tr></table></figure></p><p>再加入;试试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; re.split(r&apos;[\s\,\;]+&apos;, &apos;a,b;; c  d&apos;)</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]</span><br></pre></td></tr></table></figure></p><p>如果用户输入了一组标签，下次记得用正则表达式来把不规范的输入转化成正确的数组。</p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用<code>()</code>表示的就是要提取的分组<code>（Group）</code>。比如：</p><p><code>^(\d{3})-(\d{3,8})$</code>分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; m = re.match(r&apos;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&apos;, &apos;010-12345&apos;)</span><br><span class="line">&gt;&gt;&gt; m</span><br><span class="line">&lt;_sre.SRE_Match object; span=(0, 9), match=&apos;010-12345&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; m.group(0)</span><br><span class="line">&apos;010-12345&apos;</span><br><span class="line">&gt;&gt;&gt; m.group(1)</span><br><span class="line">&apos;010&apos;</span><br><span class="line">&gt;&gt;&gt; m.group(2)</span><br><span class="line">&apos;12345&apos;</span><br></pre></td></tr></table></figure></p><p>如果正则表达式中定义了组，就可以在<code>Match</code>对象上用<code>group()</code>方法提取出子串来。</p><p>注意到<code>group(0)</code>永远是原始字符串，<code>group(1)、group(2)……</code>表示第1、2、……个子串。</p><p>提取子串非常有用。来看一个更凶残的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = &apos;19:05:30&apos;</span><br><span class="line">&gt;&gt;&gt; m = re.match(r&apos;^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$&apos;, t)</span><br><span class="line">&gt;&gt;&gt; m.groups()</span><br><span class="line">(&apos;19&apos;, &apos;05&apos;, &apos;30&apos;)</span><br></pre></td></tr></table></figure></p><p>这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$&apos;</span><br></pre></td></tr></table></figure></p><p>对于<code>&#39;2-30&#39;，&#39;4-31&#39;</code>这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。</p><h3 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h3><p>最后需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; re.match(r&apos;^(\d+)(0*)$&apos;, &apos;102300&apos;).groups()</span><br><span class="line">(&apos;102300&apos;, &apos;&apos;)</span><br></pre></td></tr></table></figure></p><p>由于<code>\d+</code>采用贪婪匹配，直接把后面的<code>0</code>全部匹配了，结果<code>0*</code>只能匹配空字符串了。</p><p>必须让<code>\d+</code>采用非贪婪匹配（也就是尽可能少匹配），才能把后面的<code>0</code>匹配出来，加个<code>?</code>就可以让<code>\d+</code>采用非贪婪匹配：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; re.match(r&apos;^(\d+?)(0*)$&apos;, &apos;102300&apos;).groups()</span><br><span class="line">(&apos;1023&apos;, &apos;00&apos;)</span><br></pre></td></tr></table></figure></p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>当我们在Python中使用正则表达式时，re模块内部会干两件事情：</p><p>编译正则表达式，如果正则表达式的字符串本身不合法，会报错；</p><p>用编译后的正则表达式去匹配字符串。</p><p>如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import re</span><br><span class="line"># 编译:</span><br><span class="line">&gt;&gt;&gt; re_telephone = re.compile(r&apos;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&apos;)</span><br><span class="line"># 使用：</span><br><span class="line">&gt;&gt;&gt; re_telephone.match(&apos;010-12345&apos;).groups()</span><br><span class="line">(&apos;010&apos;, &apos;12345&apos;)</span><br><span class="line">&gt;&gt;&gt; re_telephone.match(&apos;010-8086&apos;).groups()</span><br><span class="line">(&apos;010&apos;, &apos;8086&apos;)</span><br></pre></td></tr></table></figure></p><p>编译后生成Regular Expression对象，由于该对象自己包含了正则表达式，所以调用对应的方法时不用给出正则字符串。</p><p><strong>小结</strong><br>正则表达式非常强大，要在短短的一节里讲完是不可能的。要讲清楚正则的所有内容，可以写一本厚厚的书了。如果你经常遇到正则表达式的问题，你可能需要一本正则表达式的参考书。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;字符串是编程时涉及到的最多的一种数据结构，对字符串进行操作的需求几乎无处不在。比如判断一个字符串是否是合法的Email地址，虽然可以编程提取@前后的子串，再分别判断是否是单词和域名，但这样做不但麻烦，而且代码难以复用。&lt;/p&gt;
&lt;p&gt;正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。&lt;/p&gt;
    
    </summary>
    
      <category term="编程相关" scheme="https://paradoxallen.github.io/categories/%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="python" scheme="https://paradoxallen.github.io/tags/python/"/>
    
  </entry>
  
</feed>
