<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>paradox&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://paradoxallen.github.io/"/>
  <updated>2018-06-01T12:08:49.553Z</updated>
  <id>https://paradoxallen.github.io/</id>
  
  <author>
    <name>paradox</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习(二) 模型调优</title>
    <link href="https://paradoxallen.github.io/4840/"/>
    <id>https://paradoxallen.github.io/4840/</id>
    <published>2018-05-31T16:00:00.000Z</published>
    <updated>2018-06-01T12:08:49.553Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前文传送"><a href="#前文传送" class="headerlink" title="前文传送"></a>前文传送</h4><p><a href="https://paradoxallen.github.io/9731/">机器学习（一）——算法介绍</a></p><p>前面讲了一些机器学习的算法的介绍，如果有一些数据这时候也可以建立出自己的模型了，但是，如果模型的效果不尽人意，那么应该如何调整呢？</p><p>以下是一份关于模型调优的方法，每当出现效果不好的时候或者是在建模前，都可以按照这个来进行检查，话不多说，一起来看～</p><p><img src="http://i2.bvimg.com/647637/9208883f4c7aeb45.jpg" alt=""></p><a id="more"></a><hr><p>为了文章阅读的清晰，先在前面简单说明一下文章的目录框架。</p><p>本文存在的意义在于辅助大家提升机器学习模型的效果，方法有很多，如果你在其中的一个办法中找到了突破，仍可以回头再找其他，直到满足你的模型效果要求，主要从4个角度来进行方法的阐述，分别是：</p><ul><li>Improve Performance With Data.（数据）</li><li>Improve Performance With Algorithms.（算法选择）</li><li>Improve Performance With Algorithm Tuning.（算法调优）</li><li>Improve Performance With Ensembles.（效果集成）</li></ul><p>好的，下面就分别从这4个角度来说一下。</p><h3 id="1-Improve-Performance-With-Data（数据）"><a href="#1-Improve-Performance-With-Data（数据）" class="headerlink" title="1. Improve Performance With Data（数据）"></a>1. Improve Performance With Data（数据）</h3><p>事实上，你直接改变训练数据或者改变目标的定义，好效果会来得更加“不费吹灰之力”，有的时候还可能是最好的操作，所以有一句话说得很有道理：<strong>选择比努力重要哈哈哈</strong>。</p><p>话不多说，说下Strategy: 创建不同的目标样本并且尽量使用最底层的特征来训练模型算法。</p><p><strong>具体策略：</strong></p><p>获得更多的数据：一个好的深度学习模型需要更多的数据来训练，其他非线性的机器学习模型也是如此。</p><ul><li>开发更多变量：如果你实在不能获得更多的数据亦或是更好质量的数据，也许可以通过概率模型、统计模型来生成新的变量。</li><li>清洗数据：通过数据清洗，你可以对缺失值、异常值进行合理的填补与修复，从而提升数据整体的质量。</li><li>重新采样数据：其实可以通过对数据的重新采样来改变数据的分布和大小。对某一特定类型的样本进行采样，说不定可以更好滴表现出效果。又或者是使用更小的数据，从而加快速度。</li><li>问题解决思路的重新思考：有的时候，你可以把你目前正在“焦头烂耳”想要解决的“预测性”问题，换成回归、分类、时间序列、异常检测、排序、推荐等等的问题。</li><li>调整变量再入模：这里指的是对数据进行离散化、标准化等的操作。</li><li>改变现有的变量：这里相信大家也很常见，就是对变量进行对数转换或指数转换，让其特性能更好地表现。</li><li>对变量进行降维：有的时候降维后的变量有更好的表现哦。</li><li>特征选择：这个就是特征工程了，简单来说，就是你对特征（变量）进行重要性的排序，选择相对预测力强的特征进入模型。</li></ul><h3 id="2-Improve-Performance-With-Algorithms（算法选择）"><a href="#2-Improve-Performance-With-Algorithms（算法选择）" class="headerlink" title="2. Improve Performance With Algorithms（算法选择）"></a>2. Improve Performance With Algorithms（算法选择）</h3><p>机器学习其实都是关于算法的学习。</p><p>Strategy: 识别出优于平均值的算法，但要对其实验过程以及结果抱着怀疑态度，并反复思考。</p><p><strong>具体策略：</strong></p><ul><li>重采样方法：使用什么方法来估计效果？有个原则就是要充分利用可用的数据来验证，这里，k-fold交叉验证方法可以是最好的哦。</li><li>评价指标：不同的目标需要使用不同的评价指标，这个相信大家在学习混淆矩阵的时候应该有所了解，什么pv+，命中率等等，都是对于特定类型的目标有着非常有效的识别。如果是一个排序性的问题，而你却用了准确度的指标来衡量模型的好坏似乎也说不过去把？</li><li>关注线性算法：线性算法通常会不那么好用，但是却更好地被人类理解且可以快速测试，如果你发现某个线性算法表现地还行，请继续优化它。</li><li>关注非线性算法：非线性算法往往会需要更多的数据，通过更加复杂的计算来获得一个不错的效果。</li><li>从文献中找ideas：这个方法还经常做，从文献中可以了解到更多的经典算法在特定需要下的应用，通过对文献的阅读来扩充你的“解题”思路把。</li></ul><h3 id="3-Improve-Performance-With-Algorithm-Tuning（算法调优）"><a href="#3-Improve-Performance-With-Algorithm-Tuning（算法调优）" class="headerlink" title="3. Improve Performance With Algorithm Tuning（算法调优）"></a>3. Improve Performance With Algorithm Tuning（算法调优）</h3><p>模型调参也是一个非常费时间的环节，有的时候“好运”可以马上抽查出表现还不错的结果，并持续调参，就可以得到一个不错的结果。但如果要对其他所有的算法进行优化，那么需要的时间就可能是几天、几个星期或者几个月了。</p><p>Strategy: 充分利用性能良好的机器学习算法。</p><p><strong>具体策略：</strong></p><ul><li>诊断方法：不同的算法需要提供不同的可视化和诊断的方法。</li><li>调参的直觉：这个就很“玄学”了，但其实都是一些经验，当你调的参足够多，也可以大致可以对这些不同算法的参数有了自己的理解，自然就有了这些所谓的“直觉”。</li><li>随机搜索：在N维参数空间按某种分布（如正态分布）随机取值，因为参数空间的各个维度的重要性是不等的，随机搜索方法可以在不重要的维度上取巧。</li><li>网格搜索：先固定一个超参，然后对其他各个超参依次进行穷举搜索。</li><li>从文献中找ideas：从文献中了解这个算法用到了哪些算法，并且这些算法主要的取值值域，有益于自身工作的开展哦。</li><li>从知名网站中找ideas：国内我个人觉得知乎还是蛮可以的，关于这节的参数调参，也是有好多好文章，其外还有csdn也不错。</li></ul><h3 id="4-Improve-Performance-With-Ensembles（效果集成）"><a href="#4-Improve-Performance-With-Ensembles（效果集成）" class="headerlink" title="4. Improve Performance With Ensembles（效果集成）"></a>4. Improve Performance With Ensembles（效果集成）<code></code></h3><p>这个算法集成的方法也是非常常用的，你可以结合多个模型的结果，综合输出一个更加稳定且效果不错的结果。</p><p>Strategy: 结合各种模型的预测结果并输出。</p><p><strong>具体策略：</strong></p><ul><li>混合模型的预测值：你可以把多个模型的预测结果结合起来，你可以将多个训练效果还不错的模型的预测结合综合起来，输出一个“平均”结果。</li><li>混合不同数据的预测值：你也可以把不同的数据集训练出来模型的结果进行结合，作为一个输出。（这个与上面的区别在于数据集的特征不同）</li><li>混合数据样本：很拗口，其实意思就是将数据集拆分成不同的子数据集，用于训练同一个算法，最后输出综合的预测结果。这个也被称之为bootstrap aggregation 或 bagging。</li><li>使用模型的方法集成：你也可以使用一个新的模型来学习如何结合多个性能不错的模型结果，输出一个最优的结合。这被称之为堆叠泛化或叠加，通常在子模型有技巧时很有效，但在不同的方式下，聚合器模型是预测的一个简单的线性加权。这个过程可以重复多层深度。</li></ul><p>##参考资料<br>1）<a href="https://machinelearningmastery.com/a-tour-of-machine-learning-algorithms/" target="_blank" rel="noopener">A Tour of Machine Learning Algorithms</a></p><p>2）<a href="https://www.zhihu.com/question/34470160?sort=created" target="_blank" rel="noopener">机器学习各种算法怎么调参?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前文传送&quot;&gt;&lt;a href=&quot;#前文传送&quot; class=&quot;headerlink&quot; title=&quot;前文传送&quot;&gt;&lt;/a&gt;前文传送&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://paradoxallen.github.io/9731/&quot;&gt;机器学习（一）——算法介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前面讲了一些机器学习的算法的介绍，如果有一些数据这时候也可以建立出自己的模型了，但是，如果模型的效果不尽人意，那么应该如何调整呢？&lt;/p&gt;
&lt;p&gt;以下是一份关于模型调优的方法，每当出现效果不好的时候或者是在建模前，都可以按照这个来进行检查，话不多说，一起来看～&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.bvimg.com/647637/9208883f4c7aeb45.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据分析" scheme="https://paradoxallen.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="机器学习" scheme="https://paradoxallen.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="模型" scheme="https://paradoxallen.github.io/tags/%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>机器学习(一) 算法介绍</title>
    <link href="https://paradoxallen.github.io/9731/"/>
    <id>https://paradoxallen.github.io/9731/</id>
    <published>2018-05-30T16:00:00.000Z</published>
    <updated>2018-06-01T12:00:14.366Z</updated>
    
    <content type="html"><![CDATA[<p>前阵子阅读了院里一位博士研究生师兄的一篇有关基于神经网络算法对北京近五年的常规探空数据进行自组织分类，并揭示出大气污染物在不同边界层结构下的演变规律和相关机制的文章<a href="https://www.atmos-chem-phys.net/18/6771/2018/" target="_blank" rel="noopener">《Self-organized classification of boundary layer meteorology and associated characteristics of air quality in Beijing》</a>，看完顿时心生膜拜之情；然后恰巧也是那个时候吕教授在院群上也转发了一篇关于机器学习预测火势甚至天气的公众号文章<a href="https://mp.weixin.qq.com/s?__biz=MjM5ODE1NDYyMA==&amp;mid=2653384819&amp;idx=2&amp;sn=523f27cb9442ab4af27137edd1280248&amp;chksm=bd1cc8608a6b4176d7cae939f794e082cf86b5bf0ac0deb53790f507f563f588b2148687957c&amp;mpshare=1&amp;scene=1&amp;srcid=0517RYcQWk5dWJCcqoI7jLCe#rd" target="_blank" rel="noopener">《机器学习成功解决“蝴蝶效应”！以后你终于可以相信天气预报了》</a>。</p><p>如此的机缘巧合，我自己也想在这一方向进行深入了解，从基本的概述理论方法开始。</p><a id="more"></a><hr><p>算法很多，如何做好分组有助于我们更好记住它们，主要有2条算法分组的方式：</p><ul><li><p>The first is a grouping of algorithms by the learning style.（通过算法的学习方式）</p></li><li><p>The second is a grouping of algorithms by similarity in form or function (like grouping similar animals together).（通过算法的功能）</p></li></ul><p>下面就会从这2个角度来阐述一下机器学习的算法。</p><p><img src="http://i4.bvimg.com/647637/c8333c245bbeada6.png" alt=""></p><h2 id="Algorithms-Grouped-by-Learning-Style（通过算法的学习方式）"><a href="#Algorithms-Grouped-by-Learning-Style（通过算法的学习方式）" class="headerlink" title="Algorithms Grouped by Learning Style（通过算法的学习方式）"></a>Algorithms Grouped by Learning Style（通过算法的学习方式）</h2><p>关于机器学习算法，有三种不同的学习方式：</p><h3 id="1-Supervised-Learning（监督学习）"><a href="#1-Supervised-Learning（监督学习）" class="headerlink" title="1. Supervised Learning（监督学习）"></a>1. Supervised Learning（监督学习）</h3><p>当输入的数据集（我们称之为训练集）的数据有标签，如好坏标签，分类标签等，那么通过这些数据来建立的预测或者分类模型，属于监督学习模型。</p><ul><li><p>经典问题：classification and regression.（分类与回归）</p></li><li><p>经典算法：Logistic Regression and the Back Propagation Neural Network.（逻辑回归算法与BP神经网络算法）</p></li></ul><p><img src="http://i4.bvimg.com/647637/98402ff904a2e723.png" alt=""></p><h3 id="2-Unsupervised-Learning（无监督学习）"><a href="#2-Unsupervised-Learning（无监督学习）" class="headerlink" title="2. Unsupervised Learning（无监督学习）"></a>2. Unsupervised Learning（无监督学习）</h3><p>与监督学习相反，训练集中的数据并没有标签，这意味着你需要从这堆没有标签的数据中去提炼它们的特点规则等等，可能是通过数学推理过程来系统地减少冗余，又或者是通过数据相似度来组织数据。</p><ul><li><p>经典问题：clustering, dimensionality reduction and association rule learning.（聚类、降维、规则学习）</p></li><li><p>经典算法：the Apriori algorithm and k-Means.（这个专用名词就不翻译了）</p></li></ul><p><img src="http://i4.bvimg.com/647637/1559c4d4bbbd73c2.png" alt=""></p><h3 id="3-Semi-Supervised-Learning（半监督学习）"><a href="#3-Semi-Supervised-Learning（半监督学习）" class="headerlink" title="3. Semi-Supervised Learning（半监督学习）"></a>3. Semi-Supervised Learning（半监督学习）</h3><p>顾名思义，半监督学习意味着训练数据有一部分有标签，而一些没有，一般而言，当训练数据量过少时，监督学习得到的模型效果不能满足需求，因此用半监督学习来增强效果。</p><ul><li><p>经典问题：classification and regression.</p></li><li><p>经典算法：半监督SVM，高斯模型，KNN模型</p></li></ul><p><img src="http://i4.bvimg.com/647637/fc0034f6bf008c55.png" alt=""></p><h2 id="Algorithms-Grouped-By-Similarity（通过算法的功能）"><a href="#Algorithms-Grouped-By-Similarity（通过算法的功能）" class="headerlink" title="Algorithms Grouped By Similarity（通过算法的功能）"></a>Algorithms Grouped By Similarity（通过算法的功能）</h2><p>根据算法的功能相似性来区分算法也是一种很好的办法，如基于树结构的算法或者基于神经网络的算法。所以我觉得从这个角度来了解这些算法会更加好。<br>即便这是一个很好的方式，但也绝非完美，仍会有一些算法不能简单地被归类，比如Learning Vector Quantization（LVQ，学习矢量量化算法），它既是神经网络，也是基于距离的算法，所以下面的归类也只是适用于大多数算法，但是常用的算法。</p><h3 id="1-Regression-Algorithms（回归算法）"><a href="#1-Regression-Algorithms（回归算法）" class="headerlink" title="1. Regression Algorithms（回归算法）"></a>1. Regression Algorithms（回归算法）</h3><p>回归更多地关注自变量与因变量之间的关系，并通过对误差的测算来建模，回归算法是对于数学统计的一个很好应用，也被纳入统计机器学习中。</p><p>常见的回归算法包括：</p><ul><li><p>Ordinary Least Squares Regression (OLSR，普通最小二乘回归)</p></li><li><p>Linear Regression（线性回归）</p></li><li><p>Logistic Regression（逻辑回归）</p></li><li><p>Stepwise Regression（逐步回归）</p></li><li><p>Adaptive Regression Splines (MARS，多元自适应回归)</p></li><li><p>Locally Estimated Scatterplot Smoothing (LOESS，本地散点平滑估计)</p></li></ul><p><img src="http://i4.bvimg.com/647637/7d5edfbfdacf0ce5.png" alt=""></p><h3 id="2-Instance-based-Algorithms（基于距离的算法）"><a href="#2-Instance-based-Algorithms（基于距离的算法）" class="headerlink" title="2. Instance-based Algorithms（基于距离的算法）"></a>2. Instance-based Algorithms（基于距离的算法）</h3><p>基于距离学习的模型非常常见，这类的模型是对训练集数据进行建模并比较新数据与之的距离，而距离的衡量有很多，常见的是欧氏距离、曼哈顿距离等。</p><p>常见的算法包括：</p><ul><li><p>k-Nearest Neighbor (kNN)</p></li><li><p>Learning Vector Quantization (LVQ，学习矢量量化)</p></li><li><p>Self-Organizing Map (SOM，自组织映射)</p></li><li><p>Locally Weighted Learning (LWL，局部加权学习)</p></li></ul><p><img src="http://i4.bvimg.com/647637/7bde9d592d1937db.png" alt=""></p><h3 id="3-Regularization-Algorithms（正则化算法）"><a href="#3-Regularization-Algorithms（正则化算法）" class="headerlink" title="3. Regularization Algorithms（正则化算法）"></a>3. Regularization Algorithms（正则化算法）</h3><p>正则化是对另一种方法(通常是回归方法)的扩展，使基于其复杂性的模型受到惩罚，支持更简单的模型，这些模型在泛化能力方面也比较好。</p><p>常见的正则化算法包括：<br>Ridge Regression（岭回归算法）<br>Least Absolute Shrinkage and Selection Operator (LASSO算法，稀疏约束)<br>Elastic Net（弹性网络）<br>Least-Angle Regression (LARS，最小角回归算法)</p><p><img src="http://i4.bvimg.com/647637/c6951c24ab35ec34.png" alt=""></p><h3 id="4-Decision-Tree-Algorithms（决策树算法）"><a href="#4-Decision-Tree-Algorithms（决策树算法）" class="headerlink" title="4. Decision Tree Algorithms（决策树算法）"></a>4. Decision Tree Algorithms（决策树算法）</h3><p>决策树方法构建基于数据中属性的实际值来建模的，决策树经常被训练用于分类和回归问题，决策树通常是快速和准确的，并且是机器学习中最受欢迎的。</p><p>常见的决策树算法包括：</p><ul><li><p>Classification and Regression Tree (CART，分类回归树算法)</p></li><li><p>Iterative Dichotomiser 3 (ID3)</p></li><li><p>C4.5 and C5.0 (不同版本的区别)</p></li><li><p>Chi-squared Automatic Interaction Detection (CHAID)</p></li><li><p>Decision Stump（决策树桩）</p></li><li><p>MD5（Message-Digest Algorithm，讯息摘要算法）</p></li><li><p>Decision Trees（条件决策树）</p></li></ul><p><img src="http://i4.bvimg.com/647637/822d6578c331ab38.png" alt=""></p><h3 id="5-Bayesian-Algorithms（贝叶斯算法）"><a href="#5-Bayesian-Algorithms（贝叶斯算法）" class="headerlink" title="5. Bayesian Algorithms（贝叶斯算法）"></a>5. Bayesian Algorithms（贝叶斯算法）</h3><p>基于贝叶斯定理的方式来构建的算法，常用语分类与回归问题。</p><p>常见的贝叶斯算法包括：</p><ul><li><p>Naive Bayes（朴素贝叶斯）</p></li><li><p>Gaussian Naive Bayes（高斯朴素贝叶斯）</p></li><li><p>Multinomial Naive Bayes（多项式朴素贝叶斯）</p></li><li><p>Averaged One-Dependence Estimators (AODE)</p></li><li><p>Belief Network (BBN，贝叶斯定理网络)</p></li><li><p>Bayesian Network (BN，贝叶斯网络)</p></li></ul><p><img src="http://i4.bvimg.com/647637/1c88f6233fffff9c.png" alt=""></p><h3 id="6-Clustering-Algorithms（聚类算法）"><a href="#6-Clustering-Algorithms（聚类算法）" class="headerlink" title="6. Clustering Algorithms（聚类算法）"></a>6. Clustering Algorithms（聚类算法）</h3><p>聚类分析又称群分析，它是研究（样品或指标）分类问题的一种统计分析方法，同时也是数据挖掘的一个重要算法。<br>聚类（Cluster）分析是由若干模式（Pattern）组成的，通常，模式是一个度量（Measurement）的向量，或者是多维空间中的一个点。<br>聚类分析以相似性为基础，在一个聚类中的模式之间比不在同一聚类中的模式之间具有更多的相似性。</p><p>常见的聚类算法包括：<br>k-Means<br>k-Medians<br>Expectation Maximisation (EM，Expectation Maximization Algorithm，是一种迭代算法)<br>Hierarchical Clustering（层次聚类）</p><p><img src="http://i4.bvimg.com/647637/ffcd3a96458da550.png" alt=""></p><h3 id="7-Association-Rule-Learning-Algorithms（关联规则学习算法）"><a href="#7-Association-Rule-Learning-Algorithms（关联规则学习算法）" class="headerlink" title="7. Association Rule Learning Algorithms（关联规则学习算法）"></a>7. Association Rule Learning Algorithms（关联规则学习算法）</h3><p>关联规则学习方法提取的规则最能解释数据中变量之间的关系，这些规则可以在大型多维数据集中发现重要和商业有用的关联，而被组织利用。</p><p>最常见的算法包括：</p><ul><li><p>Apriori algorithm</p></li><li><p>Eclat algorithm</p></li></ul><p><img src="http://i4.bvimg.com/647637/862e1ef2bd8cb2b6.png" alt=""></p><h3 id="8-Artificial-Neural-Network-Algorithms（人工神经网络算法）"><a href="#8-Artificial-Neural-Network-Algorithms（人工神经网络算法）" class="headerlink" title="8. Artificial Neural Network Algorithms（人工神经网络算法）"></a>8. Artificial Neural Network Algorithms（人工神经网络算法）</h3><p>人工神经网络是受生物神经网络结构和/或功能启发的模型，它们是一类模式匹配，通常用于回归和分类问题，但实际上是一个巨大的子字段，包含数百种算法和各种类型的问题类型。</p><p>最常见的算法包括：</p><ul><li><p>Perceptron（感知器）</p></li><li><p>Back-Propagation（反向传播法）</p></li><li><p>Hopfield Network（霍普菲尔网络）</p></li><li><p>Radial Basis Function Network (RBFN，径向基函数网络)</p></li></ul><p><img src="http://i4.bvimg.com/647637/f1c3d36096b5b753.png" alt=""></p><h3 id="9-Deep-Learning-Algorithms（深度学习算法）"><a href="#9-Deep-Learning-Algorithms（深度学习算法）" class="headerlink" title="9. Deep Learning Algorithms（深度学习算法）"></a>9. Deep Learning Algorithms（深度学习算法）</h3><p>深度学习方法是利用大量廉价计算的人工神经网络的更新，它关心的是构建更大更复杂的神经网络，正如上面所提到的，许多方法都与半监督学习问题有关，在这些问题中，大型数据集包含的标签数据非常少。</p><p>最常见的算法包括：</p><ul><li><p>Deep Boltzmann Machine (DBM)</p></li><li><p>Deep Belief Networks (DBN)</p></li><li><p>Convolutional Neural Network (CNN)</p></li><li><p>Stacked Auto-Encoders</p></li></ul><p><img src="http://i4.bvimg.com/647637/42c64e10881d9023.png" alt=""></p><h3 id="10-Dimensionality-Reduction-Algorithms（降维算法）"><a href="#10-Dimensionality-Reduction-Algorithms（降维算法）" class="headerlink" title="10. Dimensionality Reduction Algorithms（降维算法）"></a>10. Dimensionality Reduction Algorithms（降维算法）</h3><p>像聚类方法一样，维数的减少有利于寻找到数据的关联关系，但在这种情况下，是不受监督的方式，或者用较少的信息来概括或描述数据。<br>这些方法中的许多可以用于分类和回归。</p><p>常见的算法包括：</p><ul><li><p>Principal Component Analysis (PCA)</p></li><li><p>Principal Component Regression (PCR)</p></li><li><p>Partial Least Squares Regression (PLSR)</p></li><li><p>Sammon Mapping</p></li><li><p>Multidimensional Scaling (MDS)</p></li><li><p>Projection Pursuit</p></li><li><p>Linear Discriminant Analysis (LDA)</p></li><li><p>Mixture Discriminant Analysis (MDA)</p></li><li><p>Quadratic Discriminant Analysis (QDA)</p></li><li><p>Flexible Discriminant Analysis (FDA)</p></li></ul><p><img src="http://i4.bvimg.com/647637/aee45bf976e3f058.png" alt=""></p><h3 id="11-Ensemble-Algorithms（集成算法）"><a href="#11-Ensemble-Algorithms（集成算法）" class="headerlink" title="11. Ensemble Algorithms（集成算法）"></a>11. Ensemble Algorithms（集成算法）</h3><p>集成方法是由多个较弱的模型而组成的模型，这些模型是独立训练的，它们的预测在某种程度上是结合在一起来进行总体预测的。<br>这类算法是把更多精力放到了弱学习器身上，以及如何将它们结合起来。这是一门非常强大的技术，因此非常受欢迎。</p><p>常见的算法包括：</p><ul><li><p>Boosting</p></li><li><p>Bootstrapped Aggregation (Bagging)</p></li><li><p>AdaBoost</p></li><li><p>Stacked Generalization (blending)</p></li><li><p>Gradient Boosting Machines (GBM)</p></li><li><p>Gradient Boosted Regression Trees (GBRT)</p></li><li><p>Random Forest</p></li></ul><p><img src="http://i4.bvimg.com/647637/762ed312f28aa7be.png" alt=""></p><h3 id="12-Other-Algorithms（其他算法）"><a href="#12-Other-Algorithms（其他算法）" class="headerlink" title="12. Other Algorithms（其他算法）"></a>12. Other Algorithms（其他算法）</h3><p>还有很多算法没有被覆盖到，大概还有下面的算法：</p><p>Feature selection algorithms（特征选择算法）</p><ul><li><p>Algorithm accuracy evaluation（算法精度估计）</p></li><li><p>Performance measures（效果评估）</p></li><li><p>Computational intelligence (evolutionary algorithms, etc.)</p></li><li><p>Computer Vision (CV)</p></li><li><p>Natural Language Processing (NLP)</p></li><li><p>Recommender Systems</p></li><li><p>Reinforcement Learning</p></li><li><p>Graphical Models</p></li><li><p>And more…</p></li></ul><p>Further Reading<br>网络上对这些算法有更加详细的讲解，需要大家自己动手去查了，这样子才会更加了解这些算法内容，本文内容来自网络，还有一些我觉得很有用的资料也在下面，大家可以抽时间去细细研究哈。</p><p>##参考资料<br>1）<a href="https://machinelearningmastery.com/a-tour-of-machine-learning-algorithms/" target="_blank" rel="noopener">A Tour of Machine Learning Algorithms</a></p><p>2）<a href="https://www.zhihu.com/question/20691338/answer/53910077" target="_blank" rel="noopener">机器学习该如何入门——张松阳的回答</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前阵子阅读了院里一位博士研究生师兄的一篇有关基于神经网络算法对北京近五年的常规探空数据进行自组织分类，并揭示出大气污染物在不同边界层结构下的演变规律和相关机制的文章&lt;a href=&quot;https://www.atmos-chem-phys.net/18/6771/2018/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Self-organized classification of boundary layer meteorology and associated characteristics of air quality in Beijing》&lt;/a&gt;，看完顿时心生膜拜之情；然后恰巧也是那个时候吕教授在院群上也转发了一篇关于机器学习预测火势甚至天气的公众号文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5ODE1NDYyMA==&amp;amp;mid=2653384819&amp;amp;idx=2&amp;amp;sn=523f27cb9442ab4af27137edd1280248&amp;amp;chksm=bd1cc8608a6b4176d7cae939f794e082cf86b5bf0ac0deb53790f507f563f588b2148687957c&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0517RYcQWk5dWJCcqoI7jLCe#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《机器学习成功解决“蝴蝶效应”！以后你终于可以相信天气预报了》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如此的机缘巧合，我自己也想在这一方向进行深入了解，从基本的概述理论方法开始。&lt;/p&gt;
    
    </summary>
    
      <category term="数据分析" scheme="https://paradoxallen.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="机器学习" scheme="https://paradoxallen.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="https://paradoxallen.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>博客搭建——利用GitHub+Hexo</title>
    <link href="https://paradoxallen.github.io/13431/"/>
    <id>https://paradoxallen.github.io/13431/</id>
    <published>2018-05-29T16:00:00.000Z</published>
    <updated>2018-06-01T12:02:17.018Z</updated>
    
    <content type="html"><![CDATA[<p>一直想有一个可以记录的属于自己的博客，最近在知乎上看到了利用<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>+<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>搭建博客的教程，于是乎搭建了自己的博客<a href="https://paradoxallen.github.io/">paradoxallen</a>。</p><p>然而在此过程也遇到了一些bug，希望以下图文并茂的教程（虽然已经有挺多类似的教程…但主要是想自己写一篇文章!!!而且保证超级详细!!!）可以帮助大家少走弯路，搭建属于自己的博客。</p><a id="more"></a><hr><h2 id="GitHub配置"><a href="#GitHub配置" class="headerlink" title="GitHub配置"></a>GitHub配置</h2><p><a href="https://github.com/" target="_blank" rel="noopener">https://github.com/ </a>登录GitHub账号,如无GitHub帐号需要注册一个</p><p><img src="http://i1.bvimg.com/647637/c2c87e3a66d3f41c.png" alt=""></p><p>点击GitHub中的New repository创建新仓库</p><p><img src="http://i2.bvimg.com/647637/8cd2118322eeebb8.png" alt=""></p><p>仓库名应该为：用户名.<a href="http://github.io" target="_blank" rel="noopener">http://github.io</a> </p><p>这个用户名使用你的GitHub帐号名称代替，这是固定写法</p><p>如我的域名是<a href="http://github.com/paradoxallen" target="_blank" rel="noopener">github.com/paradoxallen</a>，就填入<a href="http://paradoxallen.github.io">paradoxallen.github.io</a></p><p>然后点击create repository创建仓库</p><p><img src="http://i2.bvimg.com/647637/7dee21bf61c6a269.png" alt=""></p><p>成功之后出现以下画面</p><p><img src="http://i4.bvimg.com/647637/9c9e7a4a292f769b.png" alt=""></p><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p><a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git-Downloading Package</a>选择下载Windows版本的64位或32位的安装包（也有MacOSX版本和Linux/Unix版本的，按需求下载）</p><p><img src="http://i4.bvimg.com/647637/c8ab66c94a5b8923.png" alt=""></p><p>下载后安装，基本按默认安装就行，安装成功后，鼠标右键打开Git Bash</p><p><img src="http://i2.bvimg.com/647637/1a613567dfe1c628.png" alt=""></p><p>然后设置user.name和user.email配置信息<br><code>git config --global user.name &quot;你的GitHub用户名&quot;</code><br><code>git config --global user.email &quot;你的GitHub注册邮箱&quot;</code></p><p>生成ssh密钥文件：<br><code>ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</code></p><p><img src="http://i2.bvimg.com/647637/d7a3ae0382cff29c.png" alt=""></p><p>然后直接三个回车，无需设置密码</p><p>在找到生成的.ssh的文件夹中的id-rsa.pub密钥，将内容全部复制</p><p><img src="http://i2.bvimg.com/647637/71af645c415b05d6.png" alt=""></p><p>打开<a href="https://github.com/settings/keys/new" target="_blank" rel="noopener">GitHub-Settings-SSHandGPGkeys-newSHHkeys</a>新建</p><p><img src="http://i4.bvimg.com/647637/410f443eedb161d1.png" alt=""></p><p>Title随意，Key粘贴id-rsa.pub内容，最后点击Add SHH key</p><p>在Git Bash中检测GitHub公钥是否设置成功，输入<code>ssh git@github.com</code>如下则说明成功</p><p><img src="http://i4.bvimg.com/647637/2e82b66bd44b0528.png" alt=""></p><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p><a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Download|Node.js</a>选择下载安装包，也是默认设置安装就好</p><p><img src="http://i4.bvimg.com/647637/c7552174b3bafe3b.png" alt=""></p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>这里需要在自己电脑中新建文件夹，如命名为blog</p><p>进入文件夹，按住shift键，右击鼠标点击在此处打开Powershell窗口</p><p>（有些教程是打开命令行，但好像是win10才有的powershell)</p><p><img src="http://i2.bvimg.com/647637/035c259ae9e63ed0.png" alt=""></p><p>然后依次输入：</p><p><code>npm install -g hexo-cli</code>安装Hexo</p><p><code>hexo init blog</code>初始化Hexo</p><p>成功提示<code>INFO  Start blogging with Hexo!</code></p><p>（因为我已经设置好就不重新初始化啦）</p><p>因为你初始化hexo 之后source目录下自带一篇hello world文章, 所以直接执行下方命令<br><code>hexo g</code> </p><p><code>hexo s</code>启动本地服务器</p><p>成功提示<br><code>INFO  Start processing</code><br><code>INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</code></p><p><img src="http://i4.bvimg.com/647637/e262c409d50dc6b2.png" alt=""></p><p>在浏览器输入<code>http://localhost:4000/</code>就可以看见网页和模板了（因为我修改过主题可能有点出入）</p><p><img src="http://i4.bvimg.com/647637/1a5c5f97074e6f7d.png" alt=""></p><h2 id="网站推送"><a href="#网站推送" class="headerlink" title="网站推送"></a>网站推送</h2><p>打开blog根目录_config.yml文件，将Hexo与GitHub关联起来</p><p><img src="http://i4.bvimg.com/647637/f4980b87d2c9f2ff.png" alt=""></p><p><code>deploy:</code></p><p><code>type: git</code></p><p><code>repo: GitHub上创建仓库的完整路径，加上 .git</code></p><p><code>branch: master</code></p><p>参考如下：</p><p><img src="http://i4.bvimg.com/647637/c150e9cde0adb7b3.png" alt=""></p><p>然后保存并执行命令：<br><code>npm install hexo-deployer-git --save</code></p><p>再依次输入三条命令:</p><p><code>hexo clean</code> </p><p><code>hexo g</code></p><p><code>hexo d</code></p><p>打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即 <a href="http://xxxx.github.io，如[paradoxallen.github.io](https://paradoxallen.github.io/)即可访问" target="_blank" rel="noopener">http://xxxx.github.io，如[paradoxallen.github.io](https://paradoxallen.github.io/)即可访问</a></p><p>此外，也可以打开_config.yml文件修改参数信息，如排版格式等等</p><h2 id="文章发布"><a href="#文章发布" class="headerlink" title="文章发布"></a>文章发布</h2><p>输入：<code>hexo new &quot;testing&quot;</code>打开文件使用markdown语法输入文字</p><p>保存，执行：</p><p><code>hexo clean</code></p><p><code>hexo g</code></p><p><code>hexo server</code></p><p><code>hexo deploy</code></p><p><img src="http://i2.bvimg.com/647637/408049f3884510e4.png" alt=""></p><p>就可以看到文章发布了~</p><p><img src="http://i2.bvimg.com/647637/bdb5ddb3bea1f960.png" alt=""></p><h2 id="总结陈词"><a href="#总结陈词" class="headerlink" title="总结陈词"></a>总结陈词</h2><p>搭建博客的步骤：</p><p>1、GitHub配置</p><p>2、环境安装</p><p>3、网站推送</p><p>4、文章发布</p><p>发布文章的步骤：</p><p>1、hexo new 创建文章</p><p>2、Markdown语法编辑文章</p><p>3、部署（所有打开CMD都是在blog目录下）</p><p>到这里已经完成了博客的搭建以及文章的发布，但是还有很多需要设置和调整的。</p><p>我也是刚刚搭建好博客，还有待博客界面的优化以及内容的丰富!!!</p><p>今天先到这里啦~</p><p>##参考资料<br>1.<a href="https://zhangslob.github.io/2017/02/28/%E6%95%99%E4%BD%A0%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%8CHexo-Github/" target="_blank" rel="noopener">教你免费搭建个人博客，Hexo&amp;Github</a></p><p>2.<a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">GitHub+Hexo 搭建个人网站详细教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直想有一个可以记录的属于自己的博客，最近在知乎上看到了利用&lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;+&lt;a href=&quot;https://github.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;搭建博客的教程，于是乎搭建了自己的博客&lt;a href=&quot;https://paradoxallen.github.io/&quot;&gt;paradoxallen&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;然而在此过程也遇到了一些bug，希望以下图文并茂的教程（虽然已经有挺多类似的教程…但主要是想自己写一篇文章!!!而且保证超级详细!!!）可以帮助大家少走弯路，搭建属于自己的博客。&lt;/p&gt;
    
    </summary>
    
      <category term="博客开发" scheme="https://paradoxallen.github.io/categories/%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="hexo" scheme="https://paradoxallen.github.io/tags/hexo/"/>
    
      <category term="博客" scheme="https://paradoxallen.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="GitHub" scheme="https://paradoxallen.github.io/tags/GitHub/"/>
    
  </entry>
  
</feed>
